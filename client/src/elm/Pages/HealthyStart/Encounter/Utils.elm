module Pages.HealthyStart.Encounter.Utils exposing (..)

import AssocList as Dict
import Backend.Entities exposing (..)
import Backend.HealthyStartEncounter.Model exposing (..)
import Backend.HealthyStartEncounter.Utils exposing (isNurseEncounter, lmpToEDDDate)
import Backend.Measurement.Model exposing (..)
import Backend.Measurement.Utils exposing (getHeightValue, getMeasurementValueFunc, muacValueFunc, weightValueFunc)
import Backend.Model exposing (ModelIndexedDb)
import Backend.NutritionEncounter.Utils
import Backend.PrenatalEncounter.Types exposing (PrenatalDiagnosis(..))
import EverySet
import Gizra.NominalDate exposing (NominalDate, formatDDMMYYYY)
import Maybe.Extra exposing (isJust, orElse, unwrap)
import Pages.HealthyStart.Model exposing (AssembledData, PreviousEncounterData)
import Pages.HealthyStart.Utils exposing (..)
import RemoteData exposing (RemoteData(..), WebData)
import Translate exposing (Language, translate)
import Utils.NominalDate exposing (sortEncounterTuples, sortEncounterTuplesDesc)


a =
    6



-- getAllActivities : AssembledData -> List HealthyStartActivity
-- getAllActivities assembled =
--     case assembled.encounter.encounterType of
--         NurseEncounter ->
--             if nurseEncounterNotPerformed assembled then
--                 [ PregnancyDating
--                 , History
--                 , Examination
--                 , FamilyPlanning
--                 , Medication
--                 , Backend.HealthyStartActivity.Model.MalariaPrevention
--                 , DangerSigns
--                 , SymptomReview
--                 , HealthyStartImmunisation
--                 , Laboratory
--                 , MaternalMentalHealth
--                 , HealthyStartPhoto
--                 , NextSteps
--                 ]
--
--             else
--                 [ DangerSigns
--                 , SymptomReview
--                 , History
--                 , Examination
--                 , FamilyPlanning
--                 , HealthyStartTreatmentReview
--                 , Backend.HealthyStartActivity.Model.MalariaPrevention
--                 , HealthyStartImmunisation
--                 , Laboratory
--                 , MaternalMentalHealth
--                 , HealthyStartPhoto
--                 , NextSteps
--                 ]
--
--         NursePostpartumEncounter ->
--             [ PregnancyOutcome
--             , SymptomReview
--             , MaternalMentalHealth
--             , Backend.HealthyStartActivity.Model.Breastfeeding
--             , Examination
--             , FamilyPlanning
--             , PostpartumTreatmentReview
--             , SpecialityCare
--             , NextSteps
--             ]
--
--         ChwFirstEncounter ->
--             [ PregnancyDating, Laboratory, DangerSigns, Backend.HealthyStartActivity.Model.HealthEducation, NextSteps ]
--
--         ChwSecondEncounter ->
--             [ DangerSigns, BirthPlan, Backend.HealthyStartActivity.Model.HealthEducation, NextSteps ]
--
--         ChwThirdPlusEncounter ->
--             [ DangerSigns, Backend.HealthyStartActivity.Model.HealthEducation, NextSteps ]
--
--         ChwPostpartumEncounter ->
--             [ PregnancyOutcome, DangerSigns, NextSteps ]
--
--
-- getSubsequentEncounterType : HealthyStartEncounterType -> Maybe HealthyStartEncounterType
-- getSubsequentEncounterType currentEncounterType =
--     case currentEncounterType of
--         NurseEncounter ->
--             Nothing
--
--         NursePostpartumEncounter ->
--             Nothing
--
--         ChwFirstEncounter ->
--             Just ChwSecondEncounter
--
--         ChwSecondEncounter ->
--             Just ChwThirdPlusEncounter
--
--         ChwThirdPlusEncounter ->
--             Just ChwThirdPlusEncounter
--
--         ChwPostpartumEncounter ->
--             Nothing
--
--
-- calculateEDDandEGADays : NominalDate -> NominalDate -> ( NominalDate, Int )
-- calculateEDDandEGADays currentDate lmpDate =
--     ( lmpToEDDDate lmpDate
--     , calculateEGADays currentDate lmpDate
--     )
--
--
-- generateEGAWeeksDaysLabel : Language -> Int -> String
-- generateEGAWeeksDaysLabel language diffInDays =
--     let
--         diffInWeeks =
--             diffInDays // 7
--
--         egaWeeks =
--             translate language <| Translate.WeekSinglePlural diffInWeeks
--
--         egaDays =
--             translate language <| Translate.DaySinglePlural (diffInDays - 7 * diffInWeeks)
--     in
--     egaWeeks ++ ", " ++ egaDays
--
--
-- generateEDDandEGA : Language -> NominalDate -> ( String, String ) -> Maybe NominalDate -> ( String, String )
-- generateEDDandEGA language currentDate defaults maybeLmpDate =
--     unwrap
--         defaults
--         (\lmpDate ->
--             let
--                 ( eddDate, diffInDays ) =
--                     calculateEDDandEGADays currentDate lmpDate
--             in
--             ( formatDDMMYYYY eddDate, generateEGAWeeksDaysLabel language diffInDays )
--         )
--         maybeLmpDate
--
--
-- generateGravida : ObstetricHistoryValue -> String
-- generateGravida value =
--     let
--         total =
--             (value.termPregnancy + value.preTermPregnancy + value.stillbirthsAtTerm + value.stillbirthsPreTerm + value.abortions)
--                 + (if value.currentlyPregnant then
--                     1
--
--                    else
--                     0
--                   )
--     in
--     if total < 10 then
--         "0" ++ String.fromInt total
--
--     else
--         String.fromInt total
--
--
-- generatePara : ObstetricHistoryValue -> String
-- generatePara value =
--     String.fromInt (value.termPregnancy + value.stillbirthsAtTerm)
--         ++ String.fromInt (value.preTermPregnancy + value.stillbirthsPreTerm)
--         ++ String.fromInt value.abortions
--         ++ String.fromInt value.liveChildren
--
--
-- getLmpValue : HealthyStartMeasurements -> Maybe LastMenstrualPeriodValue
-- getLmpValue =
--     .lastMenstrualPeriod >> getMeasurementValueFunc
--
--
-- getObstetricHistory : HealthyStartMeasurements -> Maybe ObstetricHistoryValue
-- getObstetricHistory measurements =
--     measurements.obstetricHistory
--         |> getMeasurementValueFunc
--
--
-- resolveGlobalLmpValue : List HealthyStartMeasurements -> List HealthyStartMeasurements -> HealthyStartMeasurements -> Maybe LastMenstrualPeriodValue
-- resolveGlobalLmpValue nursePreviousMeasurements chwPreviousMeasurements measurements =
--     let
--         -- When measurements list is not empty, we know that Lmp date
--         -- will be located at head of the list, becuase previous measurements
--         -- are sorted ASC by encounter date, and Lmp date is a mandatory
--         -- measurement at first encounter.
--         getLmpValueFromList measurementsList =
--             List.head measurementsList
--                 |> Maybe.andThen getLmpValue
--     in
--     getLmpValueFromList nursePreviousMeasurements
--         |> orElse (getLmpValue measurements)
--         |> orElse (getLmpValueFromList chwPreviousMeasurements)
--
--
-- resolveGlobalLmpDate : List HealthyStartMeasurements -> List HealthyStartMeasurements -> HealthyStartMeasurements -> Maybe NominalDate
-- resolveGlobalLmpDate nursePreviousMeasurements chwPreviousMeasurements measurements =
--     resolveGlobalLmpValue nursePreviousMeasurements chwPreviousMeasurements measurements
--         |> Maybe.map .date
--
--
-- resolveGlobalObstetricHistory : List HealthyStartMeasurements -> HealthyStartMeasurements -> Maybe ObstetricHistoryValue
-- resolveGlobalObstetricHistory nursePreviousMeasurements measurements =
--     -- When there are no previous measurements, we try to resolve
--     -- from current encounter.
--     if List.isEmpty nursePreviousMeasurements then
--         getObstetricHistory measurements
--
--     else
--         -- When there are previous measurements, we know that Lmp Obstetric history
--         -- will be located at head of the list, becuase previous measurements
--         -- are sorted by encounter date, and Obstetric history date is a mandatory measurement.
--         nursePreviousMeasurements
--             |> List.head
--             |> Maybe.andThen getObstetricHistory
--
--
-- getHealthyStartEncountersForParticipant : ModelIndexedDb -> IndividualEncounterParticipantId -> List ( HealthyStartEncounterId, HealthyStartEncounter )
-- getHealthyStartEncountersForParticipant db participantId =
--     Backend.NutritionEncounter.Utils.getHealthyStartEncountersForParticipant db participantId
--         |> List.sortWith sortEncounterTuplesDesc
--
--
-- generatePreviousMeasurements :
--     HealthyStartEncounterId
--     -> IndividualEncounterParticipantId
--     -> ModelIndexedDb
--     ->
--         ( List PreviousEncounterData
--         , List ( NominalDate, HealthyStartEncounterType, HealthyStartMeasurements )
--         )
-- generatePreviousMeasurements currentEncounterId participantId db =
--     getHealthyStartEncountersForParticipant db participantId
--         |> List.filter
--             (\( id, _ ) ->
--                 -- We do not want to get data of current encounter.
--                 id /= currentEncounterId
--             )
--         |> List.sortWith sortEncounterTuples
--         |> (\previousEncounters ->
--                 let
--                     ( nurseEncounters, chwEncounters ) =
--                         List.partition (Tuple.second >> .encounterType >> isNurseEncounter) previousEncounters
--
--                     getEncounterDataForNurse ( encounterId, encounter ) =
--                         case Dict.get encounterId db.prenatalMeasurements of
--                             Just (Success measurements) ->
--                                 Just
--                                     { startDate = encounter.startDate
--                                     , diagnoses = encounter.diagnoses
--                                     , pastDiagnoses = encounter.pastDiagnoses
--                                     , measurements = measurements
--                                     }
--
--                             _ ->
--                                 Nothing
--
--                     getEncounterDataForChw ( encounterId, encounter ) =
--                         case Dict.get encounterId db.prenatalMeasurements of
--                             Just (Success measurements) ->
--                                 Just ( encounter.startDate, encounter.encounterType, measurements )
--
--                             _ ->
--                                 Nothing
--                 in
--                 ( List.filterMap getEncounterDataForNurse nurseEncounters
--                 , List.filterMap getEncounterDataForChw chwEncounters
--                 )
--            )
--
--


generateAssembledData : HealthyStartEncounterId -> ModelIndexedDb -> WebData AssembledData
generateAssembledData id db =
    let
        encounter =
            Dict.get id db.healthyStartEncounters
                |> Maybe.withDefault NotAsked

        measurements =
            Dict.get id db.healthyStartMeasurements
                |> Maybe.withDefault NotAsked

        participant =
            RemoteData.andThen
                (\encounter_ ->
                    Dict.get encounter_.participant db.individualParticipants
                        |> Maybe.withDefault NotAsked
                )
                encounter

        person =
            RemoteData.andThen
                (\participant_ ->
                    Dict.get participant_.person db.people
                        |> Maybe.withDefault NotAsked
                )
                participant

        previousMeasurements =
            -- @todo
            --     List.map .measurements nursePreviousEncountersData
            --
            -- ( nursePreviousEncountersData, chwPreviousMeasurementsWithDates ) =
            --     RemoteData.toMaybe encounter
            --         |> Maybe.map
            --             (\encounter_ ->
            --                 generatePreviousMeasurements id encounter_.participant db
            --             )
            --         |> Maybe.withDefault ( [], [] )
            []

        globalLmpDate =
            -- @todo
            -- measurements
            --     |> RemoteData.map (resolveGlobalLmpDate nursePreviousMeasurements chwPreviousMeasurements)
            --     |> RemoteData.withDefault Nothing
            Nothing

        globalObstetricHistory =
            -- @todo
            -- measurements
            --     |> RemoteData.map (resolveGlobalObstetricHistory nursePreviousMeasurements)
            --     |> RemoteData.withDefault Nothing
            Nothing

        ( vaccinationHistory, vaccinationProgress ) =
            -- @todo
            -- ( generateVaccinationProgress nursePreviousMeasurements
            -- , RemoteData.toMaybe measurements
            --     |> Maybe.map (\measurements_ -> measurements_ :: nursePreviousMeasurements)
            --     |> Maybe.withDefault nursePreviousMeasurements
            --     |> generateVaccinationProgress
            -- )
            ( Dict.empty, Dict.empty )
    in
    RemoteData.map AssembledData (Success id)
        |> RemoteData.andMap encounter
        |> RemoteData.andMap participant
        |> RemoteData.andMap person
        |> RemoteData.andMap measurements
        |> RemoteData.andMap (Success previousMeasurements)
        |> RemoteData.andMap (Success globalLmpDate)
        |> RemoteData.andMap (Success globalObstetricHistory)
        |> RemoteData.andMap (Success vaccinationHistory)
        |> RemoteData.andMap (Success vaccinationProgress)


getFirstNurseEncounterMeasurements : AssembledData -> HealthyStartMeasurements
getFirstNurseEncounterMeasurements assembled =
    case assembled.previousEncountersData of
        [] ->
            assembled.measurements

        encounterData :: _ ->
            encounterData.measurements



--
--
-- getLastEncounterMeasurementsWithDate : NominalDate -> Bool -> AssembledData -> ( NominalDate, HealthyStartMeasurements )
-- getLastEncounterMeasurementsWithDate currentDate isChw assembled =
--     case List.reverse assembled.nursePreviousEncountersData of
--         [] ->
--             if isChw then
--                 ( currentDate, emptyHealthyStartMeasurements )
--
--             else
--                 ( assembled.encounter.startDate, assembled.measurements )
--
--         encounterData :: _ ->
--             ( encounterData.startDate, encounterData.measurements )
--
--
-- getLastEncounterMeasurements : NominalDate -> Bool -> AssembledData -> HealthyStartMeasurements
-- getLastEncounterMeasurements currentDate isChw assembled =
--     getLastEncounterMeasurementsWithDate currentDate isChw assembled |> Tuple.second
--
--
-- getAllNurseMeasurements : NominalDate -> Bool -> AssembledData -> List PreviousEncounterData
-- getAllNurseMeasurements currentDate isChw assembled =
--     let
--         currentEncounterData =
--             if isChw then
--                 []
--
--             else
--                 [ { startDate = assembled.encounter.startDate
--                   , diagnoses = assembled.encounter.diagnoses
--                   , pastDiagnoses = assembled.encounter.pastDiagnoses
--                   , measurements = assembled.measurements
--                   }
--                 ]
--     in
--     currentEncounterData
--         ++ assembled.nursePreviousEncountersData
--
--
-- generateRecurringHighSeverityAlertData : Language -> NominalDate -> Bool -> AssembledData -> RecurringHighSeverityAlert -> List ( String, String, String )
-- generateRecurringHighSeverityAlertData language currentDate isChw assembled alert =
--     let
--         trans =
--             translate language
--
--         transAlert alert_ =
--             trans (Translate.RecurringHighSeverityAlert alert_)
--     in
--     case alert of
--         BloodPressure ->
--             let
--                 resolveAlert data =
--                     getMeasurementValueFunc data.measurements.vitals
--                         |> Maybe.andThen
--                             (\value ->
--                                 let
--                                     viewAlert sys_ dia_ =
--                                         case ( sys_, dia_ ) of
--                                             ( Just sys, Just dia ) ->
--                                                 if sys > 180 || dia > 100 then
--                                                     Just
--                                                         ( trans Translate.High ++ " " ++ transAlert alert
--                                                         , String.fromFloat sys ++ "/" ++ String.fromFloat dia ++ trans Translate.MMHGUnit
--                                                         , formatDDMMYYYY data.startDate
--                                                         )
--
--                                                 else
--                                                     Nothing
--
--                                             _ ->
--                                                 Nothing
--                                 in
--                                 Maybe.Extra.or
--                                     (viewAlert value.sysRepeated value.diaRepeated)
--                                     (viewAlert value.sys value.dia)
--                             )
--             in
--             getAllNurseMeasurements currentDate isChw assembled
--                 |> List.filterMap resolveAlert
--
--
-- generateObstetricalDiagnosisAlertData :
--     Language
--     -> NominalDate
--     -> Bool
--     -> HealthyStartMeasurements
--     -> AssembledData
--     -> ObstetricalDiagnosis
--     -> Maybe String
-- generateObstetricalDiagnosisAlertData language currentDate isChw firstNurseEncounterMeasurements assembled diagnosis =
--     let
--         transAlert diagnosis_ =
--             translate language (Translate.ObstetricalDiagnosisAlert diagnosis_)
--
--         lastEncounterMeasurements =
--             getLastEncounterMeasurements currentDate isChw assembled
--     in
--     case diagnosis of
--         DiagnosisModerateUnderweight ->
--             let
--                 severeUnderweight =
--                     isJust <|
--                         generateObstetricalDiagnosisAlertData
--                             language
--                             currentDate
--                             isChw
--                             firstNurseEncounterMeasurements
--                             assembled
--                             DiagnosisSevereUnderweight
--             in
--             if severeUnderweight then
--                 Nothing
--
--             else
--                 let
--                     resolveAlert measurements =
--                         measurements.nutrition
--                             |> Maybe.andThen
--                                 (\measurement ->
--                                     let
--                                         muac =
--                                             Tuple.second measurement
--                                                 |> .value
--                                                 |> .muac
--                                                 |> muacValueFunc
--                                     in
--                                     if muac >= 18.5 && muac < 22 then
--                                         Just (transAlert diagnosis)
--
--                                     else
--                                         Nothing
--                                 )
--                 in
--                 -- If nutrition measurements were taken at current encounter,
--                 -- we issue the alarm according to those values.
--                 -- Otherwise, we use values of last encounter.
--                 if isJust assembled.measurements.nutrition then
--                     resolveAlert assembled.measurements
--
--                 else
--                     resolveAlert lastEncounterMeasurements
--
--         DiagnosisSevereUnderweight ->
--             let
--                 resolveAlert measurements =
--                     measurements.nutrition
--                         |> Maybe.andThen
--                             (\measurement ->
--                                 let
--                                     muac =
--                                         Tuple.second measurement
--                                             |> .value
--                                             |> .muac
--                                             |> muacValueFunc
--                                 in
--                                 if muac < 18.5 then
--                                     Just (transAlert diagnosis)
--
--                                 else
--                                     let
--                                         height =
--                                             Tuple.second measurement
--                                                 |> .value
--                                                 |> .height
--                                                 |> getHeightValue
--
--                                         weight =
--                                             Tuple.second measurement
--                                                 |> .value
--                                                 |> .weight
--                                                 |> weightValueFunc
--                                     in
--                                     calculateBmi (Just height) (Just weight)
--                                         |> Maybe.andThen
--                                             (\bmi_ ->
--                                                 if bmi_ < 18.5 then
--                                                     Just (transAlert diagnosis)
--
--                                                 else
--                                                     Nothing
--                                             )
--                             )
--             in
--             -- If nutrition measurements were taken at current encounter,
--             -- we issue the alarm according to those values.
--             -- Otherwise, we use values of last encounter.
--             if isJust assembled.measurements.nutrition then
--                 resolveAlert assembled.measurements
--
--             else
--                 resolveAlert lastEncounterMeasurements
--
--         DiagnosisOverweight ->
--             let
--                 resolveAlert measurements =
--                     measurements.nutrition
--                         |> Maybe.andThen
--                             (\measurement ->
--                                 let
--                                     height =
--                                         Tuple.second measurement
--                                             |> .value
--                                             |> .height
--                                             |> getHeightValue
--
--                                     weight =
--                                         Tuple.second measurement
--                                             |> .value
--                                             |> .weight
--                                             |> weightValueFunc
--                                 in
--                                 calculateBmi (Just height) (Just weight)
--                                     |> Maybe.andThen
--                                         (\bmi_ ->
--                                             if bmi_ >= 25 && bmi_ <= 30 then
--                                                 Just (transAlert diagnosis)
--
--                                             else
--                                                 Nothing
--                                         )
--                             )
--             in
--             -- If nutrition measurements were taken at current encounter,
--             -- we issue the alarm according to those values.
--             -- Otherwise, we use values of last encounter.
--             if isJust assembled.measurements.nutrition then
--                 resolveAlert assembled.measurements
--
--             else
--                 resolveAlert lastEncounterMeasurements
--
--         DiagnosisObese ->
--             let
--                 resolveAlert measurements =
--                     measurements.nutrition
--                         |> Maybe.andThen
--                             (\measurement ->
--                                 let
--                                     height =
--                                         Tuple.second measurement
--                                             |> .value
--                                             |> .height
--                                             |> getHeightValue
--
--                                     weight =
--                                         Tuple.second measurement
--                                             |> .value
--                                             |> .weight
--                                             |> weightValueFunc
--                                 in
--                                 calculateBmi (Just height) (Just weight)
--                                     |> Maybe.andThen
--                                         (\bmi_ ->
--                                             if bmi_ > 30 then
--                                                 Just (transAlert diagnosis)
--
--                                             else
--                                                 Nothing
--                                         )
--                             )
--             in
--             -- If nutrition measurements were taken at current encounter,
--             -- we issue the alarm according to those values.
--             -- Otherwise, we use values of last encounter.
--             if isJust assembled.measurements.nutrition then
--                 resolveAlert assembled.measurements
--
--             else
--                 resolveAlert lastEncounterMeasurements
--
--         DisgnosisPeripheralEdema ->
--             let
--                 resolveAlert measurements =
--                     measurements.corePhysicalExam
--                         |> Maybe.andThen
--                             (\measurement ->
--                                 let
--                                     hands =
--                                         Tuple.second measurement |> .value |> .hands
--
--                                     legs =
--                                         Tuple.second measurement |> .value |> .legs
--                                 in
--                                 if
--                                     EverySet.member Backend.Measurement.Model.EdemaHands hands
--                                         || EverySet.member Backend.Measurement.Model.EdemaLegs legs
--                                 then
--                                     Just (transAlert diagnosis)
--
--                                 else
--                                     Nothing
--                             )
--             in
--             -- If corePhysicalExam measurements were taken at current encounter,
--             -- we issue the alarm according to those values.
--             -- Otherwise, we use values of last encounter.
--             if isJust assembled.measurements.corePhysicalExam then
--                 resolveAlert assembled.measurements
--
--             else
--                 resolveAlert lastEncounterMeasurements
--
--         DiagnosisFetusBreech ->
--             let
--                 resolveAlert measurements =
--                     assembled.globalLmpDate
--                         |> Maybe.andThen
--                             (\lmpDate ->
--                                 let
--                                     egaInWeeks =
--                                         calculateEGAWeeks currentDate lmpDate
--                                 in
--                                 if egaInWeeks < 32 then
--                                     Nothing
--
--                                 else
--                                     measurements.obstetricalExam
--                                         |> Maybe.andThen
--                                             (\measurement ->
--                                                 let
--                                                     value =
--                                                         Tuple.second measurement |> .value |> .fetalPresentation
--                                                 in
--                                                 if value == Backend.Measurement.Model.FetalBreech then
--                                                     Just (transAlert diagnosis)
--
--                                                 else
--                                                     Nothing
--                                             )
--                             )
--             in
--             -- If obstetricalExam measurements were taken at current encounter,
--             -- we issue the alarm according to those values.
--             -- Otherwise, we use values of last encounter.
--             if isJust assembled.measurements.obstetricalExam then
--                 resolveAlert assembled.measurements
--
--             else
--                 resolveAlert lastEncounterMeasurements
--
--         DiagnosisFetusTransverse ->
--             let
--                 resolveAlert measurements =
--                     assembled.globalLmpDate
--                         |> Maybe.andThen
--                             (\lmpDate ->
--                                 let
--                                     egaInWeeks =
--                                         calculateEGAWeeks currentDate lmpDate
--                                 in
--                                 if egaInWeeks < 32 then
--                                     Nothing
--
--                                 else
--                                     measurements.obstetricalExam
--                                         |> Maybe.andThen
--                                             (\measurement ->
--                                                 let
--                                                     value =
--                                                         Tuple.second measurement |> .value |> .fetalPresentation
--                                                 in
--                                                 if value == Backend.Measurement.Model.Transverse then
--                                                     Just (transAlert diagnosis)
--
--                                                 else
--                                                     Nothing
--                                             )
--                             )
--             in
--             -- If obstetricalExam measurements were taken at current encounter,
--             -- we issue the alarm according to those values.
--             -- Otherwise, we use values of last encounter.
--             if isJust assembled.measurements.obstetricalExam then
--                 resolveAlert assembled.measurements
--
--             else
--                 resolveAlert lastEncounterMeasurements
--
--         DiagnosisBreastExamination ->
--             let
--                 resolveAlert measurements =
--                     measurements.breastExam
--                         |> Maybe.andThen
--                             (\measurement ->
--                                 let
--                                     signs =
--                                         Tuple.second measurement |> .value |> .exam
--                                 in
--                                 if
--                                     EverySet.isEmpty signs
--                                         || EverySet.member Backend.Measurement.Model.NormalBreast signs
--                                 then
--                                     Nothing
--
--                                 else
--                                     let
--                                         transSigns =
--                                             EverySet.toList signs
--                                                 |> List.map (\sign -> translate language (Translate.BreastExamSign sign))
--                                                 |> List.intersperse ", "
--                                                 |> String.concat
--                                     in
--                                     Just (transAlert diagnosis ++ " " ++ transSigns)
--                             )
--             in
--             -- If breastExam measurements were taken at current encounter,
--             -- we issue the alarm according to those values.
--             -- Otherwise, we use values of last encounter.
--             if isJust assembled.measurements.breastExam then
--                 resolveAlert assembled.measurements
--
--             else
--                 resolveAlert lastEncounterMeasurements
--
--         DiagnosisHypotension ->
--             let
--                 lowBloodPressureOccasions =
--                     getAllNurseMeasurements currentDate isChw assembled
--                         |> List.filterMap
--                             (.measurements
--                                 >> .vitals
--                                 >> getMeasurementValueFunc
--                                 >> Maybe.andThen
--                                     (\value ->
--                                         case ( value.sys, value.dia ) of
--                                             ( Just sys, Just dia ) ->
--                                                 if sys < 110 || dia < 70 then
--                                                     Just True
--
--                                                 else
--                                                     Nothing
--
--                                             _ ->
--                                                 Nothing
--                                     )
--                             )
--                         |> List.length
--             in
--             if lowBloodPressureOccasions > 1 then
--                 Just (transAlert diagnosis)
--
--             else
--                 Nothing
--
--         DiagnosisPregnancyInducedHypertension ->
--             if isJust (generateMedicalDiagnosisAlertData language currentDate firstNurseEncounterMeasurements DiagnosisHypertensionBeforePregnancy) then
--                 Nothing
--
--             else
--                 let
--                     highBloodPressureOccasions =
--                         getAllNurseMeasurements currentDate isChw assembled
--                             |> List.filterMap
--                                 (.measurements
--                                     >> .vitals
--                                     >> getMeasurementValueFunc
--                                     >> Maybe.andThen
--                                         (\value ->
--                                             case ( value.sys, value.dia ) of
--                                                 ( Just sys, Just dia ) ->
--                                                     if sys > 140 || dia > 90 then
--                                                         Just True
--
--                                                     else
--                                                         Nothing
--
--                                                 _ ->
--                                                     Nothing
--                                         )
--                                 )
--                             |> List.length
--                 in
--                 if highBloodPressureOccasions > 1 then
--                     Just (transAlert diagnosis)
--
--                 else
--                     Nothing
--
--         DiagnosisPreeclampsiaHighRisk ->
--             let
--                 resolveAlert measurements =
--                     getMeasurementValueFunc measurements.vitals
--                         |> Maybe.andThen
--                             (\value ->
--                                 case ( value.sys, value.dia ) of
--                                     ( Just sys, Just dia ) ->
--                                         if sys > 140 || dia > 90 then
--                                             measurements.corePhysicalExam
--                                                 |> Maybe.andThen
--                                                     (\corePhysicalExam ->
--                                                         let
--                                                             hands =
--                                                                 Tuple.second corePhysicalExam |> .value |> .hands
--
--                                                             legs =
--                                                                 Tuple.second corePhysicalExam |> .value |> .legs
--                                                         in
--                                                         if
--                                                             EverySet.member Backend.Measurement.Model.EdemaHands hands
--                                                                 || EverySet.member Backend.Measurement.Model.EdemaLegs legs
--                                                         then
--                                                             Just (transAlert diagnosis)
--
--                                                         else
--                                                             Nothing
--                                                     )
--
--                                         else
--                                             Nothing
--
--                                     _ ->
--                                         Nothing
--                             )
--             in
--             -- If vitals and corePhysicalExam measurements were taken
--             -- at current encounter, we issue the alarm according to those values.
--             -- Otherwise, we use values of last encounter.
--             if isJust assembled.measurements.vitals && isJust assembled.measurements.corePhysicalExam then
--                 resolveAlert assembled.measurements
--
--             else
--                 resolveAlert lastEncounterMeasurements
--
--
-- generateMedicalDiagnosisAlertData : Language -> NominalDate -> HealthyStartMeasurements -> MedicalDiagnosis -> Maybe String
-- generateMedicalDiagnosisAlertData language currentDate measurements diagnosis =
--     let
--         generateAlertForDiagnosis getFieldFunc triggeringSigns =
--             getMeasurementValueFunc measurements.medicalHistory
--                 |> Maybe.map getFieldFunc
--                 |> Maybe.andThen
--                     (\value ->
--                         if
--                             List.any (\sign -> EverySet.member sign value)
--                                 triggeringSigns
--                         then
--                             Just <| translate language (Translate.MedicalDiagnosisAlert diagnosis)
--
--                         else
--                             Nothing
--                     )
--     in
--     case diagnosis of
--         DiagnosisUterineMyoma ->
--             Maybe.Extra.or
--                 (generateAlertForDiagnosis .physicalConditions
--                     [ Backend.Measurement.Model.PhysicalConditionUterineMyomaCurrent
--                     , Backend.Measurement.Model.PhysicalConditionUterineMyomaSurgicalResection
--                     ]
--                 )
--                 -- Support for legacy value.
--                 (generateAlertForDiagnosis .signs [ Backend.Measurement.Model.UterineMyoma ])
--
--         Backend.HealthyStartActivity.Model.DiagnosisDiabetes ->
--             generateAlertForDiagnosis .signs [ Backend.Measurement.Model.Diabetes ]
--
--         DiagnosisCardiacDisease ->
--             generateAlertForDiagnosis .signs [ Backend.Measurement.Model.CardiacDisease ]
--
--         DiagnosisRenalDisease ->
--             generateAlertForDiagnosis .signs [ Backend.Measurement.Model.RenalDisease ]
--
--         DiagnosisHypertensionBeforePregnancy ->
--             generateAlertForDiagnosis .signs [ Backend.Measurement.Model.HypertensionBeforePregnancy ]
--
--         Backend.HealthyStartActivity.Model.DiagnosisTuberculosis ->
--             generateAlertForDiagnosis .infectiousDiseases
--                 [ Backend.Measurement.Model.InfectiousDiseasesTuberculosisPast
--                 , Backend.Measurement.Model.InfectiousDiseasesTuberculosisPresent
--                 ]
--
--         DiagnosisAsthma ->
--             generateAlertForDiagnosis .signs [ Backend.Measurement.Model.Asthma ]
--
--         DiagnosisBowedLegs ->
--             generateAlertForDiagnosis .physicalConditions [ Backend.Measurement.Model.PhysicalConditionBowedLegs ]
--
--         DiagnosisKnownHIV ->
--             generateAlertForDiagnosis .infectiousDiseases [ Backend.Measurement.Model.InfectiousDiseasesHIV ]
--
--         DiagnosisMentalHealthHistory ->
--             Maybe.Extra.or
--                 (generateAlertForDiagnosis .mentalHealthIssues
--                     [ Backend.Measurement.Model.MentalHealthIssueGeneralDepression
--                     , Backend.Measurement.Model.MentalHealthIssuePerinatalDepression
--                     , Backend.Measurement.Model.MentalHealthIssueSchizophrenia
--                     , Backend.Measurement.Model.MentalHealthIssueTrauma
--                     ]
--                 )
--                 -- Support for legacy value.
--                 (generateAlertForDiagnosis .signs [ Backend.Measurement.Model.MentalHealthHistory ])
--
--
-- calculateBmi : Maybe Float -> Maybe Float -> Maybe Float
-- calculateBmi maybeHeight maybeWeight =
--     Maybe.map2 (\height weight -> weight / ((height / 100) ^ 2)) maybeHeight maybeWeight
--
--
-- secondPhaseRequired : AssembledData -> Bool
-- secondPhaseRequired assembled =
--     (not <| emergencyReferalRequired assembled)
--         && (getMeasurementValueFunc assembled.measurements.labsResults
--                 |> Maybe.map
--                     (\value ->
--                         EverySet.size value.completedTests < EverySet.size value.performedTests
--                     )
--                 |> Maybe.withDefault False
--            )
--
--
-- emergencyReferalRequired : AssembledData -> Bool
-- emergencyReferalRequired assembled =
--     EverySet.toList assembled.encounter.diagnoses
--         |> List.filter diagnosisRequiresEmergencyReferal
--         |> List.isEmpty
--         |> not
--
-- diagnosisRequiresEmergencyReferal : PrenatalDiagnosis -> Bool
-- diagnosisRequiresEmergencyReferal diagnosis =
--     List.member diagnosis emergencyReferralDiagnosesInitial
