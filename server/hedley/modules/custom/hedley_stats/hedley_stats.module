<?php

/**
 * @file
 * Code for the Hedley Statistics module.
 */

// Advanced queue items.
define('HEDLEY_STATS_CALCULATE_STATS', 'hedley_stats_calculate_stats');

// Periods.
define('HEDLEY_STATS_PERIOD_THIS_MONTH', 'this_month');
define('HEDLEY_STATS_PERIOD_LAST_MONTH', 'last_month');
define('HEDLEY_STATS_PERIOD_TWO_MONTHS_AGO', 'two_months_ago');
define('HEDLEY_STATS_PERIOD_PAST_THREE_MONTHS', 'past_three_month');
define('HEDLEY_STATS_PERIOD_ONE_YEAR', 'one_year');
define('HEDLEY_STATS_PERIOD_LAST_YEAR', 'last_year');
define('HEDLEY_STATS_PERIOD_480_DAYS', '480_days');
define('HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS', 'past_six_month');

define('HEDLEY_STATS_GOOD', '1');
define('HEDLEY_STATS_MODERATE', '2');
define('HEDLEY_STATS_SEVERE', '3');

// Encounter types.
define('HEDLEY_STATS_PRENATAL_ENCOUNTER_TYPE', 'antenatal');
define('HEDLEY_STATS_ACUTE_ILLNESS_ENCOUNTER_TYPE', 'acute-illness');
define('HEDLEY_STATS_NCD_ENCOUNTER_TYPE', 'ncd');
define('HEDLEY_STATS_SPV_ENCOUNTER_TYPE', 'well-child');
define('HEDLEY_STATS_CHILD_SCOREBOARD_ENCOUNTER_TYPE', 'child-scoreboard');
define('HEDLEY_STATS_NUTRITION_ENCOUNTER_TYPE', 'nutrition');

// Statistics cache types.
define('HEDLEY_STATS_NUTRITION', 'sync_stats_nutrition');
define('HEDLEY_STATS_PRENATAL', 'sync_stats_prenatal');
define('HEDLEY_STATS_ACUTE_ILLNESS', 'sync_stats_acute_illness');
define('HEDLEY_STATS_NCD', 'sync_stats_ncd');
define('HEDLEY_STATS_PMTCT', 'sync_stats_pmtct');
define('HEDLEY_STATS_SPV', 'sync_stats_spv');
define('HEDLEY_STATS_CHILD_SCOREBOARD', 'sync_stats_child_scoreboard');
define('HEDLEY_STATS_NUTRITION_INDIVIDUAL', 'sync_stats_nutrition_individual');
define('HEDLEY_STATS_NUTRITION_GROUP', 'sync_stats_nutrition_group');

// Cache IDs.
define('HEDLEY_STATS_SYNC_STATS_CACHE', 'sync_stats_general');
define('HEDLEY_STATS_SYNC_SESSION_ATTENDANCE', 'sync_session_attendance_stats');
define('HEDLEY_STATS_SYNC_CHILDREN_BENEFICIARIES', 'sync_children_beneficiaries_stats');
define('HEDLEY_STATS_SYNC_FAMILY_PLANNING', 'sync_family_planning_stats');
define('HEDLEY_STATS_SYNC_TOTAL_ENCOUNTERS', 'sync_total_encounters_stats');
define('HEDLEY_STATS_SYNC_CASE_MANAGEMENT', 'sync_case_management_stats');
define('HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA', 'sync_acute_illness_data');
define('HEDLEY_STATS_SYNC_PRENATAL_DATA', 'sync_prenatal_data');
define('HEDLEY_STATS_SYNC_NCD_DATA', 'sync_ncd_data');
define('HEDLEY_STATS_SYNC_PMTCT_DATA', 'sync_pmtct_data');
define('HEDLEY_STATS_SYNC_SPV_DATA', 'sync_spv_data');
define('HEDLEY_STATS_SYNC_CHILD_SCOREBOARD_DATA', 'sync_child_scoreboard_data');
define('HEDLEY_STATS_SYNC_NUTRITION_INDIVIDUAL_DATA', 'sync_nutrition_individual_data');
define('HEDLEY_STATS_SYNC_NUTRITION_GROUP_DATA', 'sync_nutrition_group_data');
define('HEDLEY_STATS_SYNC_VILLAGES_WITH_RESIDENTS', 'villages_with_residents');

// Cache methods.
define('HEDLEY_STATS_CACHE_GET', 'get');
define('HEDLEY_STATS_CACHE_SET', 'set');
define('HEDLEY_STATS_CACHE_CLEAR', 'clear');

/**
 * Implements hook_node_insert().
 */
function hedley_stats_node_insert($node) {
  hedley_stats_trigger_stats_recalculation($node);
}

/**
 * Implements hook_node_update().
 */
function hedley_stats_node_update($node) {
  hedley_stats_trigger_stats_recalculation($node);
}

/**
 * If needed, reset statistics cache and trigger recalculation.
 *
 * @param object $node
 *   The node that triggered the change.
 *
 * @throws \EntityMetadataWrapperException
 */
function hedley_stats_trigger_stats_recalculation($node) {
  $cache_type_for_recalculation = hedley_stats_requires_statistics_recalculation($node);

  if ($cache_type_for_recalculation === FALSE) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  if (!$wrapper->__isset('field_shards')) {
    // Can't resolve to which health centers content belongs.
    return;
  }

  $health_centers = $wrapper->field_shards->value(['identifier' => TRUE]);

  // Get health centers.
  if (empty($health_centers)) {
    return;
  }

  foreach ($health_centers as $health_center_id) {
    // Reset statistics cache for health center, because
    // content affecting its statistics has been added / changed.
    hedley_stats_clear_caches_for_health_center($health_center_id, $cache_type_for_recalculation);

    // Schedule recalculation of statistics.
    hedley_stats_schedule_statistics_calculation_for_health_center($health_center_id);
  }
}

/**
 * Schedules statistics calculation.
 *
 * AQ task is added for statistics calculation, unless health center
 * is member of exclusion list.
 *
 * @param int $health_center_id
 *   The node ID of health center, which statistics are calculated.
 */
function hedley_stats_schedule_statistics_calculation_for_health_center($health_center_id) {
  $excluded_health_centers = variable_get('hedley_statistics_excluded_health_centers', '');
  $excluded_health_centers = explode(',', $excluded_health_centers);
  if (array_search($health_center_id, $excluded_health_centers) !== FALSE) {
    // Health center is member of the exclusion list.
    return;
  }
  // This health center is not excluded - schedule statistics
  // calculation by adding an AQ task.
  hedley_general_add_task_to_advanced_queue_by_id(HEDLEY_STATS_CALCULATE_STATS, $health_center_id, [
    'health_center_nid' => $health_center_id,
  ]);
}

/**
 * Checks if entity requires statistics recalculation.
 *
 * @param object $node
 *   The entity.
 *
 * @return string|bool
 *   The type of cache to clear. False, if clearing is not required.
 */
function hedley_stats_requires_statistics_recalculation($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  if (hedley_stats_requires_prenatal_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_PRENATAL;
  }

  if (hedley_stats_requires_acute_illness_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_ACUTE_ILLNESS;
  }

  if (hedley_stats_requires_ncd_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_NCD;
  }

  if (hedley_stats_requires_pmtct_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_PMTCT;
  }

  if (hedley_stats_requires_spv_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_SPV;
  }

  if (hedley_stats_requires_child_scoreboard_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_CHILD_SCOREBOARD;
  }

  if (hedley_stats_requires_nutrition_individual_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_NUTRITION_INDIVIDUAL;
  }

  if (hedley_stats_requires_nutrition_group_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_NUTRITION_GROUP;
  }

  // This comes last, because it's where we should fall if all previous options
  // are not meat. If HEDLEY_STATS_NUTRITION_INDIVIDUAL or
  // HEDLEY_STATS_NUTRITION_GROUP is returned, it will cover recalculation
  // of HEDLEY_STATS_NUTRITION as well.
  if (hedley_stats_requires_nutrition_statistics_recalculation($node->type)) {
    return HEDLEY_STATS_NUTRITION;
  }

  return FALSE;
}

/**
 * Checks if entity requires Nutrition statistics recalculation.
 *
 * @param string $bundle
 *   Entity bundle.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_nutrition_statistics_recalculation($bundle) {
  $triggering_types = array_merge(
    [
      HEDLEY_ACTIVITY_ATTENDANCE_CONTENT_TYPE,
      HEDLEY_ACTIVITY_FAMILY_PLANNING_CONTENT_TYPE,
      HEDLEY_ACTIVITY_NUTRITION_ENCOUNTER_CONTENT_TYPE,
      // Patients at HC needs tracking, because they may be added to
      // HC villages, and villages residents are needed for
      // statistics calculations.
      HEDLEY_ACTIVITY_PERSON_CONTENT_TYPE,
    ],
    HEDLEY_ACTIVITY_HEIGHT_BUNDLES,
    HEDLEY_ACTIVITY_NUTRITION_BUNDLES,
    HEDLEY_ACTIVITY_MUAC_BUNDLES,
    HEDLEY_ACTIVITY_WEIGHT_BUNDLES
  );

  return in_array($bundle, $triggering_types);
}

/**
 * Checks if entity requires Prenatal statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_prenatal_statistics_recalculation($wrapper) {
  $triggering_types = [
    HEDLEY_ACTIVITY_PRENATAL_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_DANGER_SIGNS_CONTENT_TYPE,
    // For send_to_hc.
    HEDLEY_ACTIVITY_PRENATAL_REFERRAL_CONTENT_TYPE,
    // For MUAC.
    HEDLEY_ACTIVITY_PRENATAL_NUTRITION_CONTENT_TYPE,
  ];
  $bundle = $wrapper->getBundle();

  if (in_array($bundle, $triggering_types)) {
    return TRUE;
  }

  if ($bundle == HEDLEY_ACTIVITY_INDIVIDUAL_PARTICIPANT_CONTENT_TYPE) {
    $encounter_type = $wrapper->field_encounter_type->value();
    return $encounter_type == HEDLEY_STATS_PRENATAL_ENCOUNTER_TYPE;
  }

  return FALSE;
}

/**
 * Checks if entity requires Acute illness statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_acute_illness_statistics_recalculation($wrapper) {
  $triggering_types = [
    HEDLEY_ACTIVITY_ACUTE_ILLNESS_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_SEND_TO_HC_CONTENT_TYPE,
    HEDLEY_ACTIVITY_ACUTE_ILLNESS_VITALS_CONTENT_TYPE,
    HEDLEY_ACTIVITY_SYMPTOMS_GENERAL_CONTENT_TYPE,
    HEDLEY_ACTIVITY_ISOLATION_CONTENT_TYPE,
    HEDLEY_ACTIVITY_CALL_114_CONTENT_TYPE,
    HEDLEY_ACTIVITY_HC_CONTAC_CONTENT_TYPE,
  ];

  $bundle = $wrapper->getBundle();

  if (in_array($bundle, $triggering_types)) {
    return TRUE;
  }

  if ($bundle == HEDLEY_ACTIVITY_INDIVIDUAL_PARTICIPANT_CONTENT_TYPE) {
    $encounter_type = $wrapper->field_encounter_type->value();
    return $encounter_type == HEDLEY_STATS_ACUTE_ILLNESS_ENCOUNTER_TYPE;
  }

  return FALSE;
}

/**
 * Checks if entity requires NCD statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_ncd_statistics_recalculation($wrapper) {
  $triggering_types = [
    HEDLEY_ACTIVITY_NCD_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NCD_OUTSIDE_CARE_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NCD_CO_MORBIDITIES_CONTENT_TYPE,
  ];
  $bundle = $wrapper->getBundle();

  if (in_array($bundle, $triggering_types)) {
    return TRUE;
  }

  if ($bundle == HEDLEY_ACTIVITY_INDIVIDUAL_PARTICIPANT_CONTENT_TYPE) {
    $encounter_type = $wrapper->field_encounter_type->value();
    return $encounter_type == HEDLEY_STATS_NCD_ENCOUNTER_TYPE;
  }

  return FALSE;
}

/**
 * Checks if entity requires PMTCT statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_pmtct_statistics_recalculation($wrapper) {
  $bundle = $wrapper->getBundle();

  return ($bundle == HEDLEY_ACTIVITY_GROUP_PARTICIPANT_CONTENT_TYPE) && ($wrapper->field_clinic->field_group_type->value() == 'pmtct');
}

/**
 * Checks if entity requires SPV statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_spv_statistics_recalculation($wrapper) {
  $triggering_types = array_merge([
    HEDLEY_ACTIVITY_WELL_CHILD_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_WELL_CHILD_HEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_WELL_CHILD_WEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_WELL_CHILD_MUAC_CONTENT_TYPE,
    HEDLEY_ACTIVITY_WELL_CHILD_NUTRITION_CONTENT_TYPE,
    HEDLEY_ACTIVITY_WELL_CHILD_HPV_IMMUNISATION_CONTENT_TYPE,
  ],
    HEDLEY_ACTIVITY_WELL_CHILD_IMMUNISATION_BUNDLES
  );

  $bundle = $wrapper->getBundle();

  if (in_array($bundle, $triggering_types)) {
    return TRUE;
  }

  if ($bundle == HEDLEY_ACTIVITY_INDIVIDUAL_PARTICIPANT_CONTENT_TYPE) {
    $encounter_type = $wrapper->field_encounter_type->value();
    return $encounter_type == HEDLEY_STATS_SPV_ENCOUNTER_TYPE;
  }

  return FALSE;
}

/**
 * Checks if entity requires SPV statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_child_scoreboard_statistics_recalculation($wrapper) {
  $triggering_types = array_merge([
    HEDLEY_ACTIVITY_CHILD_SCOREBOARD_ENCOUNTER_CONTENT_TYPE,
  ],
    HEDLEY_ACTIVITY_CHILD_SCOREBOARD_IMMUNISATION_BUNDLES
  );

  $bundle = $wrapper->getBundle();

  if (in_array($bundle, $triggering_types)) {
    return TRUE;
  }

  if ($bundle == HEDLEY_ACTIVITY_INDIVIDUAL_PARTICIPANT_CONTENT_TYPE) {
    $encounter_type = $wrapper->field_encounter_type->value();
    return $encounter_type == HEDLEY_STATS_CHILD_SCOREBOARD_ENCOUNTER_TYPE;
  }

  return FALSE;
}

/**
 * Checks if entity requires Individual Nutrition statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_nutrition_individual_statistics_recalculation($wrapper) {
  $triggering_types = [
    HEDLEY_ACTIVITY_NUTRITION_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NUTRITION_HEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NUTRITION_WEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NUTRITION_MUAC_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NUTRITION_NUTRITION_CONTENT_TYPE,
  ];

  $bundle = $wrapper->getBundle();

  if (in_array($bundle, $triggering_types)) {
    return TRUE;
  }

  if ($bundle == HEDLEY_ACTIVITY_INDIVIDUAL_PARTICIPANT_CONTENT_TYPE) {
    $encounter_type = $wrapper->field_encounter_type->value();
    return $encounter_type == HEDLEY_STATS_NUTRITION_ENCOUNTER_TYPE;
  }

  return FALSE;
}

/**
 * Checks if entity requires Group Nutrition statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_nutrition_group_statistics_recalculation($wrapper) {
  $triggering_types = [
    HEDLEY_ACTIVITY_GROUP_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_HEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_WEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_MUAC_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NUTRITION_CONTENT_TYPE,
  ];

  $bundle = $wrapper->getBundle();

  if (!in_array($bundle, $triggering_types)) {
    return FALSE;
  }

  if ($bundle == HEDLEY_ACTIVITY_GROUP_ENCOUNTER_CONTENT_TYPE) {
    // Even though clinic is a required field on group encounter,
    // we have this check to allow SimpleTest to pass.
    if (empty($wrapper->field_clinic->getIdentifier())) {
      return FALSE;
    }
    $clinic_type = $wrapper->field_clinic->field_group_type->value();
  }
  else {
    // Even though clinic is a required field on group measurements,
    // we have this check to allow SimpleTest to pass.
    if (empty($wrapper->field_session->getIdentifier())) {
      return FALSE;
    }
    $clinic_type = $wrapper->field_session->field_clinic->field_group_type->value();
  }

  // True for all triggering types which do not belong to CHW
  // clinic, since at current stage, we are interested only in data
  // generated at HC by nurses.
  return !empty($clinic_type) && $clinic_type !== 'chw';
}

/**
 * Clears all statistics related caches for a health center.
 *
 * @param int $nid
 *   Health center node ID.
 * @param string $cache_type_for_recalculation
 *   Type of statistics cache for recalculation.
 */
function hedley_stats_clear_caches_for_health_center($nid, $cache_type_for_recalculation) {
  switch ($cache_type_for_recalculation) {
    case HEDLEY_STATS_PRENATAL:
      hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_PRENATAL_DATA, $nid);
      return;

    case HEDLEY_STATS_ACUTE_ILLNESS:
      hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA, $nid);
      return;

    case HEDLEY_STATS_NCD:
      hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_NCD_DATA, $nid);
      return;

    case HEDLEY_STATS_PMTCT:
      hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_PMTCT_DATA, $nid);
      return;

    case HEDLEY_STATS_SPV:
      hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_SPV_DATA, $nid);
      return;

    case HEDLEY_STATS_CHILD_SCOREBOARD:
      hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_CHILD_SCOREBOARD_DATA, $nid);
      return;
  }

  if ($cache_type_for_recalculation == HEDLEY_STATS_NUTRITION_INDIVIDUAL) {
    // Note we do not return after, since we want to clear 'old'
    // Nutrition caches as well.
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_NUTRITION_INDIVIDUAL_DATA, $nid);
  }
  elseif ($cache_type_for_recalculation == HEDLEY_STATS_NUTRITION_GROUP) {
    // Note we do not return after, since we want to clear 'old'
    // Nutrition caches as well.
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_NUTRITION_GROUP_DATA, $nid);
  }

  // If we got this far, we need to clear Nutrition stats cache.
  $periods = [
    HEDLEY_STATS_PERIOD_THIS_MONTH,
    HEDLEY_STATS_PERIOD_LAST_MONTH,
    HEDLEY_STATS_PERIOD_TWO_MONTHS_AGO,
    HEDLEY_STATS_PERIOD_PAST_THREE_MONTHS,
    HEDLEY_STATS_PERIOD_ONE_YEAR,
    HEDLEY_STATS_PERIOD_LAST_YEAR,
  ];

  // Clear cache that doesn't have periods.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_TOTAL_ENCOUNTERS, $nid);
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_SESSION_ATTENDANCE, $nid);
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_VILLAGES_WITH_RESIDENTS, $nid);

  // Clear cache for all the periods.
  foreach ($periods as $period) {
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_FAMILY_PLANNING, $nid, $period);
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_CHILDREN_BENEFICIARIES, $nid, $period);
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_CASE_MANAGEMENT, $nid, $period);
  }
}

/**
 * Implements hook_advanced_queue_info().
 */
function hedley_stats_advanced_queue_info() {
  $items[HEDLEY_STATS_CALCULATE_STATS] = [
    'label' => t('Calculate the dashboard stats'),
    'worker callback' => 'hedley_stats_calculate_stats_worker',
    'groups' => [
      'hedley',
    ],
    // The number of seconds to retry after.
    'retry after' => 120,
    // The maximum number of attempts after a failure.
    'max attempts' => 3,
  ];

  return $items;
}

/**
 * Advanced queue worker; Calculate stats for a dashboards.
 *
 * @param object $queue_item
 *   The item object to process.
 *
 * @return array
 *   Array indicating if the process succeeded, or an array with
 *   "status" and "result" keys.
 */
function hedley_stats_calculate_stats_worker($queue_item) {
  if (!$health_center_id = $queue_item->data['health_center_nid']) {
    return [
      'status' => ADVANCEDQUEUE_STATUS_FAILURE,
      'result' => t('Does not have Health Center Node ID.'),
    ];
  }

  try {
    hedley_stats_calculate_stats_for_health_center($health_center_id);
  }
  catch (Exception $e) {
    return [
      'status' => ADVANCEDQUEUE_STATUS_FAILURE_RETRY,
      'result' => $e->getMessage(),
    ];
  }

  $params = [
    '@nid' => $health_center_id,
  ];
  return [
    'status' => ADVANCEDQUEUE_STATUS_SUCCESS,
    'result' => t('The statistics has been calculated for health center ID: @nid', $params),
  ];
}

/**
 * Generate and store in cache health center statistics data.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @throws EntityMetadataWrapperException
 */
function hedley_stats_calculate_stats_for_health_center($health_center_id) {
  // We started recalculation of HC statistics. Therefore, we delete its
  // statistics hash cache, to indicate that it's not available (until
  // recalculation is completed).
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_STATS_CACHE, $health_center_id);

  // Get all clinics of type 'FBF' for the HC.
  $clinics = hedley_health_center_get_clinics_of_health_center($health_center_id);
  // Calculate statistics that are provided for FBF clinics only.
  $fbf_clinics = !empty($clinics['fbf']) ? $clinics['fbf'] : [];
  hedley_stats_get_session_attendance_stats_by_health_center($health_center_id, $fbf_clinics);
  hedley_stats_get_case_management($health_center_id);
  hedley_stats_get_children_beneficiaries_stats_by_period($health_center_id);
  hedley_stats_get_family_planning_stats_by_period($health_center_id, HEDLEY_STATS_PERIOD_PAST_THREE_MONTHS);
  $villages_with_residents = hedley_stats_get_villages_with_residents($health_center_id);
  hedley_stats_get_total_encounters($health_center_id, $villages_with_residents);
  hedley_stats_get_acute_illness_data($health_center_id);
  hedley_stats_get_prenatal_data($health_center_id);
  hedley_stats_get_ncd_data($health_center_id);
  $pmtct_clinics = !empty($clinics['pmtct']) ? $clinics['pmtct'] : [];
  hedley_stats_get_pmtct_data($health_center_id, $pmtct_clinics);
  hedley_stats_get_spv_data($health_center_id);
  hedley_stats_get_child_scorecard_data($health_center_id);
  hedley_stats_get_nutrition_individual_data($health_center_id);
  hedley_stats_get_nutrition_group_data($health_center_id);

  $stats_cache_hash = md5(time());
  // Store in cache only the hash. All statistics have their own cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_STATS_CACHE, $health_center_id, NULL, $stats_cache_hash);

  // Free up memory.
  drupal_static_reset();
}

/**
 * Pull from cache and format statistics data for a health center.
 *
 * @param int $health_center_id
 *   The health center node ID.
 * @param string $health_center_cached_hash
 *   Current hash for Health center statistics.
 *
 * @return array
 *   Statistics data for a health center.
 *
 * @throws EntityMetadataWrapperException
 */
function hedley_stats_pull_stats_for_health_center($health_center_id, $health_center_cached_hash) {
  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_SESSION_ATTENDANCE, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $completed_program = $cache_data[0];
  $missed_sessions = $cache_data[1];

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_VILLAGES_WITH_RESIDENTS, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $villages_with_residents = $cache_data;

  $case_management = [];
  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_CASE_MANAGEMENT, $health_center_id, HEDLEY_STATS_PERIOD_ONE_YEAR);
  if ($cache_data === NULL) {
    return [];
  }
  $case_management['this_year'] = $cache_data;
  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_CASE_MANAGEMENT, $health_center_id, HEDLEY_STATS_PERIOD_LAST_YEAR);
  if ($cache_data === NULL) {
    return [];
  }
  $case_management['last_year'] = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_CHILDREN_BENEFICIARIES, $health_center_id, HEDLEY_STATS_PERIOD_ONE_YEAR);
  if ($cache_data === NULL) {
    return [];
  }
  $children_beneficiaries = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_FAMILY_PLANNING, $health_center_id, HEDLEY_STATS_PERIOD_PAST_THREE_MONTHS);
  if ($cache_data === NULL) {
    return [];
  }
  $family_planning = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_TOTAL_ENCOUNTERS, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $total_encounters = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $acute_illness_data = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_PRENATAL_DATA, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $prenatal_data = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_NCD_DATA, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $ncd_data = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_PMTCT_DATA, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $pmtct_data = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_SPV_DATA, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $spv_data = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_CHILD_SCOREBOARD_DATA, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $child_scoreboard_data = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_NUTRITION_INDIVIDUAL_DATA, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $nutrition_individual_data = $cache_data;

  $cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_NUTRITION_GROUP_DATA, $health_center_id);
  if ($cache_data === NULL) {
    return [];
  }
  $nutrition_group_data = $cache_data;

  $wrapper = entity_metadata_wrapper('node', $health_center_id);
  $health_center_uuid = $wrapper->field_uuid->value();

  $stats = [
    'vid' => 1,
    'type' => 'statistics',
    // UUID of the health center.
    'uuid' => $health_center_uuid,
    'case_management' => $case_management,
    'children_beneficiaries' => $children_beneficiaries,
    'completed_program' => $completed_program,
    'family_planning' => $family_planning,
    'missed_sessions' => $missed_sessions,
    'total_encounters' => $total_encounters,
    'acute_illness_data' => $acute_illness_data,
    'prenatal_data' => $prenatal_data,
    'ncd_data' => $ncd_data,
    'pmtct_data' => $pmtct_data,
    'spv_data' => $spv_data,
    'child_scoreboard_data' => $child_scoreboard_data,
    'nutrition_individual_data' => $nutrition_individual_data,
    'nutrition_group_data' => $nutrition_group_data,
    'villages_with_residents' => $villages_with_residents,
  ];

  $now = time();
  // UTC date and time on which statistics were generated.
  $timestamp = date('d-m-Y, H:i', $now - date('Z'));
  $stats['timestamp'] = $timestamp;
  // Update client of current hash for health center statistics.
  $stats['stats_cache_hash'] = $health_center_cached_hash;

  return $stats;
}

/**
 * Returns a list of villages UUIDs with IDs of its residents.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of villages UUIDs with IDs of its residents.
 *
 * @throws \EntityMetadataWrapperException
 */
function hedley_stats_get_villages_with_residents($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_VILLAGES_WITH_RESIDENTS, $health_center_id)) {
    return $cache_data;
  }

  $villages_ids = hedley_health_center_get_villages_by_health_center($health_center_id);

  $result = [];
  foreach (array_chunk($villages_ids, 500) as $ids) {
    $nodes = node_load_multiple($ids);
    foreach ($nodes as $node) {
      $village_uuid = $node->field_uuid[LANGUAGE_NONE][0]['value'];
      $result[$village_uuid] = hedley_chw_get_village_residents($node->nid);
    }
    // Free up memory.
    drupal_static_reset();
  }

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_VILLAGES_WITH_RESIDENTS, $health_center_id, NULL, $result);

  return $result;
}

/**
 * Return acute illnesses data that is used to generate statistics.
 *
 * We get data of all encounters for illnesses that were active during
 * past 6 months.
 * We need to know when encounters were created, it's diagnosis, if fever was
 * recorded, and several measurements.
 * Also, we add patient ID, to be able to associate it with its village.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of AI encounters data.
 *
 * @throws Exception
 */
function hedley_stats_get_acute_illness_data($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA, $health_center_id)) {
    return $cache_data;
  }

  // Pull all acute illness encounters during past 6 months.
  // Since dashboard presents data for past 6 months, we will be generating data
  // for all illnesses that had an encounter over past 6 months.
  $query = hedley_stats_get_base_query($health_center_id, 'acute_illness_encounter', HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS);

  // Resolve all participants associated with those encounters.
  hedley_general_join_field_to_query($query, 'node', 'field_individual_participant');
  $query->groupBy('field_individual_participant.field_individual_participant_target_id');

  $result = $query
    ->execute()
    ->fetchAllAssoc('field_individual_participant');

  $individual_participants = array_keys($result);
  if (empty($individual_participants)) {
    $result = [];
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA, $health_center_id, NULL, $result);
    return $result;
  }

  // Pull all participants to which resolved encounters belong, including
  // some patient data, outcome and concluded date.
  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant');
  $query->condition('node.nid', $individual_participants, 'IN');

  $fields_to_join = [
    'field_person',
    'field_outcome',
    'field_date_concluded',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }

  // Add patient birthdate, so we can calculate the age.
  $query->leftJoin('field_data_field_birth_date', 'birth_date', 'birth_date.entity_id = field_person.field_person_target_id');
  $query->addField('birth_date', 'field_birth_date_value');

  $result = hedley_stats_run_node_query_in_batches($query);

  $items = [];
  // Prepare illnesses data to be consumed by client side.
  foreach ($result as $row) {
    $items[$row->nid] = [
      'id' => $row->field_person,
      // Field for 'created' is added at hedley_stats_get_base_query().
      'created' => date_format(date_create($row->field_expected), 'Y-m-d'),
      'birth_date' => date_format(date_create($row->field_birth_date_value), 'Y-m-d'),
      // We use the 'end date' of expected fields here, because the
      // 'date concluded' field is not set when illness is resolved.
      // While we could do that for illness, 'date concluded' field was meant
      // to capture the date when pregnancy has ended - some date in past.
      'date_concluded' => !empty($row->field_expected_field_expected_value2) ? date_format(date_create($row->field_date_concluded), 'Y-m-d') : NULL,
      'outcome' => $row->field_outcome,
      'encounters' => [],
    ];
  }

  // Free up memory.
  drupal_static_reset();

  // Resolve encounters data.
  $query = hedley_stats_get_base_query($health_center_id, 'acute_illness_encounter');
  $fields_to_join = [
    'field_individual_participant',
    'field_sequence_number',
    'field_acute_illness_diagnosis',
    'field_ai_encounter_type',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }
  $query->condition('field_individual_participant.field_individual_participant_target_id', $individual_participants, 'IN');

  // Join with AI Encounter table, through which we can join measurements data.
  $query->leftJoin('field_data_field_acute_illness_encounter', 'ai_encounter', 'ai_encounter.field_acute_illness_encounter_target_id = node.nid');

  // Pull data of health center referrals.
  $query->leftJoin('field_data_field_send_to_hc', 'send_to_hc', 'send_to_hc.entity_id = ai_encounter.entity_id');
  $query->addField('send_to_hc', 'field_send_to_hc_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT send_to_hc.field_send_to_hc_value)", 'send_to_hc');

  // Pull data of recorded fever at symptoms.
  $query->leftJoin('field_data_field_fever_period', 'fever_period', 'fever_period.entity_id = ai_encounter.entity_id');
  $query->addField('fever_period', 'field_fever_period_value');
  $query->addExpression("GROUP_CONCAT(fever_period.field_fever_period_value)", 'fever_period');

  // Pull data of recorded fever at vitals.
  $query->leftJoin('field_data_field_body_temperature', 'body_temperature', 'body_temperature.entity_id = ai_encounter.entity_id');
  $query->addField('body_temperature', 'field_body_temperature_value');
  $query->addExpression("GROUP_CONCAT(body_temperature.field_body_temperature_value)", 'body_temperature');

  // Pull data of isolations - COVID suspect.
  $query->leftJoin('field_data_field_isolation', 'isolation', 'isolation.entity_id = ai_encounter.entity_id');
  $query->addField('isolation', 'field_isolation_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT isolation.field_isolation_value)", 'isolation');

  // Pull data of 114 calls - COVID suspect.
  $query->leftJoin('field_data_field_114_contact', '114_contact', '114_contact.entity_id = ai_encounter.entity_id');
  $query->addField('114_contact', 'field_114_contact_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT 114_contact.field_114_contact_value)", 'contact_114');

  // Pull data of 114 recommendations - COVID suspect.
  $query->leftJoin('field_data_field_114_recommendation', '114_recommendation', '114_recommendation.entity_id = ai_encounter.entity_id');
  $query->addField('114_recommendation', 'field_114_recommendation_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT 114_recommendation.field_114_recommendation_value)", 'recommendation_114');

  // Pull data of HC contact - COVID suspect.
  $query->leftJoin('field_data_field_hc_contact', 'hc_contact', 'hc_contact.entity_id = ai_encounter.entity_id');
  $query->addField('hc_contact', 'field_hc_contact_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT hc_contact.field_hc_contact_value)", 'contact_hc');

  // Pull data of HC recommendations - COVID suspect.
  $query->leftJoin('field_data_field_hc_recommendation', 'hc_recommendation', 'hc_recommendation.entity_id = ai_encounter.entity_id');
  $query->addField('hc_recommendation', 'field_hc_recommendation_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT hc_recommendation.field_hc_recommendation_value)", 'recommendation_hc');

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    if (empty($items[$row->field_individual_participant])) {
      // If we got here, there's an encounter that is not
      // assigned to participant.
      // This is anomaly that should not happen, since participant
      // is mandatory field.
      // However, there was one case where it happened on live,
      // so adding this check for certainty, since this failure causes
      // health center sync to get stuck, making HC devices not usable.
      continue;
    }

    $fever_by_signs = !empty($row->fever_period) && $row->fever_period > 0;
    $fever_by_vitals = !empty($row->body_temperature) && (float) $row->body_temperature >= 37.5;

    $item = [
      // Field for 'created' is added at hedley_stats_get_base_query().
      'start_date' => date_format(date_create($row->field_scheduled_date), 'Y-m-d'),
      'sequence_number' => $row->field_sequence_number,
      'diagnosis' => $row->field_acute_illness_diagnosis,
      'fever' => $fever_by_signs || $fever_by_vitals,
      'send_to_hc' => empty($row->send_to_hc) ? [] : explode(',', $row->send_to_hc),
      'isolation' => empty($row->isolation) ? [] : explode(',', $row->isolation),
      'call_114' => empty($row->contact_114) ? [] : explode(',', $row->contact_114),
      'recommendation_114' => empty($row->recommendation_114) ? [] : explode(',', $row->recommendation_114),
      'contact_hc' => empty($row->contact_hc) ? [] : explode(',', $row->contact_hc),
      'recommendation_hc' => empty($row->recommendation_hc) ? [] : explode(',', $row->recommendation_hc),
    ];

    if (!empty($row->field_ai_encounter_type)) {
      $item['encounter_type'] = $row->field_ai_encounter_type;
    }

    $items[$row->field_individual_participant]['encounters'][] = $item;
  }

  // Free up memory.
  drupal_static_reset();

  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Return pregnancies data that is used to generate ANC statistics.
 *
 * We pull data for pregnancies started during past 480 days.
 * We need to know when they were created, what was the expected delivery
 * date, and if exist, real delivery date and outcome.
 * Also, we add patient ID, to be able to associate it with its village.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of villages UUIDs with IDs of its residents.
 *
 * @throws \Exception
 */
function hedley_stats_get_prenatal_data($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_PRENATAL_DATA, $health_center_id)) {
    return $cache_data;
  }

  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant', HEDLEY_STATS_PERIOD_480_DAYS);

  $fields_to_join = [
    'field_person',
    'field_encounter_type',
    'field_expected_date_concluded',
    'field_date_concluded',
    'field_outcome',
    'field_outcome_location',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }

  // Get only participants of Antenatal type.
  $query->condition('field_encounter_type.field_encounter_type_value', HEDLEY_STATS_PRENATAL_ENCOUNTER_TYPE);

  $result = hedley_stats_run_node_query_in_batches($query);

  if (empty($result)) {
    $result = [];
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_PRENATAL_DATA, $health_center_id, NULL, $result);
    return $result;
  }

  $items = [];
  // Prepare data to be consumed by client side.
  foreach ($result as $row) {
    $items[$row->nid] = [
      'id' => $row->field_person,
      // Field for 'created' is added at hedley_stats_get_base_query().
      'created' => date_format(date_create($row->field_expected), 'Y-m-d'),
      'expected_date_concluded' => !empty($row->field_expected_date_concluded) ? date_format(date_create($row->field_expected_date_concluded), 'Y-m-d') : NULL,
      'date_concluded' => !empty($row->field_date_concluded) ? date_format(date_create($row->field_date_concluded), 'Y-m-d') : NULL,
      'outcome' => $row->field_outcome,
      'delivery_location' => $row->field_outcome_location,
      'encounters' => [],
    ];
  }

  // Free up memory.
  drupal_static_reset();

  $individual_participants = array_keys($items);

  $query = hedley_stats_get_base_query($health_center_id, 'prenatal_encounter');
  $fields_to_join = [
    'field_individual_participant',
    'field_prenatal_encounter_type',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }
  $query->condition('field_individual_participant.field_individual_participant_target_id', $individual_participants, 'IN');

  // Pull data of prenatal_diagnoses that were recorded during encounter.
  $query->leftJoin('field_data_field_prenatal_diagnoses', 'prenatal_diagnoses', 'prenatal_diagnoses.entity_id = node.nid');
  $query->addField('prenatal_diagnoses', 'field_prenatal_diagnoses_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT prenatal_diagnoses.field_prenatal_diagnoses_value)", 'prenatal_diagnoses');

  // Join with Prenatal Encounter table,
  // through which we can join measurements data.
  $query->leftJoin('field_data_field_prenatal_encounter', 'prenatal_encounter', 'prenatal_encounter.field_prenatal_encounter_target_id = node.nid');

  // Pull data of danger signs that were recorded during encounter.
  $query->leftJoin('field_data_field_danger_signs', 'danger_signs', 'danger_signs.entity_id = prenatal_encounter.entity_id');
  $query->addField('danger_signs', 'field_danger_signs_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT danger_signs.field_danger_signs_value)", 'danger_signs');

  // Pull data of MUAC that was recorded during encounter.
  $query->leftJoin('field_data_field_muac', 'muac', 'muac.entity_id = prenatal_encounter.entity_id');
  $query->addField('muac', 'field_muac_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT muac.field_muac_value)", 'muac');

  // Pull data of health center referrals that were recorded during encounter.
  $query->leftJoin('field_data_field_send_to_hc', 'send_to_hc', 'send_to_hc.entity_id = prenatal_encounter.entity_id');
  $query->addField('send_to_hc', 'field_send_to_hc_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT send_to_hc.field_send_to_hc_value)", 'send_to_hc');

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  foreach ($result as $row) {
    $item = [
      // Field for 'created' is added at hedley_stats_get_base_query().
      'start_date' => date_format(date_create($row->field_scheduled_date), 'Y-m-d'),
      'danger_signs' => explode(',', $row->danger_signs),
      'send_to_hc' => explode(',', $row->send_to_hc),
      'diagnoses' => explode(',', $row->prenatal_diagnoses),
    ];

    if (!empty($row->field_prenatal_encounter_type)) {
      $item['encounter_type'] = $row->field_prenatal_encounter_type;
    }

    if (!empty($row->muac)) {
      $item['muac'] = $row->muac;
    }

    $items[$row->field_individual_participant]['encounters'][] = $item;
  }

  // Free up memory.
  drupal_static_reset();

  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_PRENATAL_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Return NCD data that is used to generate statistics.
 *
 * We get data of all encounters for patients that were active during
 * past 6 months.
 * We need to know when encounters were created, it's
 * diagnoses and several measurements. Also, we add patient ID,
 * to be able to associate it with its village.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of NCD participant data with its encounters.
 *
 * @throws Exception
 */
function hedley_stats_get_ncd_data($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_NCD_DATA, $health_center_id)) {
    return $cache_data;
  }

  // Pull all NCD encounters during past 6 months.
  // Since dashboard presents data for past 6 months, we will be generating data
  // for all NCD participants that had an encounter over past 6 months.
  $query = hedley_stats_get_base_query($health_center_id, 'ncd_encounter', HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS);

  // Resolve all participants associated with those encounters.
  hedley_general_join_field_to_query($query, 'node', 'field_individual_participant');
  $query->groupBy('field_individual_participant.field_individual_participant_target_id');

  $result = $query
    ->execute()
    ->fetchAllAssoc('field_individual_participant');

  $individual_participants = array_keys($result);
  if (empty($individual_participants)) {
    $result = [];
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_NCD_DATA, $health_center_id, NULL, $result);
    return $result;
  }

  // Pull all participants to which resolved encounters belong, including
  // some patient data.
  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant');
  $query->condition('node.nid', $individual_participants, 'IN');

  $fields_to_join = [
    'field_person',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }

  // Add patient birthdate, so we can calculate the age.
  $query->leftJoin('field_data_field_birth_date', 'birth_date', 'birth_date.entity_id = field_person.field_person_target_id');
  $query->addField('birth_date', 'field_birth_date_value');

  $result = hedley_stats_run_node_query_in_batches($query);

  $items = [];
  // Prepare participant data to be consumed by client side.
  foreach ($result as $row) {
    $items[$row->nid] = [
      'id' => $row->field_person,
      // Field for 'created' is added at hedley_stats_get_base_query().
      'created' => date_format(date_create($row->field_expected), 'Y-m-d'),
      'birth_date' => date_format(date_create($row->field_birth_date_value), 'Y-m-d'),
      'encounters' => [],
    ];
  }

  // Free up memory.
  drupal_static_reset();

  // Resolve encounters data.
  $base_query = hedley_stats_get_base_query($health_center_id, 'ncd_encounter');
  $fields_to_join = [
    'field_individual_participant',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($base_query, 'node', $field, FALSE);
  }
  $base_query->condition('field_individual_participant.field_individual_participant_target_id', $individual_participants, 'IN');
  // Join with NCD Encounter table, through which we can join measurements data.
  $base_query->leftJoin('field_data_field_ncd_encounter', 'ncd_encounter', 'ncd_encounter.field_ncd_encounter_target_id = node.nid');

  $query = clone $base_query;
  // Pull data of prenatal_diagnoses that were recorded during encounter.
  $query->leftJoin('field_data_field_ncd_diagnoses', 'ncd_diagnoses', 'ncd_diagnoses.entity_id = node.nid');
  $query->addField('ncd_diagnoses', 'field_ncd_diagnoses_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT ncd_diagnoses.field_ncd_diagnoses_value)", 'ncd_diagnoses');

  // Pull data of medical conditions (diagnoses) that were recorded
  // during encounter at Outside care activity.
  $query->leftJoin('field_data_field_medical_conditions', 'medical_conditions', 'medical_conditions.entity_id = ncd_encounter.entity_id');
  $query->addField('medical_conditions', 'field_medical_conditions_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT medical_conditions.field_medical_conditions_value)", 'medical_conditions');

  // Pull data of comorbidities (diagnoses) that were recorded
  // during encounter at Outside care activity.
  $query->leftJoin('field_data_field_comorbidities', 'comorbidities', 'comorbidities.entity_id = ncd_encounter.entity_id');
  $query->addField('comorbidities', 'field_comorbidities_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT comorbidities.field_comorbidities_value)", 'comorbidities');

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    $items[$row->field_individual_participant]['encounters'][$row->nid] = [
      // Field for 'created' is added at hedley_stats_get_base_query().
      'start_date' => date_format(date_create($row->field_scheduled_date), 'Y-m-d'),
      'diagnoses' => explode(',', $row->ncd_diagnoses),
      'medical_conditions' => explode(',', $row->medical_conditions),
      'co_morbidities' => explode(',', $row->comorbidities),
    ];
  }

  // Free up memory.
  drupal_static_reset();

  $query = clone $base_query;

  // Run dedicated query to pull data of HIV test result recorded
  // at NCD HIV Test activity.
  // Dedicated query is mandatory since multiple bundles hold same field.
  // There are combinations where some bundles will be created, and others not.
  // As a result, if we join this field to query that pulls other data,
  // failure to pull the field for bundle fails whole query, causing loss
  // of data.
  $query->leftJoin('field_data_field_test_result', 'test_result', 'test_result.entity_id = ncd_encounter.entity_id');
  $query->addField('test_result', 'field_test_result_value');
  $query->condition('test_result.bundle', 'ncd_hiv_test');
  $query->addExpression("GROUP_CONCAT(test_result.field_test_result_value)", 'test_result');
  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    if (empty($items[$row->field_individual_participant]['encounters'][$row->nid])) {
      // There's no encounter to associate measurement with.
      // In theory, this should not be happening, but in fact this
      // have occurred on live.
      // Therefore, check was added to prevent decoder failure on client.
      continue;
    }

    $items[$row->field_individual_participant]['encounters'][$row->nid]['hiv_test_result'] = $row->test_result;
  }

  // Run dedicated query to pull data of HIV test execution note recorded
  // at NCD HIV Test activity.
  // Dedicated query is mandatory since multiple bundles hold same field.
  // There are combinations where some bundles will be created, and others not.
  // As a result, if we join this field to query that pulls other data,
  // failure to pull the field for bundle fails whole query, causing loss
  // of data.
  $query->leftJoin('field_data_field_test_execution_note', 'test_execution_note', 'test_execution_note.entity_id = ncd_encounter.entity_id');
  $query->addField('test_execution_note', 'field_test_execution_note_value');
  $query->condition('test_execution_note.bundle', 'ncd_hiv_test');
  $query->addExpression("GROUP_CONCAT(test_execution_note.field_test_execution_note_value)", 'test_execution_note');
  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    if (empty($items[$row->field_individual_participant]['encounters'][$row->nid])) {
      // There's no encounter to associate measurement with.
      // In theory, this should not be happening, but in fact this
      // have occurred on live.
      // Therefore, check was added to prevent decoder failure on client.
      continue;
    }

    $items[$row->field_individual_participant]['encounters'][$row->nid]['hiv_test_execution_note'] = $row->test_execution_note;
  }

  foreach ($items as &$item) {
    $item['encounters'] = array_values($item['encounters']);
  }
  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_NCD_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Return data of PMTCT group encounters.
 *
 * We need to know mother ID, and when participation starts and ends, to
 * be able to count mothers that got HIV (per NCD data) and participate
 * at PMTCT Group.
 *
 * @param int $health_center_id
 *   The health center node ID.
 * @param array $pmtct_clinics
 *   Nodes IDs of PMTCT clinics of health center.
 *
 * @return array
 *   List of AI encounters data.
 *
 * @throws Exception
 */
function hedley_stats_get_pmtct_data($health_center_id, array $pmtct_clinics) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_PMTCT_DATA, $health_center_id)) {
    return $cache_data;
  }

  if (empty($pmtct_clinics)) {
    $result = [];
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_PMTCT_DATA, $health_center_id, NULL, $result);
    return $result;
  }

  $query = hedley_stats_get_base_query($health_center_id, 'pmtct_participant');
  $fields_to_join = [
    'field_clinic',
    'field_adult',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }
  // Participant belong to one of PMTCT clinics of the health center.
  $query->condition('field_clinic.field_clinic_target_id', $pmtct_clinics, 'IN');
  // Participantion ends after presented period (past 6 months).
  $one_day = 24 * 3600;
  $ending_after = strtotime("first day of -5 months") - $one_day;
  $ending_after_date = date('Y-m-d 00:00:00', $ending_after);
  $query->condition('field_expected.field_expected_value2', $ending_after_date, '>');

  $result = hedley_stats_run_node_query_in_batches($query);
  $items = [];
  foreach ($result as $row) {
    $items[] = [
      'id' => $row->field_adult,
      'start_date' => date_format(date_create($row->field_expected), 'Y-m-d'),
      'end_date' => date_format(date_create($row->field_expected_field_expected_value2), 'Y-m-d'),
    ];
  }

  // Free up memory.
  drupal_static_reset();

  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_PMTCT_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Return Well Child data that is used to generate statistics.
 *
 * We get data of all encounters for patients that were active during
 * past 6 months.
 * We need to know when encounters were created, it's
 * diagnoses and several measurements. Also, we add patient ID,
 * to be able to associate it with its village.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of Well Child participant data with its encounters.
 *
 * @throws Exception
 */
function hedley_stats_get_spv_data($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_SPV_DATA, $health_center_id)) {
    return $cache_data;
  }

  // Pull all Well Child encounters during past 6 months.
  // Since dashboard presents data for past 6 months, we will be generating data
  // for all Well Child participants that had an encounter over past 6 months.
  $query = hedley_stats_get_base_query($health_center_id, 'well_child_encounter', HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS);

  // Resolve all participants associated with those encounters.
  hedley_general_join_field_to_query($query, 'node', 'field_individual_participant');
  $query->groupBy('field_individual_participant.field_individual_participant_target_id');

  $result = $query
    ->execute()
    ->fetchAllAssoc('field_individual_participant');

  $individual_participants = array_keys($result);
  if (empty($individual_participants)) {
    $result = [];
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_SPV_DATA, $health_center_id, NULL, $result);
    return $result;
  }

  // Pull all participants to which resolved encounters belong, including
  // some patient data.
  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant');
  $query->condition('node.nid', $individual_participants, 'IN');

  $fields_to_join = [
    'field_person',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }

  // Add patient birthdate, so we can calculate the age.
  $query->leftJoin('field_data_field_birth_date', 'birth_date', 'birth_date.entity_id = field_person.field_person_target_id');
  $query->addField('birth_date', 'field_birth_date_value');

  // Add patient gender, so we know if HPV vaccination is required.
  $query->leftJoin('field_data_field_gender', 'gender', 'gender.entity_id = field_person.field_person_target_id');
  $query->addField('gender', 'field_gender_value');

  $result = hedley_stats_run_node_query_in_batches($query);

  $items = [];
  // Prepare participant data to be consumed by client side.
  foreach ($result as $row) {
    $items[$row->nid] = [
      'id' => $row->field_person,
      // Field for 'created' is added at hedley_stats_get_base_query().
      'created' => date_format(date_create($row->field_expected), 'Y-m-d'),
      'birth_date' => date_format(date_create($row->field_birth_date_value), 'Y-m-d'),
      'gender' => $row->field_gender_value,
      'encounters' => [],
    ];
  }

  // Free up memory.
  drupal_static_reset();

  // Resolve encounters data.
  $base_query = hedley_stats_get_base_query($health_center_id, 'well_child_encounter');
  $fields_to_join = [
    'field_individual_participant',
    'field_well_child_encounter_type',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($base_query, 'node', $field, FALSE);
  }
  $base_query->condition('field_individual_participant.field_individual_participant_target_id', $individual_participants, 'IN');

  // Join with Well Child Encounter table, through which
  // we can join measurements data.
  $base_query->leftJoin('field_data_field_well_child_encounter', 'well_child_encounter', 'well_child_encounter.field_well_child_encounter_target_id = node.nid');

  $query = clone $base_query;

  // Pull data of well child warnings that were recorded during encounter.
  $query->leftJoin('field_data_field_encounter_warnings', 'encounter_warnings', 'encounter_warnings.entity_id = node.nid');
  $query->addField('encounter_warnings', 'field_encounter_warnings_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT encounter_warnings.field_encounter_warnings_value)", 'encounter_warnings');

  // Pull data of MUAC that was recorded during encounter.
  $query->leftJoin('field_data_field_muac', 'muac', 'muac.entity_id = well_child_encounter.entity_id');
  $query->addField('muac', 'field_muac_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT muac.field_muac_value)", 'muac');

  // Pull data of Nutrition Signs that was recorded during encounter.
  $query->leftJoin('field_data_field_nutrition_signs', 'nutrition_signs', 'nutrition_signs.entity_id = well_child_encounter.entity_id');
  $query->addField('nutrition_signs', 'field_nutrition_signs_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT nutrition_signs.field_nutrition_signs_value)", 'nutrition_signs');

  // Pull data of weight for height z-score for determining 'Wasting'.
  // Taken from Well Child weight measurement.
  $query->leftJoin('field_data_field_zscore_length', 'zscore_length', 'zscore_length.entity_id = well_child_encounter.entity_id');
  $query->addField('zscore_length', 'field_zscore_length_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT zscore_length.field_zscore_length_value)", 'zscore_length');

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    $item = [
      // Field for 'created' is added at hedley_stats_get_base_query().
      'start_date' => date_format(date_create($row->field_scheduled_date), 'Y-m-d'),
      'warnings' => explode(',', $row->encounter_warnings),
      'nutrition_signs' => explode(',', $row->nutrition_signs),
    ];
    if (!empty($row->field_well_child_encounter_type)) {
      $item['encounter_type'] = $row->field_well_child_encounter_type;
    }
    if (!empty($row->muac)) {
      $item['muac'] = $row->muac;
    }
    if (!empty($row->zscore_length)) {
      $item['zscore_wasting'] = $row->zscore_length;
    }
    $items[$row->field_individual_participant]['encounters'][$row->nid] = $item;
  }

  // Free up memory.
  drupal_static_reset();

  // Run a dedicated query for each of bundles that hold z-score age field.
  // Dedicated query is mandatory since multiple bundles hold same field.
  // There are combinations where some bundles will be created, and others not.
  // As a result, if we join this field to query that pulls other data,
  // failure to pull the field for bundle fails whole query, causing loss
  // of data.
  $zsore_age_bundles = [
    HEDLEY_ACTIVITY_WELL_CHILD_HEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_WELL_CHILD_WEIGHT_CONTENT_TYPE,
  ];
  foreach ($zsore_age_bundles as $bundle) {
    hedley_stats_add_zscore_age_for_bundle($base_query, 'well_child', $bundle, $items);
  }

  // Run a dedicated query for each of immunizations bundles.
  // Dedicated query is mandatory since multiple bundles hold same field.
  // There are combinations where some bundles will be created, and others not.
  // As a result, if we join this field to query that pulls other data,
  // failure to pull the field for bundle fails whole query, causing loss
  // of data.
  foreach (HEDLEY_ACTIVITY_WELL_CHILD_IMMUNISATION_BUNDLES as $bundle) {
    hedley_stats_add_immunization_dates_for_bundle($base_query, 'well_child', $bundle, $items);
  }

  foreach ($items as &$item) {
    $item['encounters'] = array_values($item['encounters']);
  }
  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_SPV_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Return Child Scoreboard data that is used to generate statistics.
 *
 * We get data of all encounters for patients that were active during
 * past 6 months.
 * We need to know when encounters were created, it's
 * diagnoses and several measurements. Also, we add patient ID,
 * to be able to associate it with its village.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of Child Scoreboard  participant data with its encounters.
 *
 * @throws Exception
 */
function hedley_stats_get_child_scorecard_data($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_CHILD_SCOREBOARD_DATA, $health_center_id)) {
    return $cache_data;
  }

  // Pull all Child Scoreboard encounters during past 6 months.
  // Since dashboard presents data for past 6 months, we will be
  // generating data for all Child Scoreboard participants that had
  // an encounter over past 6 months.
  $query = hedley_stats_get_base_query($health_center_id, 'child_scoreboard_encounter', HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS);

  // Resolve all participants associated with those encounters.
  hedley_general_join_field_to_query($query, 'node', 'field_individual_participant');
  $query->groupBy('field_individual_participant.field_individual_participant_target_id');

  $result = $query
    ->execute()
    ->fetchAllAssoc('field_individual_participant');

  $individual_participants = array_keys($result);
  if (empty($individual_participants)) {
    $result = [];
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_CHILD_SCOREBOARD_DATA, $health_center_id, NULL, $result);
    return $result;
  }

  // Pull all participants to which resolved encounters belong, including
  // some patient data.
  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant');
  $query->condition('node.nid', $individual_participants, 'IN');

  $fields_to_join = [
    'field_person',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }

  // Add patient birthdate, so we can calculate the age.
  $query->leftJoin('field_data_field_birth_date', 'birth_date', 'birth_date.entity_id = field_person.field_person_target_id');
  $query->addField('birth_date', 'field_birth_date_value');

  // Add patient gender, so we know if HPV vaccination is required.
  $query->leftJoin('field_data_field_gender', 'gender', 'gender.entity_id = field_person.field_person_target_id');
  $query->addField('gender', 'field_gender_value');

  $result = hedley_stats_run_node_query_in_batches($query);

  $items = [];
  // Prepare participant data to be consumed by client side.
  foreach ($result as $row) {
    $items[$row->nid] = [
      'id' => $row->field_person,
      // Field for 'created' is added at hedley_stats_get_base_query().
      'created' => date_format(date_create($row->field_expected), 'Y-m-d'),
      'birth_date' => date_format(date_create($row->field_birth_date_value), 'Y-m-d'),
      'gender' => $row->field_gender_value,
      'encounters' => [],
    ];
  }

  // Free up memory.
  drupal_static_reset();

  // Resolve encounters data.
  $base_query = hedley_stats_get_base_query($health_center_id, 'child_scoreboard_encounter');
  $fields_to_join = [
    'field_individual_participant',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($base_query, 'node', $field, FALSE);
  }
  $base_query->condition('field_individual_participant.field_individual_participant_target_id', $individual_participants, 'IN');

  // Join with Well Child Encounter table, through which
  // we can join measurements data.
  $base_query->leftJoin('field_data_field_child_scoreboard_encounter', 'child_scoreboard_encounter', 'child_scoreboard_encounter.field_child_scoreboard_encounter_target_id = node.nid');

  $query = clone $base_query;

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    $items[$row->field_individual_participant]['encounters'][$row->nid] = [
      'start_date' => date_format(date_create($row->field_scheduled_date), 'Y-m-d'),
    ];
  }

  // Free up memory.
  drupal_static_reset();

  // Run a dedicated query for each of immunizations bundles.
  // Dedicated query is mandatory since multiple bundles hold same field.
  // There are combinations where some bundles will be created, and others not.
  // As a result, if we join this field to query that pulls other data,
  // failure to pull the field for bundle fails whole query, causing loss
  // of data.
  foreach (HEDLEY_ACTIVITY_CHILD_SCOREBOARD_IMMUNISATION_BUNDLES as $bundle) {
    hedley_stats_add_immunization_dates_for_bundle($base_query, 'child_scoreboard', $bundle, $items);
  }

  foreach ($items as &$item) {
    $item['encounters'] = array_values($item['encounters']);
  }
  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_CHILD_SCOREBOARD_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Add z-score age value for a specific bundle to the given items array.
 *
 * @param SelectQuery $base_query
 *   The base query to build upon.
 * @param string $encounter_type
 *   The type of encounter from which immunization data is to be pulled.
 * @param string $bundle
 *   The bundle that hold z-score age field.
 * @param array $items
 *   An array to store the z-score value for encounters
 *   of each participant.
 */
function hedley_stats_add_zscore_age_for_bundle(SelectQuery $base_query, $encounter_type, $bundle, array &$items) {
  $query = clone $base_query;

  $query->leftJoin('field_data_field_zscore_age', 'zscore_age', "zscore_age.entity_id = {$encounter_type}_encounter.entity_id");
  $query->addField('zscore_age', 'field_zscore_age_value');
  $query->condition('zscore_age.bundle', $bundle);
  $query->addExpression("GROUP_CONCAT(DISTINCT zscore_age.field_zscore_age_value)", 'zscore_age');

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    if (empty($items[$row->field_individual_participant]['encounters'][$row->nid])) {
      // There's no encounter to associate measurement with.
      // In theory, this should not be happening, but in fact this
      // have occurred on live.
      // Therefore, check was added to prevent decoder failure on client.
      continue;
    }

    $alias = ($bundle == HEDLEY_ACTIVITY_WELL_CHILD_WEIGHT_CONTENT_TYPE) ? 'zscore_underweight' : 'zscore_stunting';
    $items[$row->field_individual_participant]['encounters'][$row->nid][$alias] = $row->zscore_age;
  }

  // Free up memory.
  drupal_static_reset();
}

/**
 * Add immunization dates for a specific bundle to the given items array.
 *
 * @param SelectQuery $base_query
 *   The base query to build upon.
 * @param string $encounter_type
 *   The type of encounter from which immunization data is to be pulled.
 * @param string $bundle
 *   The bundle for immunization type.
 * @param array $items
 *   An array to store the immunization dates for encounters
 *   of each participant.
 */
function hedley_stats_add_immunization_dates_for_bundle(SelectQuery $base_query, $encounter_type, $bundle, array &$items) {
  $query = clone $base_query;
  // Pull data of immunization bundle.
  $query->leftJoin('field_data_field_administration_dates', 'administration_dates', "administration_dates.entity_id = {$encounter_type}_encounter.entity_id");
  $query->addField('administration_dates', 'field_administration_dates_value');
  $query->condition('administration_dates.bundle', $bundle);
  $query->addExpression("GROUP_CONCAT(administration_dates.field_administration_dates_value)", 'administration_dates');

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    if (empty($items[$row->field_individual_participant]['encounters'][$row->nid])) {
      // There's no encounter to associate measurement with.
      // In theory, this should not be happening, but in fact this
      // have occurred on live.
      // Therefore, check was added to prevent decoder failure on client.
      continue;
    }

    $administration_data = explode(',', $row->administration_dates);
    $administration_dates = [];
    foreach ($administration_data as $value) {
      if (!empty($value)) {
        $administration_dates[] = date_format(date_create($value), 'Y-m-d');
      }
    }

    $items[$row->field_individual_participant]['encounters'][$row->nid][$bundle] = $administration_dates;
  }

  // Free up memory.
  drupal_static_reset();
}

/**
 * Return Nutrition individual data that is used to generate statistics.
 *
 * We get data of all encounters for patients that were active during
 * past 6 months.
 * We need to know when encounters were created, and several measurements.
 * Also, we add patient ID, to be able to associate it with its village.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of Nutrition participants data with its encounters.
 *
 * @throws Exception
 */
function hedley_stats_get_nutrition_individual_data($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_NUTRITION_INDIVIDUAL_DATA, $health_center_id)) {
    return $cache_data;
  }

  // Pull all Nutrition encounters during past 6 months.
  // Since dashboard presents data for past 6 months, we will be generating data
  // for all Nutrition participants that had an encounter over past 6 months.
  $query = hedley_stats_get_base_query($health_center_id, 'nutrition_encounter', HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS);

  // Resolve all participants associated with those encounters.
  hedley_general_join_field_to_query($query, 'node', 'field_individual_participant');
  $query->groupBy('field_individual_participant.field_individual_participant_target_id');

  $result = $query
    ->execute()
    ->fetchAllAssoc('field_individual_participant');

  $individual_participants = array_keys($result);
  if (empty($individual_participants)) {
    $result = [];
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_NUTRITION_INDIVIDUAL_DATA, $health_center_id, NULL, $result);
    return $result;
  }

  // Pull all participants to which resolved encounters belong, including
  // some patient data.
  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant');
  $query->condition('node.nid', $individual_participants, 'IN');

  $fields_to_join = [
    'field_person',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }

  // Add patient birthdate, so we can calculate the age.
  $query->leftJoin('field_data_field_birth_date', 'birth_date', 'birth_date.entity_id = field_person.field_person_target_id');
  $query->addField('birth_date', 'field_birth_date_value');

  $result = hedley_stats_run_node_query_in_batches($query);

  $items = [];
  // Prepare participant data to be consumed by client side.
  foreach ($result as $row) {
    $items[$row->nid] = [
      'id' => $row->field_person,
      // Field for 'created' is added at hedley_stats_get_base_query().
      'created' => date_format(date_create($row->field_expected), 'Y-m-d'),
      'birth_date' => date_format(date_create($row->field_birth_date_value), 'Y-m-d'),
      'encounters' => [],
    ];
  }

  // Free up memory.
  drupal_static_reset();

  // Resolve encounters data.
  $base_query = hedley_stats_get_base_query($health_center_id, 'nutrition_encounter');
  $fields_to_join = [
    'field_individual_participant',
    'field_nutrition_encounter_type',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($base_query, 'node', $field, FALSE);
  }
  $base_query->condition('field_individual_participant.field_individual_participant_target_id', $individual_participants, 'IN');

  // Join with Nutrition Encounter table, through which we can
  // join measurements data.
  $base_query->leftJoin('field_data_field_nutrition_encounter', 'nutrition_encounter', 'nutrition_encounter.field_nutrition_encounter_target_id = node.nid');

  $query = clone $base_query;

  // Pull data of MUAC that was recorded during encounter.
  $query->leftJoin('field_data_field_muac', 'muac', 'muac.entity_id = nutrition_encounter.entity_id');
  $query->addField('muac', 'field_muac_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT muac.field_muac_value)", 'muac');

  // Pull data of Nutrition Signs that was recorded during encounter.
  $query->leftJoin('field_data_field_nutrition_signs', 'nutrition_signs', 'nutrition_signs.entity_id = nutrition_encounter.entity_id');
  $query->addField('nutrition_signs', 'field_nutrition_signs_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT nutrition_signs.field_nutrition_signs_value)", 'nutrition_signs');

  // Pull data of weight for height z-score for determining 'Wasting'.
  // Taken from Nutrition weight measurement.
  $query->leftJoin('field_data_field_zscore_length', 'zscore_length', 'zscore_length.entity_id = nutrition_encounter.entity_id');
  $query->addField('zscore_length', 'field_zscore_length_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT zscore_length.field_zscore_length_value)", 'zscore_length');

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    $item = [
      // Field for 'created' is added at hedley_stats_get_base_query().
      'start_date' => date_format(date_create($row->field_scheduled_date), 'Y-m-d'),
      'nutrition_signs' => explode(',', $row->nutrition_signs),
    ];
    if (!empty($row->field_nutrition_encounter_type)) {
      $item['encounter_type'] = $row->field_nutrition_encounter_type;
    }
    if (!empty($row->muac)) {
      $item['muac'] = $row->muac;
    }
    if (!empty($row->zscore_length)) {
      $item['zscore_wasting'] = $row->zscore_length;
    }
    $items[$row->field_individual_participant]['encounters'][$row->nid] = $item;
  }

  // Free up memory.
  drupal_static_reset();

  // Run a dedicated query for each of bundles that hold z-score age field.
  // Dedicated query is mandatory since multiple bundles hold same field.
  // There are combinations where some bundles will be created, and others not.
  // As a result, if we join this field to query that pulls other data,
  // failure to pull the field for bundle fails whole query, causing loss
  // of data.
  $zsore_age_bundles = [
    HEDLEY_ACTIVITY_NUTRITION_HEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NUTRITION_WEIGHT_CONTENT_TYPE,
  ];
  foreach ($zsore_age_bundles as $bundle) {
    hedley_stats_add_zscore_age_for_bundle($base_query, 'nutrition', $bundle, $items);
  }

  foreach ($items as &$item) {
    $item['encounters'] = array_values($item['encounters']);
  }
  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_NUTRITION_INDIVIDUAL_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Return Nutrition group that is used to generate statistics.
 *
 * We get data of all sessions for patients that were active during
 * past 6 months.
 * We need to know when encounters were created, and several measurements.
 * Also, we add patient ID, to be able to associate it with its village.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of Nutrition participants data with its encounters.
 *
 * @throws Exception
 */
function hedley_stats_get_nutrition_group_data($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_NUTRITION_GROUP_DATA, $health_center_id)) {
    return $cache_data;
  }

  // Pull all non CHW group encounters during past 6 months.
  // Since dashboard presents data for past 6 months, we will be generating data
  // for all sessions that had an encounter over past 6 months.
  $query = hedley_stats_get_base_query($health_center_id, 'session', HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS);
  $query->leftJoin('field_data_field_clinic', 'clinic', 'clinic.entity_id = node.nid');
  $query->leftJoin('field_data_field_group_type', 'group_type', 'group_type.entity_id = clinic.field_clinic_target_id');
  $query->condition('group_type.field_group_type_value', 'chw', '<>');

  $result = $query
    ->execute()
    ->fetchAllAssoc('nid');
  if (empty($result)) {
    $result = [];
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_NUTRITION_GROUP_DATA, $health_center_id, NULL, $result);
    return $result;
  }

  $sessions_during_period = array_keys($result);

  // Now we need to resolve all patients (children) that have participated
  // in one of those sessions. Patient is defined by person that had at
  // least one nutrition measurement taken during one of sessions.
  $nutrition_bundles = [
    HEDLEY_ACTIVITY_HEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_WEIGHT_CONTENT_TYPE,
    HEDLEY_ACTIVITY_MUAC_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NUTRITION_CONTENT_TYPE,
  ];
  $query = hedley_stats_get_base_query($health_center_id, $nutrition_bundles);
  $query->leftJoin('field_data_field_session', 'session', 'session.entity_id = node.nid');
  $query->condition('session.field_session_target_id', $sessions_during_period, 'IN');
  $query->leftJoin('field_data_field_person', 'person', 'person.entity_id = session.entity_id');
  $query->addField('person', 'field_person_target_id', 'person_id');

  $patients_ids = $query
    ->execute()
    ->fetchAllAssoc('person_id');
  $patients_ids = array_unique(array_keys($patients_ids));
  if (empty($patients_ids)) {
    $result = [];
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_NUTRITION_GROUP_DATA, $health_center_id, NULL, $result);
    return $result;
  }

  $data = [];

  $query = hedley_stats_get_nutrition_group_query_for_bundle($health_center_id, $patients_ids, HEDLEY_ACTIVITY_WEIGHT_CONTENT_TYPE);
  // Pull data of weight for height z-score for determining 'Wasting'.
  $query->leftJoin('field_data_field_zscore_length', 'zscore_length', 'zscore_length.entity_id = session.entity_id');
  $query->addField('zscore_length', 'field_zscore_length_value', 'wasting');
  // Pull data of weight for age z-score for determining 'Underweight'.
  $query->leftJoin('field_data_field_zscore_age', 'zscore_age', 'zscore_age.entity_id = session.entity_id');
  $query->addField('zscore_age', 'field_zscore_age_value', 'underweight');

  $rows = hedley_stats_run_node_query_in_batches($query);
  foreach ($rows as $row) {
    $data[$row->clinic_type][$row->person_id][$row->session_id] = [
      'start_date' => date_format(date_create($row->field_date_measured), 'Y-m-d'),
      'zscore_wasting' => $row->wasting,
      'zscore_underweight' => $row->underweight,
    ];
  }

  $query = hedley_stats_get_nutrition_group_query_for_bundle($health_center_id, $patients_ids, HEDLEY_ACTIVITY_HEIGHT_CONTENT_TYPE);
  // Pull data of height for age z-score for determining 'Stunting'.
  $query->leftJoin('field_data_field_zscore_age', 'zscore_age', 'zscore_age.entity_id = session.entity_id');
  $query->addField('zscore_age', 'field_zscore_age_value', 'stunting');

  $rows = hedley_stats_run_node_query_in_batches($query);
  foreach ($rows as $row) {
    $data[$row->clinic_type][$row->person_id][$row->session_id]['start_date'] = date_format(date_create($row->field_date_measured), 'Y-m-d');
    $data[$row->clinic_type][$row->person_id][$row->session_id]['zscore_stunting'] = $row->stunting;
  }

  $query = hedley_stats_get_nutrition_group_query_for_bundle($health_center_id, $patients_ids, HEDLEY_ACTIVITY_MUAC_CONTENT_TYPE);
  // Pull data of MUAC that was recorded during session.
  $query->leftJoin('field_data_field_muac', 'muac', 'muac.entity_id = session.entity_id');
  $query->addField('muac', 'field_muac_value');

  $rows = hedley_stats_run_node_query_in_batches($query);
  foreach ($rows as $row) {
    $data[$row->clinic_type][$row->person_id][$row->session_id]['start_date'] = date_format(date_create($row->field_date_measured), 'Y-m-d');
    $data[$row->clinic_type][$row->person_id][$row->session_id]['muac'] = $row->field_muac_value;
  }

  $query = hedley_stats_get_nutrition_group_query_for_bundle($health_center_id, $patients_ids, HEDLEY_ACTIVITY_NUTRITION_CONTENT_TYPE);
  // Pull data of Nutrition Signs that was recorded during encounter.
  $query->leftJoin('field_data_field_nutrition_signs', 'nutrition_signs', 'nutrition_signs.entity_id = session.entity_id');
  $query->addField('nutrition_signs', 'field_nutrition_signs_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT nutrition_signs.field_nutrition_signs_value)", 'nutrition_signs');
  $query->groupBy('node.nid');

  $rows = hedley_stats_run_node_query_in_batches($query);
  foreach ($rows as $row) {
    $data[$row->clinic_type][$row->person_id][$row->session_id]['start_date'] = date_format(date_create($row->field_date_measured), 'Y-m-d');
    $data[$row->clinic_type][$row->person_id][$row->session_id]['nutrition_signs'] = explode(',', $row->nutrition_signs);
  }

  $items = [];
  foreach ($data as $clinict_type_data) {
    foreach ($clinict_type_data as $patient_id => $encounters) {
      if (empty($items[$patient_id])) {
        $items[$patient_id] = [
          'id' => $patient_id,
          'encounters' => [],
        ];
      }

      foreach ($encounters as $encounter) {
        $items[$patient_id]['encounters'][] = $encounter;
      }
    }
  }

  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_NUTRITION_GROUP_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Generates base query for Nutrition group data from single measurement type.
 *
 * Since statistics are generated for Nurse, we
 * omit measurements taken during CHW sessions.
 *
 * @param int $health_center_id
 *   The health center node ID.
 * @param array $patients_ids
 *   List of patients to which measurements (of type) should belong.
 * @param string $bundle
 *   The type of the measurement.
 *
 * @return SelectQuery
 *   Gemereated query.
 *
 * @throws Exception
 */
function hedley_stats_get_nutrition_group_query_for_bundle($health_center_id, array $patients_ids, $bundle) {
  $base_query = hedley_stats_get_base_query($health_center_id, $bundle);

  $base_query->leftJoin('field_data_field_session', 'session', 'session.entity_id = node.nid');
  $base_query->addField('session', 'field_session_target_id', 'session_id');
  $base_query->leftJoin('field_data_field_clinic', 'clinic', 'clinic.entity_id = session.field_session_target_id');
  $base_query->leftJoin('field_data_field_group_type', 'group_type', 'group_type.entity_id = clinic.field_clinic_target_id');
  $base_query->addField('group_type', 'field_group_type_value', 'clinic_type');
  $base_query->leftJoin('field_data_field_person', 'person', 'person.entity_id = session.entity_id');
  $base_query->addField('person', 'field_person_target_id', 'person_id');
  $base_query->condition('person.field_person_target_id', $patients_ids, 'IN');
  $base_query->condition('group_type.field_group_type_value', 'chw', '<>');

  return $base_query;
}

/**
 * Returns active participants for HC, during provided period.
 *
 * Data includes both groups and individual participants.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. By default, it is for one year.
 *
 * @return array
 *   Array with the participants details grouped by clinic type.
 *
 * @throws \Exception
 */
function hedley_stats_get_children_beneficiaries_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_CHILDREN_BENEFICIARIES, $health_center_id, $period)) {
    return $cache_data;
  }

  $items = hedley_stats_get_children_beneficiaries_group_stats($health_center_id, $period);
  $items['individual'] = hedley_stats_get_children_beneficiaries_individual_stats($health_center_id);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_CHILDREN_BENEFICIARIES, $health_center_id, $period, $items);

  return $items;
}

/**
 * Returns active participants for HC (per clinic type), during provided period.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. By default it is for one year.
 *
 * @return array
 *   Array with the participants details grouped by clinic type.
 *
 * @throws \Exception
 */
function hedley_stats_get_children_beneficiaries_group_stats($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  $query = hedley_stats_get_base_query($health_center_id, 'pmtct_participant');

  $field_names = [
    'field_person',
    'field_adult',
    'field_clinic',
  ];

  foreach ($field_names as $field_name) {
    hedley_general_join_field_to_query($query, 'node', $field_name);
  }

  hedley_general_join_field_to_query($query, 'node', 'field_group_type', TRUE, 'field_clinic.field_clinic_target_id');

  $date = hedley_stats_get_period($period);
  // We want to get all participants that graduate within, or after
  // defined period.
  $query->condition('field_expected.field_expected_value2', $date['start'], '>');

  $result = hedley_stats_run_node_query_in_batches($query);

  $adults = $children = [];
  foreach ($result as $row) {
    $adults[] = $row->field_adult;
    $children[] = $row->field_person;
  }
  $adults = array_unique($adults);
  $children = array_unique($children);

  $adults_info = $children_info = [];
  foreach (array_chunk($adults, 500) as $ids) {
    $nodes = node_load_multiple($ids);
    foreach ($nodes as $node) {
      $adults_info[$node->nid] = [
        'name' => $node->title,
        'phone_number' => empty($node->field_phone_number) ? '' : $node->field_phone_number[LANGUAGE_NONE][0]['value'],
      ];
    }
    // Free up memory.
    drupal_static_reset();
  }
  foreach (array_chunk($children, 500) as $ids) {
    $nodes = node_load_multiple($ids);
    foreach ($nodes as $node) {
      $children_info[$node->nid] = [
        'id' => $node->nid,
        'name' => $node->title,
        'birth_date' => $node->field_birth_date[LANGUAGE_NONE][0]['value'],
        'gender' => $node->field_gender[LANGUAGE_NONE][0]['value'],
      ];
    }
    // Free up memory.
    drupal_static_reset();
  }

  $items = [];
  foreach (hedley_stats_get_all_clinic_types() as $clinic_type) {
    $items[$clinic_type] = [];
  }

  foreach ($result as $row) {
    $child_id = $row->field_person;
    $birth_date = $children_info[$child_id]['birth_date'];
    if (empty($birth_date)) {
      // Child got no birthdate set. We can't process
      // its data on client, so we skip it.
      continue;
    }

    $adult_id = $row->field_adult;
    $clinic_type = $row->field_group_type;
    $items[$clinic_type][] = [
      'created' => hedley_stats_convert_timestamp_to_nominal($row->created),
      'id' => $children_info[$child_id]['id'],
      'name' => $children_info[$child_id]['name'],
      'birth_date' => date("Y-m-d", strtotime($birth_date)),
      'gender' => $children_info[$child_id]['gender'],
      'mother_name' => $adults_info[$adult_id]['name'],
      'phone_number' => $adults_info[$adult_id]['phone_number'],
      'graduation_date' => date_format(date_create($row->field_expected_field_expected_value2), 'Y-m-d'),
    ];
  }

  return $items;
}

/**
 * Returns active nutrition participants for HC.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 *
 * @return array
 *   Array with the participants details.
 *
 * @throws \Exception
 */
function hedley_stats_get_children_beneficiaries_individual_stats($health_center_id) {
  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant');

  $field_names = [
    'field_person',
    'field_encounter_type',
  ];

  foreach ($field_names as $field_name) {
    hedley_general_join_field_to_query($query, 'node', $field_name);
  }

  $query->condition('field_encounter_type.field_encounter_type_value', 'nutrition');

  $result = hedley_stats_run_node_query_in_batches($query);

  $children = [];
  foreach ($result as $row) {
    $children[] = $row->field_person;
  }
  $children = array_unique($children);

  $children_info = [];
  foreach (array_chunk($children, 500) as $ids) {
    $nodes = node_load_multiple($ids);
    foreach ($nodes as $node) {
      $children_info[$node->nid] = [
        'id' => $node->nid,
        'name' => $node->title,
        'birth_date' => $node->field_birth_date[LANGUAGE_NONE][0]['value'],
        'gender' => $node->field_gender[LANGUAGE_NONE][0]['value'],
      ];
    }
    // Free up memory.
    drupal_static_reset();
  }

  $items = [];
  foreach ($result as $row) {
    $child_id = $row->field_person;
    $birth_date = $children_info[$child_id]['birth_date'];

    if (empty($birth_date)) {
      // Child got no birthdate set. We can't process
      // its data on client, so we skip it.
      continue;
    }
    $birth_date = strtotime($birth_date);

    // Child graduates at age of 13.
    $graduation_date = strtotime('+13 years', $birth_date);

    $items[] = [
      'created' => hedley_stats_convert_timestamp_to_nominal($row->created),
      'id' => $children_info[$child_id]['id'],
      'name' => $children_info[$child_id]['name'],
      'birth_date' => date("Y-m-d", $birth_date),
      'gender' => $children_info[$child_id]['gender'],
      'graduation_date' => hedley_stats_convert_timestamp_to_nominal($graduation_date),
      // No need to provide mother details, because we do not present
      // it anywhere, when it comes to individual participant data.
      'mother_name' => '',
      'phone_number' => '',
    ];
  }

  return $items;
}

/**
 * Return family planning related states.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 *
 * @return array
 *   Array with the result.
 *
 * @throws \Exception
 */
function hedley_stats_get_family_planning_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_FAMILY_PLANNING, $health_center_id, $period)) {
    return $cache_data;
  }

  $query = hedley_stats_get_base_query($health_center_id, 'family_planning', $period);

  // Join `Signs` field (e.g. Pill, Condoms, etc').
  hedley_general_join_field_to_query($query, 'node', 'field_family_planning_signs');

  // Get the group type.
  hedley_general_join_field_to_query($query, 'node', 'field_session');
  hedley_general_join_field_to_query($query, 'node', 'field_clinic', TRUE, "field_session.field_session_target_id");
  hedley_general_join_field_to_query($query, 'node', 'field_group_type', TRUE, "field_clinic.field_clinic_target_id");
  // Only FBF groups.
  $query->condition('field_group_type.field_group_type_value', 'fbf');

  $query->groupBy('node.nid');
  $query->addExpression('GROUP_CONCAT(field_family_planning_signs.field_family_planning_signs_value)', 'signs');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Prepare data to be consumed by client side.
  foreach ($result as &$row) {
    $row->created = hedley_stats_convert_timestamp_to_nominal($row->created);
    $row->signs = explode(',', $row->signs);

    // Remove unused data, to save bandwidth.
    unset($row->nid);
    unset($row->type);
    unset($row->field_session);
    unset($row->field_clinic);
    unset($row->field_group_type);
    unset($row->field_shards);
    unset($row->field_family_planning_signs);
  }

  // Free up memory.
  drupal_static_reset();

  // Set the cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_FAMILY_PLANNING, $health_center_id, $period, array_values($result));

  return array_values($result);
}

/**
 * Return FBF sessions attendance related states by health center.
 *
 * The statistics we need are:
 *  - Children that have missed sessions by period.
 *  - Children that are graduating the program, by period.
 *
 * The logic:
 *   1. Pull all participants (mother+child pair) of FBF clinics
 *      of the health center.
 *   2. Pull all FBF sessions that have were performed during given periods.
 *   3. For each participant, for each of periods:
 *     - Determine if participant was supposed to participate in a session.
 *     - If so:
 *        3.1. Load all measurements taken for child during FFB sessions
 *           (resolved at point 2). If there are no measurements, we know that
 *           child has missed the session.
 *        3.2. Determine if child graduates within given period.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param array $fbf_clinics
 *   A list of FBF clinics IDs that belong to health center.
 *
 * @return array
 *   Array with the results.
 */
function hedley_stats_get_session_attendance_stats_by_health_center($health_center_id, array $fbf_clinics) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_SESSION_ATTENDANCE, $health_center_id)) {
    return $cache_data;
  }

  if (empty($fbf_clinics)) {
    $result = [[], []];
    // No clinics found.
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_SESSION_ATTENDANCE, $health_center_id, NULL, $result);
    return $result;
  }

  $periods = [
    // On front-end, we have a selection only for 2 periods -
    // this month and previous month.
    // We add the 'two months ago' period, to support display of
    // the '% from previous months' located on cards.
    HEDLEY_STATS_PERIOD_TWO_MONTHS_AGO,
    HEDLEY_STATS_PERIOD_LAST_MONTH,
    HEDLEY_STATS_PERIOD_THIS_MONTH,
  ];

  $completed_program = [];
  $missed_session = [];

  foreach ($fbf_clinics as $clinic_id) {
    $sessions_by_period = $periods_ranges = [];
    foreach ($periods as $period) {
      $sessions_by_period[$period] = hedley_stats_get_clinic_sessions_by_period($clinic_id, $period);
      $periods_ranges[$period] = hedley_stats_get_period($period);
    }

    // Get PMTCT participants by clinic.
    $participants_ids = hedley_stats_get_pmtct_participants_by_clinic($clinic_id, 5000);
    $participants_info = [];
    $children = $mothers = [];
    foreach (array_chunk($participants_ids, 500) as $ids) {
      $nodes = node_load_multiple($ids);
      foreach ($nodes as $node) {
        $children[] = $node->field_person[LANGUAGE_NONE][0]['target_id'];
        $mothers[] = $node->field_adult[LANGUAGE_NONE][0]['target_id'];
        $participants_info[$node->nid] = [
          'child_id' => $node->field_person[LANGUAGE_NONE][0]['target_id'],
          'mother_id' => $node->field_adult[LANGUAGE_NONE][0]['target_id'],
          'join_date' => $node->created,
          'graduate_date' => strtotime($node->field_expected[LANGUAGE_NONE][0]['value2']),
        ];
      }
      // Free up memory.
      drupal_static_reset();
    }

    $children = array_unique($children);
    $mothers = array_unique($mothers);
    $children_info = $mothers_info = [];
    foreach (array_chunk($mothers, 500) as $ids) {
      $nodes = node_load_multiple($ids);
      foreach ($nodes as $node) {
        $mothers_info[$node->nid] = [
          'name' => $node->title,
          'phone_number' => empty($node->field_phone_number) ? '' : $node->field_phone_number[LANGUAGE_NONE][0]['value'],
        ];
      }
      // Free up memory.
      drupal_static_reset();
    }
    foreach (array_chunk($children, 500) as $ids) {
      $nodes = node_load_multiple($ids);
      foreach ($nodes as $node) {
        $children_info[$node->nid] = [
          'name' => $node->title,
          'birth_date' => $node->field_birth_date[LANGUAGE_NONE][0]['value'],
          'gender' => $node->field_gender[LANGUAGE_NONE][0]['value'],
        ];
      }
      // Free up memory.
      drupal_static_reset();
    }

    foreach ($participants_ids as $participant_id) {
      $participant_info = $participants_info[$participant_id];
      $child_id = $participant_info['child_id'];
      $mother_id = $participant_info['mother_id'];

      if (empty($child_id) || empty($mother_id)) {
        // Missing mandatory data. Skipping participant.
        continue;
      }

      $child_info = $children_info[$child_id];
      $birth_date = $child_info['birth_date'];
      if (empty($birth_date)) {
        // Child got no birthdate set. We can't process
        // its data on client, so we skip it.
        continue;
      }

      $mother_info = $mothers_info[$mother_id];
      $participant_join_date = $participant_info['join_date'];
      $participant_graduate_date = $participant_info['graduate_date'];

      $expected_person = [
        'name' => $child_info['name'],
        'gender' => $child_info['gender'],
        'birth_date' => hedley_restful_timestamp_only_date($birth_date),
        'mother_name' => $mother_info['name'],
        'phone_number' => $mother_info['phone_number'],
        'expected_date' => NULL,
      ];

      foreach ($periods as $period) {
        $start_timestamp = strtotime($periods_ranges[$period]['start']);
        // Participant has graduated before period has started.
        if ($participant_graduate_date < $start_timestamp) {
          continue;
        }

        $end_timestamp = strtotime($periods_ranges[$period]['end']);
        // Participant has joined after the period has ended.
        if ($participant_join_date > $end_timestamp) {
          continue;
        }

        // Setting expected date to first day in range, to allow proper
        // filtering on front-end.
        $expected_person['expected_date'] = hedley_stats_convert_timestamp_to_nominal($start_timestamp);

        $sessions_ids = $sessions_by_period[$period];
        if (!empty($sessions_ids)) {
          $count = hedley_activity_count_person_measurements_taken_during_sessions($child_id, $sessions_ids);
          if ($count == 0) {
            // The child missed the session during given period, because
            // no measurements was taken for them.
            $missed_session[] = $expected_person;
          }
        }

        if ($participant_graduate_date <= $end_timestamp) {
          // Graduation date is within the period.
          $completed_program[] = $expected_person;
        }
      }
    }

    // Free up memory.
    drupal_static_reset();
  }

  // Set the cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_SESSION_ATTENDANCE, $health_center_id, NULL, [
    array_values($completed_program),
    array_values($missed_session),
  ]);

  return [array_values($completed_program), array_values($missed_session)];
}

/**
 * Returns "Total Encounters".
 *
 * Includes total number of encounters for each type of clinic, and
 * total number of individual nutrition encounters.
 * Results are provided for 'global' totals, and broken down by villages.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 *
 * @return array
 *   AN array with total encounters.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_encounters($health_center_id, $villages_with_residents) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_TOTAL_ENCOUNTERS, $health_center_id)) {
    return $cache_data;
  }

  $total_by_patient_at_clinic = [
    'last_year' => hedley_stats_get_total_encounters_by_patients_at_clinic($health_center_id, HEDLEY_STATS_PERIOD_LAST_YEAR),
    'this_year' => hedley_stats_get_total_encounters_by_patients_at_clinic($health_center_id, HEDLEY_STATS_PERIOD_ONE_YEAR),
  ];

  $total_by_patient_individual = [
    'last_year' => hedley_stats_get_total_nutrition_encounters_by_patient($health_center_id, HEDLEY_STATS_PERIOD_LAST_YEAR),
    'this_year' => hedley_stats_get_total_nutrition_encounters_by_patient($health_center_id, HEDLEY_STATS_PERIOD_ONE_YEAR),
  ];

  $result['global'] = hedley_stats_get_total_encounters_for_residents($total_by_patient_at_clinic, $total_by_patient_individual);
  $result['villages'] = [];
  foreach ($villages_with_residents as $village_uuid => $residents_ids) {
    $result['villages'][$village_uuid] = hedley_stats_get_total_encounters_for_residents($total_by_patient_at_clinic, $total_by_patient_individual, $residents_ids);
  }

  // Free up memory.
  drupal_static_reset();

  // Set the cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_TOTAL_ENCOUNTERS, $health_center_id, NULL, $result);

  return $result;
}

/**
 * Returns "Total Encounters" for specified patients.
 *
 * If patients list is not provided (defaults to False),
 * overall totals are calculated.
 *
 * Includes total number of encounters for each type of clinic, and
 * total number of individual nutrition encounters.
 *
 * @param array $total_by_patient_at_clinic
 *   For each of clinics, total number of sessions for each patient.
 * @param array $total_by_patient_individual
 *   Total number of Nutrition encounters for each patient.
 * @param bool|array $patients_ids
 *   Optional; a list of patients IDs, for which totals are counted.
 *
 * @return array
 *   A list with total encounters count.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_encounters_for_residents(array $total_by_patient_at_clinic, array $total_by_patient_individual, $patients_ids = FALSE) {
  $result = hedley_stats_get_total_encounters_by_clinic_type($total_by_patient_at_clinic, $patients_ids);
  $result['individual'] = hedley_stats_get_total_nutrition_encounters($total_by_patient_individual, $patients_ids);

  return $result;
}

/**
 * Return "Total Encounters" for specified type of clinic, for past 2 years.
 *
 * If patients list is not provided (defaults to False),
 * overall totals are calculated.
 *
 * @param array $total_by_patient_at_clinic
 *   For each of clinics, total number of sessions for each patient.
 * @param bool|array $patients_ids
 *   Optional; a list of patients IDs, for which totals are counted.
 *
 * @return array
 *   A list with total encounters count.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_encounters_by_clinic_type(array $total_by_patient_at_clinic, $patients_ids = FALSE) {
  $result = [];
  $clinic_types = hedley_stats_get_all_clinic_types();
  if (is_array($patients_ids) && empty($patients_ids)) {
    // Patients list is empty. No encounters. Return empty result.
    foreach ($clinic_types as $clinic_type) {
      $result[$clinic_type] = [
        'last_year' => 0,
        'this_year' => 0,
      ];
    }

    return $result;
  }

  foreach ($clinic_types as $clinic_type) {
    $result[$clinic_type] = [
      'last_year' => hedley_stats_total_encounters_from_breakdown_by_patient($total_by_patient_at_clinic['last_year'][$clinic_type], $patients_ids),
      'this_year' => hedley_stats_total_encounters_from_breakdown_by_patient($total_by_patient_at_clinic['this_year'][$clinic_type], $patients_ids),
    ];
  }

  return $result;
}

/**
 * Generates data structure with number of Group encounters per patient.
 *
 * Keys - patients IDs, Values - number of encounters.
 * Broken down by clinics types.
 *
 * @param int $health_center_id
 *   The health center node ID.
 * @param string $period
 *   The period for the data.
 *
 * @return array
 *   Array with number of Nutrition encounters per patient, within period.
 *
 * @throws Exception
 */
function hedley_stats_get_total_encounters_by_patients_at_clinic($health_center_id, $period) {
  $query = hedley_stats_get_base_query($health_center_id, 'attendance', $period);
  hedley_general_join_field_to_query($query, 'node', 'field_session');
  hedley_general_join_field_to_query($query, 'node', 'field_attended');
  hedley_general_join_field_to_query($query, 'node', 'field_clinic', TRUE, 'field_session.field_session_target_id');
  hedley_general_join_field_to_query($query, 'node', 'field_group_type', TRUE, 'field_clinic.field_clinic_target_id');
  hedley_general_join_field_to_query($query, 'node', 'field_person');
  // Only participants who actually attended the sessions.
  $query->condition('field_attended.field_attended_value', TRUE);
  $result = hedley_stats_run_node_query_in_batches($query);

  $total_by_patient_at_clinic = [];
  $clinic_types = hedley_stats_get_all_clinic_types();
  foreach ($clinic_types as $clinic_type) {
    $total_by_patient_at_clinic[$clinic_type] = [];
  }

  foreach ($result as $row) {
    $total_by_patient_at_clinic[$row->field_group_type][$row->field_person] = isset($total_by_patient_at_clinic[$row->field_group_type][$row->field_person]) ? $total_by_patient_at_clinic[$row->field_group_type][$row->field_person] + 1 : 1;
  }

  return $total_by_patient_at_clinic;
}

/**
 * Return "Total Encounters" for individual nutrition encounters, per period.
 *
 * If patients list is not provided (defaults to False),
 * overall totals are calculated.
 *
 * @param array $total_by_patient
 *   Total number of Nutrition encounters for each patient.
 * @param bool|array $patients_ids
 *   Optional; a list of patients IDs, for which totals are counted.
 *
 * @return array
 *   A list with total encounters count.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_nutrition_encounters(array $total_by_patient, $patients_ids = FALSE) {
  if (is_array($patients_ids) && empty($patients_ids)) {
    // Patients list is empty. No encounters. Return empty result.
    return [
      'last_year' => 0,
      'this_year' => 0,
    ];
  }

  return [
    'last_year' => hedley_stats_total_encounters_from_breakdown_by_patient($total_by_patient['last_year'], $patients_ids),
    'this_year' => hedley_stats_total_encounters_from_breakdown_by_patient($total_by_patient['this_year'], $patients_ids),
  ];
}

/**
 * Counts total number of encounters from data structure.
 *
 * If patients IDs list is provided, counts only for those patients.
 *
 * @param array $total_by_patient
 *   Total number of Nutrition encounters for each patient.
 * @param array|bool $patients_ids
 *   Optional; a list of patients IDs, for which total is counted.
 *
 * @return int
 *   Total number of encounters at data structure.
 */
function hedley_stats_total_encounters_from_breakdown_by_patient(array $total_by_patient, $patients_ids = FALSE) {
  if ($patients_ids === FALSE) {
    return array_sum($total_by_patient);
  }

  return array_sum(
    array_filter(
      $total_by_patient,
      function ($key) use ($patients_ids) {
        return in_array($key, $patients_ids);
      },
      ARRAY_FILTER_USE_KEY
    )
  );
}

/**
 * Generates data structure with number of Nutrition encounters per patient.
 *
 * Keys - patients IDs, Values - number of encounters.
 *
 * @param int $health_center_id
 *   The health center node ID.
 * @param string $period
 *   The period for the data.
 *
 * @return array
 *   Array with number of Nutrition encounters per patient, within period.
 *
 * @throws Exception
 */
function hedley_stats_get_total_nutrition_encounters_by_patient($health_center_id, $period) {
  $query = hedley_stats_get_base_query($health_center_id, 'nutrition_encounter', $period);
  hedley_general_join_field_to_query($query, 'node', 'field_individual_participant');
  hedley_general_join_field_to_query($query, 'node', 'field_person', TRUE, 'field_individual_participant.field_individual_participant_target_id');
  $result = $query->execute()->fetchAll();

  $total_by_patient = [];
  foreach ($result as $row) {
    $total_by_patient[$row->field_person] = !empty($total_by_patient[$row->field_person]) ? $total_by_patient[$row->field_person] + 1 : 1;

  }

  return $total_by_patient;
}

/**
 * Get the "Case Management" data, for current and previous years.
 *
 * The data is for the "Case Management" table which is divided into 4 types:
 * Stunting, Underweight, Wasting and MUAC.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of nutrition data for person, for current and previous years.
 *
 * @throws \Exception
 */
function hedley_stats_get_case_management($health_center_id) {
  return [
    'this_year' => hedley_stats_get_case_management_for_period($health_center_id),
    'last_year' => hedley_stats_get_case_management_for_period($health_center_id, HEDLEY_STATS_PERIOD_LAST_YEAR),
  ];
}

/**
 * Get the "Case Management" data, within given period.
 *
 * The data is for the "Case Management" table which is divided into 4 types:
 * Stunting, Underweight, Wasting and MUAC.
 *
 * @param int $health_center_id
 *   The health center node ID.
 * @param string $period
 *   Optional; The period for the data, defaults to one year.
 *
 * @return array
 *   List of nutrition data for person, within given period.
 *
 * @throws \Exception
 */
function hedley_stats_get_case_management_for_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_CASE_MANAGEMENT, $health_center_id, $period)) {
    return $cache_data;
  }

  $extend = ($period == HEDLEY_STATS_PERIOD_ONE_YEAR);
  $total_month = $extend ? 13 : 12;

  // Set the data for each month.
  $data_per_month = [];
  for ($i = 1; $i <= $total_month; $i++) {
    // If not changed below, NULL will indicate to client that
    // there was no data for current month.
    $data_per_month[$i] = NULL;
  }

  // Set the nutrition for each person.
  $nutrition_per_person = [
    'stunting' => $data_per_month,
    'underweight' => $data_per_month,
    'wasting' => $data_per_month,
    'muac' => $data_per_month,
    'nutrition_signs' => $data_per_month,
  ];

  $data = hedley_stats_get_nutrition_measurements_grouped_by_person($health_center_id, $period, $extend);

  $people = [];
  foreach ($data as $people_data) {
    $people = array_merge($people, array_keys($people_data));
  }
  $people = array_unique($people);
  $people_info = [];
  foreach (array_chunk($people, 500) as $ids) {
    $nodes = node_load_multiple($ids);
    foreach ($nodes as $node) {
      $people_info[$node->nid] = [
        'id' => $node->nid,
        'name' => $node->title,
        'birth_date' => hedley_restful_timestamp_only_date($node->field_birth_date[LANGUAGE_NONE][0]['value']),
        'gender' => $node->field_gender[LANGUAGE_NONE][0]['value'],
      ];
    }
    // Free up memory.
    drupal_static_reset();
  }

  $result = [];
  foreach ($data as $program_type => $people_data) {
    if (empty($people_data)) {
      $result[$program_type] = [];
      continue;
    }

    $people = [];
    foreach ($people_data as $id => $person) {
      $item = $people_info[$id];
      if (empty($item['birth_date'])) {
        // Child got no birthdate set. We can't process
        // its data on client, so we skip it.
        continue;
      }

      $item['nutrition'] = $nutrition_per_person;
      foreach ($person as $type => $measurement) {
        $one_day = 24 * 60 * 60;
        foreach ($measurement as $date => $values) {
          // Get the date of the measurement in order to distribute them by
          // months.
          $date_as_timestamp = strtotime($date);
          $month = date('n', $date_as_timestamp);

          // When extend data flag is raised, meaning that we want
          // to add one more month for current year, and if
          // measurement was taken over a year ago,
          // we set it at month 13. It's used to calculate the changes
          // that took place at first month of current year period.
          if ($extend && $date_as_timestamp < strtotime("last day of -1 year") + $one_day) {
            $month = '13';
          };

          foreach ($values as $field_name => $value) {
            // Some z-scores will not be present, when not all measurements
            // are taken for child. For example, without height, there's no
            // z-score length and z-score bmi.
            // In such cases, there's nothing to calculate, and we move
            // on to next measurement.
            if (empty($value)) {
              continue;
            }

            if (in_array($type, ['nutrition', 'nutrition_nutrition'])) {
              if ($value != 'none') {
                // This indicates to front-end of a 'Severe nutrition' case.
                $item['nutrition']['nutrition_signs'][$month] = -3;
              }
              else {
                // This indicates to front-end of a 'Good nutrition' case.
                $item['nutrition']['nutrition_signs'][$month] = 3;
              }

              // Move on to next measurement.
              continue;
            }

            // Round up the value, the class will indicate the zscore level.
            $formatted_value = round($value, 2);

            switch ($type) {
              case 'height':
              case 'nutrition_height':
                // The value to display in the table.
                $item['nutrition']['stunting'][$month] = $formatted_value;
                break;

              case 'weight':
              case 'nutrition_weight':
                if ($field_name == 'field_zscore_age') {
                  // The value to display in the table.
                  $item['nutrition']['underweight'][$month] = $formatted_value;
                }
                elseif ($field_name == 'field_zscore_length') {
                  // The value to display in the table.
                  $item['nutrition']['wasting'][$month] = $formatted_value;
                }
                break;

              case 'muac':
              case 'nutrition_muac':
                // The value to display in the table.
                $item['nutrition']['muac'][$month] = $formatted_value;
                break;
            }
          }
        }
      }
      $people[] = $item;
    }

    $result[$program_type] = $people;
  }

  // Set the cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_CASE_MANAGEMENT, $health_center_id, $period, $result);

  return $result;
}

/**
 * Returns a list with all available types of clinics.
 *
 * @return array
 *   A list with all available types of clinics.
 */
function hedley_stats_get_all_clinic_types() {
  return [
    HEDLEY_PERSON_CLINIC_TYPE_FBF,
    HEDLEY_PERSON_CLINIC_TYPE_PMTCT,
    HEDLEY_PERSON_CLINIC_TYPE_SORWATHE,
    HEDLEY_PERSON_CLINIC_TYPE_ACHI,
    HEDLEY_PERSON_CLINIC_TYPE_CHW,
  ];
}

/**
 * Returns all nutrition measurements for a health center.
 *
 * Results are for certain period, and grouped by person.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to query.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return array
 *   Nutrition measurements for a health center, within given period.
 *
 * @throws \Exception
 */
function hedley_stats_get_nutrition_measurements_grouped_by_person($health_center_id, $period, $extend = FALSE) {
  $result = hedley_stats_get_nutrition_measurements_grouped_by_clinic_type_and_person($health_center_id, $period, $extend);
  $result['individual'] = hedley_stats_get_nutrition_measurements_for_individual_encounters_grouped_by_person($health_center_id, $period, $extend);

  return $result;
}

/**
 * Gets all group encounter nutrition measurements, for a health center.
 *
 * Results are for certain period, and grouped by clinic type and person.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to query.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return array
 *   Nutrition measurements grouped by clinic type and person.
 *
 * @throws \Exception
 */
function hedley_stats_get_nutrition_measurements_grouped_by_clinic_type_and_person($health_center_id, $period, $extend = FALSE) {
  $result = [];
  $clinic_types = hedley_stats_get_all_clinic_types();
  foreach ($clinic_types as $clinic_type) {
    $result[$clinic_type] = [];
  }

  // All group measurements with nutrition fields mapping.
  $node_types = heldey_stats_get_nutrition_measurements_mapping_for_group_encounter();

  $query = hedley_stats_get_base_query($health_center_id, array_keys($node_types), $period, $extend);

  // Get the group type.
  hedley_general_join_field_to_query($query, 'node', 'field_session');
  hedley_general_join_field_to_query($query, 'node', 'field_clinic', TRUE, 'field_session.field_session_target_id');
  hedley_general_join_field_to_query($query, 'node', 'field_group_type', TRUE, 'field_clinic.field_clinic_target_id');

  // Get the person.
  hedley_general_join_field_to_query($query, 'node', 'field_person');

  // Get the nutrition signs for this person.
  hedley_general_join_field_to_query($query, 'node', 'field_nutrition_signs', FALSE);

  // Get all other measurements for this person.
  hedley_general_join_field_to_query($query, 'node', 'field_zscore_age', FALSE);
  hedley_general_join_field_to_query($query, 'node', 'field_muac', FALSE);
  hedley_general_join_field_to_query($query, 'node', 'field_zscore_length', FALSE);

  $rows = hedley_stats_run_node_query_in_batches($query);

  // Group measurements by person.
  foreach ($rows as $row) {
    // Get fields for current node type.
    $measurement_fields = $node_types[$row->type];

    foreach ($measurement_fields as $measurement_field) {
      $result[$row->field_group_type][$row->field_person][$row->type][$row->field_date_measured][$measurement_field] = $row->{$measurement_field};
    }
  }

  return $result;
}

/**
 * Gets all nutrition measurements at individual encounter, for a health center.
 *
 * Results are for certain period, and grouped by person.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to query.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return array
 *   Nutrition measurements at individual encounters, for a health center,
 *   within given per period.
 *
 * @throws \Exception
 */
function hedley_stats_get_nutrition_measurements_for_individual_encounters_grouped_by_person($health_center_id, $period, $extend = FALSE) {
  // All individual encounter measurements with nutrition fields mapping.
  $node_types = heldey_stats_get_nutrition_measurements_mapping_for_individual_encounter();

  $query = hedley_stats_get_base_query($health_center_id, array_keys($node_types), $period, $extend);

  // Get the person.
  hedley_general_join_field_to_query($query, 'node', 'field_person');

  // Get the nutrition signs for this person.
  hedley_general_join_field_to_query($query, 'node', 'field_nutrition_signs', FALSE);

  // Get all other measurements for this person.
  hedley_general_join_field_to_query($query, 'node', 'field_zscore_age', FALSE);
  hedley_general_join_field_to_query($query, 'node', 'field_muac', FALSE);
  hedley_general_join_field_to_query($query, 'node', 'field_zscore_length', FALSE);

  $result = hedley_stats_run_node_query_in_batches($query);

  // Group measurements by person.
  $people = [];
  foreach ($result as $measurement) {
    // Get fields for current node type.
    $measurement_fields = $node_types[$measurement->type];

    foreach ($measurement_fields as $measurement_field) {
      $people[$measurement->field_person][$measurement->type][$measurement->field_date_measured][$measurement_field] = $measurement->{$measurement_field};
    }
  }

  return $people;
}

/**
 * Executes query in batches, with constant number of results at each batch.
 *
 * Complex query can produce, 50K, 100K or even more rows of result.
 * This size may cause 'out of memory' exception.
 * To prevent this, we run these queries in batches. There will be more hits
 * at the DB, but we don't end up running out of memory.
 *
 * @param SelectQuery $query
 *   The query to execute.
 * @param int $batch
 *   Number of results we want to receive at each batch. Defaults to 5000.
 *
 * @return array
 *   Query accumulated result.
 */
function hedley_stats_run_node_query_in_batches(SelectQuery $query, $batch = 10000) {
  $query->orderBy('node.nid');

  $result = [];
  $nid = 0;

  while (TRUE) {
    $batch_query = clone $query;
    // We want to get results for nodes we did not process before.
    $batch_query->condition('nid', $nid, '>');

    $batch_result = $batch_query
      ->range(0, $batch)
      ->execute()
      ->fetchAllAssoc('nid');

    if (empty($batch_result)) {
      // There's no more results, so we know that no more
      // batches are needed, and we can exit the WHILE loop.
      break;
    }

    // Accumulate result.
    $result = array_merge($result, $batch_result);
    // Locate the latest node processed, for the next batch.
    $nid = end($batch_result)->nid;
    // Free up memory.
    drupal_static_reset();
  }

  return $result;
}

/**
 * Base query for stats - pulls content in given period for Health Center.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string|array $node_type
 *   Either single content type or an array of types.
 * @param string $period
 *   Optional; The period during which content was taken.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return \SelectQuery
 *   THe query object.
 *
 * @throws \Exception
 */
function hedley_stats_get_base_query($health_center_id, $node_type, $period = FALSE, $extend = FALSE) {
  $query = db_select('node', 'node');
  $query->fields('node', ['nid', 'type', 'created']);
  $node_type_operator = is_array($node_type) ? 'IN' : '=';
  $query
    ->condition('type', $node_type, $node_type_operator)
    ->condition('status', NODE_PUBLISHED);

  // All nodes have the Health center info under `field_shards`.
  $health_center_field = 'field_shards';
  // Filter by health center.
  hedley_general_join_field_to_query($query, 'node', $health_center_field);
  $health_center_field_name = $health_center_field . '.' . $health_center_field . '_target_id';
  $query->condition($health_center_field_name, $health_center_id);

  $encounter_types = hedley_general_get_individual_encounter_types();
  $participant_types = [
    'individual_participant',
    'pmtct_participant',
  ];

  // If we're dealing with group session or individual encounter,
  // creation date is resolved using 'field_scheduled_date'.
  if (in_array($node_type, $encounter_types) || $node_type == 'session') {
    $date_field = 'field_scheduled_date';
    hedley_general_join_field_to_query($query, 'node', $date_field, FALSE, NULL, NULL, TRUE);
  }
  // If we're dealing with individual participant, creation date is
  // resolved using 'field_expected'.
  elseif (in_array($node_type, $participant_types)) {
    $date_field = 'field_expected';
    hedley_general_join_field_to_query($query, 'node', $date_field, FALSE, NULL, NULL, TRUE);
  }
  // Dealing with measurements.
  // For all measurement nodes, creation date is
  // resolved using 'field_date_measured'.
  else {
    $date_field = 'field_date_measured';
    hedley_general_join_field_to_query($query, 'node', $date_field);
  }

  if ($period) {
    $date_field_name = $date_field . '.' . $date_field . '_value';

    $date = hedley_stats_get_period($period, $extend);
    $query->condition($date_field_name, [
      $date['start'],
      $date['end'],
    ], 'BETWEEN');
  }

  return $query;
}

/**
 * Get the start date based on period of time.
 *
 * @param string $period
 *   The period to calculate.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return false|array
 *   The date period.
 */
function hedley_stats_get_period($period, $extend = FALSE) {
  $range = hedley_stats_get_range_for_period($period, $extend);

  $db_date_field_format = 'Y-m-d 00:00:00';
  $date = [
    'start' => date($db_date_field_format, $range['start']),
    'end' => date($db_date_field_format, $range['end']),
  ];

  return $date;
}

/**
 * Returns the start and the end of the period as timestamps.
 *
 * @param string $period
 *   The name of the period.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return array
 *   The start and the end of the period timestamps.
 */
function hedley_stats_get_range_for_period($period, $extend = FALSE) {
  $now = time();
  $one_day = 24 * 3600;

  switch ($period) {
    case HEDLEY_STATS_PERIOD_THIS_MONTH:
      return [
        'start' => strtotime("first day of this month"),
        'end' => $now + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_LAST_MONTH:
      return [
        'start' => strtotime("first day of previous month"),
        'end' => strtotime("last day of previous month") + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_TWO_MONTHS_AGO:
      return [
        'start' => strtotime("first day of -2 months"),
        'end' => strtotime("last day of -2 months") + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_PAST_THREE_MONTHS:
      return [
        'start' => strtotime("first day of -2 months"),
        'end' => $now + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_ONE_YEAR:
      $start = strtotime("last day of -1 year") + $one_day;
      if ($extend) {
        $current_month = date('n');
        $current_year = date('Y');
        $start = $start - $one_day * hedley_stats_calculate_days_in_month($current_year - 1, $current_month);
      }

      return [
        'start' => $start,
        'end' => $now + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_LAST_YEAR:
      return [
        'start' => strtotime("last day of -2 years") + $one_day,
        'end' => strtotime("last day of -1 year") + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_480_DAYS:
      return [
        'start' => strtotime("-480 days"),
        'end' => $now + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS:
      return [
        'start' => strtotime("first day of -5 months"),
        'end' => $now + $one_day,
      ];
  }
}

/**
 * Helper function; Convert Unix timestamp to YYYYMMDD.
 *
 * @param int $timestamp
 *   The Unix timestamp.
 *
 * @return false|string
 *   The converted timestamp.
 */
function hedley_stats_convert_timestamp_to_nominal($timestamp) {
  return date('Y-m-d', $timestamp);
}

/**
 * Measurements types with the z-score fields mapped at group encounter.
 *
 * @return array
 *   The measurements content types with mapping.
 */
function heldey_stats_get_nutrition_measurements_mapping_for_group_encounter() {
  return [
    'height' => [
      'field_zscore_age',
    ],
    'nutrition' => [
      'field_nutrition_signs',
    ],
    'muac' => [
      'field_muac',
    ],
    'weight' => [
      'field_zscore_age',
      'field_zscore_length',
    ],
  ];
}

/**
 * Measurements types with the z-score fields mapped at individual encounter.
 *
 * @return array
 *   The measurements content types with mapping.
 */
function heldey_stats_get_nutrition_measurements_mapping_for_individual_encounter() {
  return [
    'nutrition_height' => [
      'field_zscore_age',
    ],
    'nutrition_nutrition' => [
      'field_nutrition_signs',
    ],
    'nutrition_muac' => [
      'field_muac',
    ],
    'nutrition_weight' => [
      'field_zscore_age',
      'field_zscore_length',
    ],
  ];
}

/**
 * Get PMTCT participants by clinic.
 *
 * @param int $clinic_id
 *   The clinic node ID.
 * @param int $range
 *   The queries' range.
 *
 * @return array
 *   Node IDs if they exist or empty array if no nodes exist.
 */
function hedley_stats_get_pmtct_participants_by_clinic($clinic_id, $range = 100) {

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'pmtct_participant')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_clinic', 'target_id', $clinic_id)
    ->range(0, $range);

  $result = $query->execute();

  return !empty($result['node']) ? array_keys($result['node']) : [];
}

/**
 * Get clinic's sessions by period.
 *
 * @param int $clinic_id
 *   The clinic node ID.
 * @param string $period
 *   The wanted period.
 * @param int $range
 *   The queries' range.
 *
 * @return array
 *   Node IDs if they exist or empty array if no nodes exist.
 */
function hedley_stats_get_clinic_sessions_by_period($clinic_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR, $range = 100) {
  $dates = hedley_stats_get_period($period);

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'session')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_clinic', 'target_id', $clinic_id)
    // Meaning that we are still expecting those participants.
    ->fieldCondition('field_scheduled_date', 'value', $dates['start'], '>=')
    ->fieldCondition('field_scheduled_date', 'value', $dates['end'], '<=')
    ->propertyOrderBy('nid')
    ->range(0, $range);

  $result = $query->execute();

  return !empty($result['node']) ? array_keys($result['node']) : [];
}

/**
 * Handle stats cache.
 *
 * @param string $method
 *   Whether to get or set cache.
 * @param string $cache_name
 *   The cache name.
 * @param int $health_center_id
 *   The health center node ID.
 * @param string $period
 *   Optional; A period for the cache ID.
 * @param mixed $cache_data
 *   Optional; The cache data to set.
 *
 * @return mixed|null
 *   Either the cache data or nothing if we are setting it.
 */
function hedley_stats_handle_cache($method, $cache_name, $health_center_id, $period = NULL, $cache_data = NULL) {
  $cache_id = $period ? $cache_name . '_' . $health_center_id . '_' . $period : $cache_name . '_' . $health_center_id;

  switch ($method) {
    case HEDLEY_STATS_CACHE_GET:
      $cached = cache_get($cache_id);
      return !empty($cached) ? $cached->data['value'] : NULL;

    case HEDLEY_STATS_CACHE_SET:
      $cached = [
        'timestamp' => time(),
        'value' => $cache_data,
      ];
      cache_set($cache_id, $cached);
      break;

    case HEDLEY_STATS_CACHE_CLEAR:
      $cache = cache_get($cache_id);
      if (!empty($cache)) {
        cache_clear_all($cache_id, 'cache');
      }
      break;
  }
}

/**
 * Returns number of days in given month of given year.
 *
 * @param int $year
 *   The year.
 * @param int $month
 *   The month.
 *
 * @see: https://stackoverflow.com/questions/9240891/
 *       cal-days-in-month-function-is-not-working#answer-9240933.
 *
 * @return int
 *   Number of days in given month of given year
 */
function hedley_stats_calculate_days_in_month($year, $month) {
  return (int) date('t', mktime(0, 0, 0, $month, 1, $year));
}
