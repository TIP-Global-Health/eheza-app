<?php

/**
 * @file
 * Code for the Hedley Statistics module.
 */

define('HEDLEY_STATS_PERIOD_THIS_MONTH', 'this_month');
define('HEDLEY_STATS_PERIOD_LAST_MONTH', 'last_month');
define('HEDLEY_STATS_PERIOD_THREE_MONTHS', 'three_months');
define('HEDLEY_STATS_PERIOD_ONE_YEAR', 'one_year');
define('HEDLEY_STATS_PERIOD_LAST_YEAR', 'last_year');
define('HEDLEY_STATS_SEVERE', 'severe');
define('HEDLEY_STATS_MODERATE', 'moderate');
define('HEDLEY_STATS_GOOD', 'good');

/**
 * Return new people in a Health centers related stats.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 *
 * @return array
 *   Array with the result.
 *
 * @throws \Exception
 */
function hedley_stats_get_children_beneficiaries_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  $query = hedley_stats_get_base_query($health_center_id, 'person', $period);

  // Get gender and age.
  hedley_stats_join_field_to_query($query, 'node', 'field_gender');
  hedley_stats_join_field_to_query($query, 'node', 'field_birth_date');

  // Currently our way of knowing who is kid, is checking they are under
  // 13.
  $birthdate_start = date('Y-m-d H:i:s', strtotime("13 years ago"));
  $now_date = date('Y-m-d H:i:s');

  $query->condition('field_birth_date.field_birth_date_value', [
    $birthdate_start,
    $now_date,
  ], 'BETWEEN');

  $result = $query
    ->execute()
    ->fetchAllAssoc('nid');

  // Prepare data to be consumed by client side.
  foreach ($result as &$row) {
    $row->created = hedley_stats_convert_timestamp_to_nominal($row->created);
    $row->field_birth_date = hedley_stats_convert_timestamp_to_nominal(strtotime($row->field_birth_date));
  }

  return array_values($result);
}

/**
 * Return family planning related states.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 *
 * @return array
 *   Array with the result.
 *
 * @throws \Exception
 */
function hedley_stats_get_family_planning_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  $query = hedley_stats_get_base_query($health_center_id, 'family_planning', $period);

  // Join `Signs` field (e.g. Pill, Condoms, etc').
  hedley_stats_join_field_to_query($query, 'node', 'field_family_planning_signs');

  $query->groupBy('node.nid');
  $query->addExpression('GROUP_CONCAT(field_family_planning_signs.field_family_planning_signs_value)', 'signs');

  $result = $query
    ->execute()
    ->fetchAllAssoc('nid');

  // Prepare data to be consumed by client side.
  foreach ($result as &$row) {
    $row->created = hedley_stats_convert_timestamp_to_nominal($row->created);
    $row->signs = explode(',', $row->signs);

    // Remove unused data, to save bandwidth.
    unset($row->nid);
    unset($row->type);
    unset($row->field_shards);
    unset($row->field_family_planning_signs);
  }

  return array_values($result);
}

/**
 * Return Malnourished beneficiaries related states.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 *
 * @return array
 *   Array with the result.
 *
 * @throws \Exception
 */
function hedley_stats_get_malnourished_beneficiaries_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  $query = hedley_stats_get_base_query($health_center_id, 'height', $period);

  // Join `Z-score age`.
  hedley_stats_join_field_to_query($query, 'node', 'field_zscore_age');

  // Malnourished is defined as Z-score below -1.
  $query->condition('field_zscore_age.field_zscore_age_value', -1, '<');

  // Get child's gender, via the People content type.
  hedley_stats_join_field_to_query($query, 'node', 'field_person');
  hedley_stats_join_field_to_query($query, 'node', 'field_gender', TRUE, "field_person.field_person_target_id");

  $result = $query
    ->execute()
    ->fetchAllAssoc('nid');

  // Prepare data to be consumed by client side.
  foreach ($result as &$row) {
    $row->created = hedley_stats_convert_timestamp_to_nominal($row->created);
    $row->field_zscore_age = floatval($row->field_zscore_age);

    // Remove unused data, to save bandwidth.
    unset($row->nid);
    unset($row->type);
    unset($row->field_shards);
    unset($row->field_person);
  }

  return array_values($result);
}

/**
 * Return "Good nutrition" percentages for last year and the year before.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 *
 * @return array
 *   AN array with good nutrition stats.
 *
 * @throws \Exception
 */
function hedley_stats_get_good_nutrition($health_center_id) {
  $good_nutrition_result = [
    'last_year' => 0,
    'this_year' => 0,
  ];

  $result = [];

  // All the measurements nodes with measurement field mapped.
  $node_types = [
    'height' => [
      'field_zscore_age',
    ],
    'nutrition' => [
      'field_nutrition_signs',
    ],
    'muac' => [
      'field_muac',
    ],
    'weight' => [
      'field_zscore_age',
      'field_zscore_length',
      'field_zscore_bmi',
    ],
  ];

  // We start from attendance for this year and last year and we get
  // measurements by the session (Encounter) ID.
  $queries['last_year'] = hedley_stats_get_base_query($health_center_id, array_keys($node_types), HEDLEY_STATS_PERIOD_LAST_YEAR, 'field_date_measured', TRUE);
  $queries['this_year'] = hedley_stats_get_base_query($health_center_id, array_keys($node_types), HEDLEY_STATS_PERIOD_ONE_YEAR, 'field_date_measured', TRUE);

  foreach ($queries as $key => $query) {
    // Get the group type.
    hedley_stats_join_field_to_query($query, 'node', 'field_session');
    hedley_stats_join_field_to_query($query, 'node', 'field_clinic', TRUE, "field_session.field_session_target_id");
    hedley_stats_join_field_to_query($query, 'node', 'field_group_type', TRUE, "field_clinic.field_clinic_target_id");
    // Only FBF groups.
    $query->condition('field_group_type.field_group_type_value', 'fbf');

    // Get the person.
    hedley_stats_join_field_to_query($query, 'node', 'field_person');

    // Get the nutrition signs for this person.
    hedley_stats_join_field_to_query($query, 'node', 'field_nutrition_signs', FALSE);

    // Get all other measurements for this person.
    hedley_stats_join_field_to_query($query, 'node', 'field_zscore_age', FALSE);
    hedley_stats_join_field_to_query($query, 'node', 'field_muac', FALSE);
    hedley_stats_join_field_to_query($query, 'node', 'field_zscore_length', FALSE);
    hedley_stats_join_field_to_query($query, 'node', 'field_zscore_bmi', FALSE);

    // Only FBF groups.
    $query->condition('field_group_type.field_group_type_value', 'fbf');

    $result[$key] = $query
      ->execute()
      ->fetchAllAssoc('nid');
  }

  $people = [];
  foreach ($result as $period => $measurements) {
    foreach ($measurements as $measurement) {
      // Get fields for current node type.
      $measurement_fields = $node_types[$measurement->type];

      // Group measurements by person.
      foreach ($measurement_fields as $measurement_field) {
        $people[$period][$measurement->field_person][$measurement->type][$measurement_field] = $measurement->{$measurement_field};
      }
    }
  }

  // Analyzing the measurements.
  $nutrition_signs = hedley_stats_nutrition_signs();
  $all_people_measured = [
    'last_year' => count($people['last_year']),
    'this_year' => count($people['this_year']),
  ];
  $people_good_nutrition = [
    'last_year' => 0,
    'this_year' => 0,
  ];

  // Go through all the people.
  foreach ($people as $period => $data) {
    foreach ($data as $person) {
      // Define that the person has good nutrition.
      $good_nutrition = 1;

      foreach ($person as $type => $measurement) {
        // We are interested only with the nutrition signs that match the
        // current type.
        $current_nutrition_signs = $nutrition_signs[$type];

        // Go through all the measurements for this person.
        foreach ($measurement as $field_name => $value) {
          // The nutrition value should be 'none' to be considered "good".
          if ($type == 'nutrition') {
            if ($value != $current_nutrition_signs[$field_name][HEDLEY_STATS_GOOD]) {
              $good_nutrition = 0;
            }
          }
          // All the rest of the measurements should be bigger than "moderate"
          // to be considered good.
          else {
            if ($value <= $current_nutrition_signs[$field_name][HEDLEY_STATS_MODERATE]) {
              $good_nutrition = 0;
            }
          }
        }
      }

      if ($good_nutrition) {
        $people_good_nutrition[$period]++;
      }
    }
  }

  return [
    'all' => $all_people_measured,
    'good' => $people_good_nutrition,
  ];
}

/**
 * Return "Total Encounters" per period.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 *
 * @return array
 *   AN array with total encounters.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_encounters($health_center_id) {
  $result = [
    'last_year' => 0,
    'this_year' => 0,
  ];
  $queries['last_year'] = hedley_stats_get_base_query($health_center_id, 'attendance', HEDLEY_STATS_PERIOD_LAST_YEAR, 'field_date_measured');
  $queries['this_year'] = hedley_stats_get_base_query($health_center_id, 'attendance', HEDLEY_STATS_PERIOD_ONE_YEAR, 'field_date_measured');

  foreach ($queries as $key => $query) {
    // Get the group type.
    hedley_stats_join_field_to_query($query, 'node', 'field_session');
    hedley_stats_join_field_to_query($query, 'node', 'field_clinic', TRUE, "field_session.field_session_target_id");
    hedley_stats_join_field_to_query($query, 'node', 'field_group_type', TRUE, "field_clinic.field_clinic_target_id");

    // Only FBF groups.
    $query->condition('field_group_type.field_group_type_value', 'fbf');

    $result[$key] = $query
      ->execute()
      ->rowCount();
  }

  return $result;
}

/**
 * Get base query for stats.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string|array $node_type
 *   The node type to query - Can be an array of types.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 * @param string $date_field
 *   The field name to check the period condition against.
 * @param bool $measurements
 *   The queried nodes are measurements.
 *
 * @return \SelectQuery
 *   THe query object.
 *
 * @throws \Exception
 */
function hedley_stats_get_base_query($health_center_id, $node_type, $period, $date_field = 'created', $measurements = FALSE) {
  $query = db_select('node', 'node');
  $query->fields('node', ['nid', 'created', 'type']);

  // Date condition, could be the node's created property or any other field can
  // be accepted as well, here's the logic to handle that.
  if ($date_field != 'created') {
    // We need to include the date field in the query if it's not the default
    // one.
    hedley_stats_join_field_to_query($query, 'node', $date_field);
    $date_field_name = $date_field . '.' . $date_field . '_value';
    $as_timestamp = FALSE;
  }
  else {
    $date_field_name = 'created';
    $as_timestamp = TRUE;
  }

  $date = hedley_stats_get_period($period, $as_timestamp);
  $query->condition($date_field_name, [
    $date['start'],
    $date['end'],
  ], 'BETWEEN');

  $node_type_operator = is_array($node_type) ? 'IN' : '=';
  $query
    ->condition('type', $node_type, $node_type_operator)
    ->condition('status', NODE_PUBLISHED);

  $health_center_field_name = 'field_health_center';

  // Some node types have the Health center info under `Shards` field.
  if (!is_array($node_type)) {
    if (field_info_instance('node', 'field_shards', $node_type)) {
      $health_center_field_name = 'field_shards';
    }
  }

  // All measurement nodes have the Health center info under `Shards` field.
  if ($measurements) {
    $health_center_field_name = 'field_shards';
  }

  // Filter by health center.
  hedley_stats_join_field_to_query($query, 'node', $health_center_field_name);
  $query->condition($health_center_field_name . '.' . $health_center_field_name . '_target_id', $health_center_id);

  return $query;
}

/**
 * Get the start date based on period of time.
 *
 * @param string $period
 *   The period to calculate.
 * @param bool $as_timestamp
 *   Determine if date should be returned as string or timestamp. Defaults to
 *   TRUE.
 *
 * @return false|array
 *   The date period.
 */
function hedley_stats_get_period($period, $as_timestamp = TRUE) {
  $db_date_field_format = 'Y-m-d h:i:s';
  $date = [
    'start' => time(),
    'end' => time(),
  ];

  switch ($period) {
    case HEDLEY_STATS_PERIOD_THIS_MONTH:
      $date = [
        'start' => date($db_date_field_format, strtotime("first day of this month")),
        'end' => date($db_date_field_format, time()),
      ];
      break;

    case HEDLEY_STATS_PERIOD_LAST_MONTH:
      $date = [
        'start' => date($db_date_field_format, strtotime("first day of previous month")),
        'end' => date($db_date_field_format, time()),
      ];
      break;

    case HEDLEY_STATS_PERIOD_THREE_MONTHS:
      $date = [
        'start' => date($db_date_field_format, strtotime("3 months ago")),
        'end' => date($db_date_field_format, time()),
      ];
      break;

    case HEDLEY_STATS_PERIOD_ONE_YEAR:
      $date = [
        'start' => date($db_date_field_format, strtotime("last year")),
        'end' => date($db_date_field_format, time()),
      ];
      break;

    case HEDLEY_STATS_PERIOD_LAST_YEAR:
      $date = [
        'start' => date($db_date_field_format, strtotime("-2 years")),
        'end' => date($db_date_field_format, strtotime("last year")),
      ];
      break;
  }

  if ($as_timestamp) {
    $date['start'] = strtotime($date['start']);
    $date['end'] = strtotime($date['end']);
  }

  return $date;
}

/**
 * Join a field to a DB Select query, and add its main value.
 *
 * @param SelectQuery $query
 *   Query to join to.
 * @param string $entity_type
 *   Type of the host entity of the field. Or NULL to avoid filtering the field
 *   table by entity type.
 * @param string $field_name
 *   Field name.
 * @param bool $require
 *   Whether filter out rows where this field would be NULL.
 * @param string $entity_id_selector
 *   SQL selector for the column by which the field is joined. The entity ID is
 *   used by default.
 *
 * @throws Exception
 */
function hedley_stats_join_field_to_query(SelectQuery $query, $entity_type, $field_name, $require = TRUE, $entity_id_selector = NULL) {
  $field = field_info_field($field_name);
  $table_name = _field_sql_storage_tablename($field);

  if (!$entity_id_selector) {
    if (!$entity_type) {
      throw new Exception('Entity type is required when ID selector is not specified');
    }
    // Set default entity ID selector.
    switch ($entity_type) {
      case 'user':
        $entity_id_selector = 'users.uid';
        break;

      case 'node':
        $entity_id_selector = 'node.nid';
        break;

      default:
        throw new Exception(format_string('hedley_general_join_field_to_query() is not implemented for entity_type: "@type"', ['@type' => $entity_type]));
    }
  }

  $join = $require ? 'innerJoin' : 'leftJoin';
  $arguments = [':type' => $entity_type];
  $conditions[] = "$entity_id_selector = $field_name.entity_id";
  if ($entity_type) {
    $conditions[] = "$field_name.entity_type = :type";
  }

  $query->$join($table_name, $field_name, implode(' AND ', $conditions), $arguments);

  $column_suffix = $field['type'] == 'entityreference' ? 'target_id' : 'value';

  $query->addField($field_name, $field_name . '_' . $column_suffix, $field_name);
}

/**
 * Convert Unix timestamp to YYYYMMDD.
 *
 * @param int $timestamp
 *   The Unix timestamp.
 *
 * @return false|string
 *   The converted timestamp.
 */
function hedley_stats_convert_timestamp_to_nominal($timestamp) {
  return date('Y-m-d', $timestamp);
}

/**
 * Get the info about nutrition signs for all measurements.
 *
 * @return array
 *   The detailed measurements signs.
 */
function hedley_stats_nutrition_signs() {
  return [
    'height' => [
      'field_zscore_age' => [
        HEDLEY_STATS_SEVERE => -3,
        HEDLEY_STATS_MODERATE => -2,
        HEDLEY_STATS_GOOD => -1.99,
      ],
    ],
    'nutrition' => [
      'field_nutrition_signs' => [
        HEDLEY_STATS_GOOD => 'none',
      ],
    ],
    'muac' => [
      'field_muac' => [
        HEDLEY_STATS_SEVERE => 18.5,
        HEDLEY_STATS_MODERATE => 22,
        HEDLEY_STATS_GOOD => 22.1,
      ],
    ],
    'weight' => [
      'field_zscore_age' => [
        HEDLEY_STATS_SEVERE => -3,
        HEDLEY_STATS_MODERATE => -2,
        HEDLEY_STATS_GOOD => -1.99,
      ],
      'field_zscore_length' => [
        HEDLEY_STATS_SEVERE => -3,
        HEDLEY_STATS_MODERATE => -2,
        HEDLEY_STATS_GOOD => -1.99,
      ],
      'field_zscore_bmi' => [
        HEDLEY_STATS_SEVERE => -3,
        HEDLEY_STATS_MODERATE => -2,
        HEDLEY_STATS_GOOD => -1.99,
      ],
    ],
  ];
}
