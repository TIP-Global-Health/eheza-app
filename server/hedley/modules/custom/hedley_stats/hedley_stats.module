<?php

/**
 * @file
 * Code for the Hedley Statistics module.
 */

define('HEDLEY_STATS_PERIOD_THIS_MONTH', 'this_month');
define('HEDLEY_STATS_PERIOD_LAST_MONTH', 'last_month');
define('HEDLEY_STATS_PERIOD_THREE_MONTHS', 'three_months');
define('HEDLEY_STATS_PERIOD_ONE_YEAR', 'one_year');
define('HEDLEY_STATS_PERIOD_LAST_YEAR', 'last_year');

/**
 * Return new people in a Health centers related stats.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 *
 * @return array
 *   Array with the result.
 *
 * @throws \Exception
 */
function hedley_stats_get_children_beneficiaries_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  $query = hedley_stats_get_base_query($health_center_id, 'person', $period);

  // Get gender and age.
  hedley_stats_join_field_to_query($query, 'node', 'field_gender');
  hedley_stats_join_field_to_query($query, 'node', 'field_birth_date');

  // Currently our way of knowing who is kid, is checking they are under
  // 13.
  $birthdate_start = date('Y-m-d H:i:s', strtotime("13 years ago"));
  $now_date = date('Y-m-d H:i:s');

  $query->condition('field_birth_date.field_birth_date_value', [$birthdate_start, $now_date], 'BETWEEN');

  $result = $query
    ->execute()
    ->fetchAllAssoc('nid');

  // Prepare data to be consumed by client side.
  foreach ($result as &$row) {
    $row->created = hedley_stats_convert_timestamp_to_nominal($row->created);
    $row->field_birth_date = hedley_stats_convert_timestamp_to_nominal(strtotime($row->field_birth_date));
  }

  return array_values($result);
}

/**
 * Return family planning related states.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 *
 * @return array
 *   Array with the result.
 *
 * @throws \Exception
 */
function hedley_stats_get_family_planning_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  $query = hedley_stats_get_base_query($health_center_id, 'family_planning', $period);

  // Join `Signs` field (e.g. Pill, Condoms, etc').
  hedley_stats_join_field_to_query($query, 'node', 'field_family_planning_signs');

  $query->groupBy('node.nid');
  $query->addExpression('GROUP_CONCAT(field_family_planning_signs.field_family_planning_signs_value)', 'signs');

  $result = $query
    ->execute()
    ->fetchAllAssoc('nid');

  // Prepare data to be consumed by client side.
  foreach ($result as &$row) {
    $row->created = hedley_stats_convert_timestamp_to_nominal($row->created);
    $row->signs = explode(',', $row->signs);

    // Remove unused data, to save bandwidth.
    unset($row->nid);
    unset($row->field_shards);
    unset($row->field_family_planning_signs);
  }

  return array_values($result);
}

/**
 * Return Malnourished beneficiaries related states.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 *
 * @return array
 *   Array with the result.
 *
 * @throws \Exception
 */
function hedley_stats_get_malnourished_beneficiaries_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  $query = hedley_stats_get_base_query($health_center_id, 'height', $period);

  // Join `Z-score age`.
  hedley_stats_join_field_to_query($query, 'node', 'field_zscore_age');

  // Malnourished is defined as Z-score below -1.
  $query->condition('field_zscore_age.field_zscore_age_value', -1, '<');

  // Get child's gender, via the People content type.
  hedley_stats_join_field_to_query($query, 'node', 'field_person');
  hedley_stats_join_field_to_query($query, 'node', 'field_gender', TRUE, "field_person.field_person_target_id");

  $result = $query
    ->execute()
    ->fetchAllAssoc('nid');

  // Prepare data to be consumed by client side.
  foreach ($result as &$row) {
    $row->created = hedley_stats_convert_timestamp_to_nominal($row->created);
    $row->field_zscore_age = floatval($row->field_zscore_age);

    // Remove unused data, to save bandwidth.
    unset($row->nid);
    unset($row->field_shards);
    unset($row->field_person);
  }

  return array_values($result);
}

/**
 * Return "Total Encounters" per period.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 *
 * @return array
 *   AN array with total encounters.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_encounters($health_center_id) {
  $result = [
    'last_year' => 0,
    'this_year' => 0,
  ];
  $queries['last_year'] = hedley_stats_get_base_query($health_center_id, 'attendance', HEDLEY_STATS_PERIOD_LAST_YEAR, 'field_date_measured');
  $queries['this_year'] = hedley_stats_get_base_query($health_center_id, 'attendance', HEDLEY_STATS_PERIOD_ONE_YEAR, 'field_date_measured');

  foreach ($queries as $key => $query) {
    // Get the group type.
    hedley_stats_join_field_to_query($query, 'node', 'field_session');
    hedley_stats_join_field_to_query($query, 'node', 'field_clinic', TRUE, "field_session.field_session_target_id");
    hedley_stats_join_field_to_query($query, 'node', 'field_group_type', TRUE, "field_clinic.field_clinic_target_id");

    // Only FBF groups.
    $query->condition('field_group_type.field_group_type_value', 'fbf');

    $result[$key] = $query
      ->execute()
      ->rowCount();
  }

  return $result;
}

/**
 * Get base query for stats.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $node_type
 *   The node type to query.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 * @param string $date_field
 *   The field name to check the period condition against.
 *
 * @return \SelectQuery
 *   THe query object.
 *
 * @throws \Exception
 */
function hedley_stats_get_base_query($health_center_id, $node_type, $period, $date_field = 'created') {
  $query = db_select('node', 'node');
  $query->fields('node', ['nid', 'created']);

  // Date condition, could be the node's created property or any other field can
  // be accepted as well, here's the logic to handle that.
  if ($date_field != 'created') {
    // We need to include the date field in the query if it's not the default
    // one.
    hedley_stats_join_field_to_query($query, 'node', $date_field);
    $date_field_name = $date_field . '.' . $date_field . '_value';
    $as_timestamp = FALSE;
  }
  else {
    $date_field_name = 'created';
    $as_timestamp = TRUE;
  }

  $date = hedley_stats_get_period($period, $as_timestamp);
  $query->condition($date_field_name, [$date['start'], $date['end']], 'BETWEEN');

  $query
    ->condition('type', $node_type)
    ->condition('status', NODE_PUBLISHED);

  $health_center_field_name = 'field_health_center';

  // Some node types have the Health center info under `Shards` field.
  if (field_info_instance('node', 'field_shards', $node_type)) {
    $health_center_field_name = 'field_shards';
  }

  // Filter by health center.
  hedley_stats_join_field_to_query($query, 'node', $health_center_field_name);
  $query->condition($health_center_field_name . '.' . $health_center_field_name . '_target_id', $health_center_id);

  return $query;
}

/**
 * Get the start date based on period of time.
 *
 * @param string $period
 *   The period to calculate.
 * @param bool $as_timestamp
 *   Determine if date should be returned as string or timestamp. Defaults to
 *   TRUE.
 *
 * @return false|array
 *   The date period.
 */
function hedley_stats_get_period($period, $as_timestamp = TRUE) {
  $db_date_field_format = 'Y-m-d h:i:s';
  $date = [
    'start' => time(),
    'end' => time(),
  ];

  switch ($period) {
    case HEDLEY_STATS_PERIOD_THIS_MONTH:
      $date = [
        'start' => date($db_date_field_format, strtotime("first day of this month")),
        'end' => date($db_date_field_format, time()),
      ];
      break;

    case HEDLEY_STATS_PERIOD_LAST_MONTH:
      $date = [
        'start' => date($db_date_field_format, strtotime("first day of previous month")),
        'end' => date($db_date_field_format, time()),
      ];
      break;

    case HEDLEY_STATS_PERIOD_THREE_MONTHS:
      $date = [
        'start' => date($db_date_field_format, strtotime("3 months ago")),
        'end' => date($db_date_field_format, time()),
      ];
      break;

    case HEDLEY_STATS_PERIOD_ONE_YEAR:
      $date = [
        'start' => date($db_date_field_format, strtotime("last year")),
        'end' => date($db_date_field_format, time()),
      ];
      break;

    case HEDLEY_STATS_PERIOD_LAST_YEAR:
      $date = [
        'start' => date($db_date_field_format, strtotime("-2 years")),
        'end' => date($db_date_field_format, strtotime("last year")),
      ];
      break;
  }

  if ($as_timestamp) {
    $date['start'] = strtotime($date['start']);
    $date['end'] = strtotime($date['end']);
  }

  return $date;
}

/**
 * Join a field to a DB Select query, and add its main value.
 *
 * @param SelectQuery $query
 *   Query to join to.
 * @param string $entity_type
 *   Type of the host entity of the field. Or NULL to avoid filtering the field
 *   table by entity type.
 * @param string $field_name
 *   Field name.
 * @param bool $require
 *   Whether filter out rows where this field would be NULL.
 * @param string $entity_id_selector
 *   SQL selector for the column by which the field is joined. The entity ID is
 *   used by default.
 *
 * @throws Exception
 */
function hedley_stats_join_field_to_query(SelectQuery $query, $entity_type, $field_name, $require = TRUE, $entity_id_selector = NULL) {
  $field = field_info_field($field_name);
  $table_name = _field_sql_storage_tablename($field);

  if (!$entity_id_selector) {
    if (!$entity_type) {
      throw new Exception('Entity type is required when ID selector is not specified');
    }
    // Set default entity ID selector.
    switch ($entity_type) {
      case 'user':
        $entity_id_selector = 'users.uid';
        break;

      case 'node':
        $entity_id_selector = 'node.nid';
        break;

      default:
        throw new Exception(format_string('hedley_general_join_field_to_query() is not implemented for entity_type: "@type"', ['@type' => $entity_type]));
    }
  }

  $join = $require ? 'innerJoin' : 'leftJoin';
  $arguments = [':type' => $entity_type];
  $conditions[] = "$entity_id_selector = $field_name.entity_id";
  if ($entity_type) {
    $conditions[] = "$field_name.entity_type = :type";
  }

  $query->$join($table_name, $field_name, implode(' AND ', $conditions), $arguments);

  $column_suffix = $field['type'] == 'entityreference' ? 'target_id' : 'value';

  $query->addField($field_name, $field_name . '_' . $column_suffix, $field_name);
}

/**
 * Convert Unix timestamp to YYYYMMDD.
 *
 * @param int $timestamp
 *   The Unix timestamp.
 *
 * @return false|string
 *   The converted timestamp.
 */
function hedley_stats_convert_timestamp_to_nominal($timestamp) {
  return date('Y-m-d', $timestamp);
}
