<?php

/**
 * @file
 * Code for the Hedley Statistics module.
 */

// Advanced queue items.
define('HEDLEY_STATS_CALCULATE_STATS', 'hedley_stats_calculate_stats');

// Periods.
define('HEDLEY_STATS_PERIOD_THIS_MONTH', 'this_month');
define('HEDLEY_STATS_PERIOD_LAST_MONTH', 'last_month');
define('HEDLEY_STATS_PERIOD_TWO_MONTHS_AGO', 'two_months_ago');
define('HEDLEY_STATS_PERIOD_PAST_THREE_MONTHS', 'past_three_month');
define('HEDLEY_STATS_PERIOD_ONE_YEAR', 'one_year');
define('HEDLEY_STATS_PERIOD_LAST_YEAR', 'last_year');
define('HEDLEY_STATS_PERIOD_480_DAYS', '480_days');
define('HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS', 'past_six_month');

define('HEDLEY_STATS_GOOD', '1');
define('HEDLEY_STATS_MODERATE', '2');
define('HEDLEY_STATS_SEVERE', '3');

// Encounter types.
define('HEDLEY_STATS_PRENATAL_ENCOUNTER_TYPE', 'antenatal');
define('HEDLEY_STATS_ACUTE_ILLNESS_ENCOUNTER_TYPE', 'acute-illness');

// Statistics cache types.
define('HEDLEY_STATS_NUTRITION', 'sync_stats_nutrition');
define('HEDLEY_STATS_PRENATAL', 'sync_stats_prenatal');
define('HEDLEY_STATS_ACUTE_ILLNESS', 'sync_stats_acute_illness');

// Cache IDs.
define('HEDLEY_STATS_SYNC_STATS_CACHE', 'sync_stats_general');
define('HEDLEY_STATS_SYNC_SESSION_ATTENDANCE', 'sync_session_attendance_stats');
define('HEDLEY_STATS_SYNC_CHILDREN_BENEFICIARIES', 'sync_children_beneficiaries_stats');
define('HEDLEY_STATS_SYNC_FAMILY_PLANNING', 'sync_family_planning_stats');
define('HEDLEY_STATS_SYNC_TOTAL_ENCOUNTERS', 'sync_total_encounters_stats');
define('HEDLEY_STATS_SYNC_CASE_MANAGEMENT', 'sync_case_management_stats');
define('HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA', 'sync_acute_illness_data');
define('HEDLEY_STATS_SYNC_PRENATAL_DATA', 'sync_prenatal_data');

// Cache methods.
define('HEDLEY_STATS_CACHE_GET', 'get');
define('HEDLEY_STATS_CACHE_SET', 'set');
define('HEDLEY_STATS_CACHE_CLEAR', 'clear');

/**
 * Implements hook_node_insert().
 */
function hedley_stats_node_insert($node) {
  hedley_stats_trigger_stats_recalculation($node);
}

/**
 * Implements hook_node_update().
 */
function hedley_stats_node_update($node) {
  hedley_stats_trigger_stats_recalculation($node);
}

/**
 * If needed, reset statistics cache and trigger recalculation.
 *
 * @param object $node
 *   The node that triggered the change.
 *
 * @throws \EntityMetadataWrapperException
 */
function hedley_stats_trigger_stats_recalculation($node) {
  $cache_type_for_recalculation = hedley_stats_requires_statistics_recalculation($node);

  if ($cache_type_for_recalculation === FALSE) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  if (!$wrapper->__isset('field_shards')) {
    // Can't resolve to which health centers content belongs.
    return;
  }

  $health_centers = $wrapper->field_shards->value(['identifier' => TRUE]);

  // Get health centers.
  if (empty($health_centers)) {
    return;
  }

  // Reset statistics cache of each health center, because
  // content affecting it's statistics has been added / changed.
  foreach ($health_centers as $health_center) {
    hedley_stats_clear_caches_for_health_center($health_center, $cache_type_for_recalculation);

    // Add an AQ item to re-calculate all the statistics offline.
    hedley_general_add_task_to_advanced_queue_by_id(HEDLEY_STATS_CALCULATE_STATS, $health_center, [
      'health_center_nid' => $health_center,
    ]);
  }
}

/**
 * Checks if entity requires statistics recalculation.
 *
 * @param object $node
 *   The entity.
 *
 * @return string|bool
 *   The type of cache to clear. False, if clearing is not required.
 */
function hedley_stats_requires_statistics_recalculation($node) {
  if (hedley_stats_requires_nutrition_statistics_recalculation($node->type)) {
    return HEDLEY_STATS_NUTRITION;
  }

  $wrapper = entity_metadata_wrapper('node', $node);

  if (hedley_stats_requires_prenatal_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_PRENATAL;
  }

  if (hedley_stats_requires_acute_illness_statistics_recalculation($wrapper)) {
    return HEDLEY_STATS_ACUTE_ILLNESS;
  }

  return FALSE;
}

/**
 * Checks if entity requires Nutrition statistics recalculation.
 *
 * @param string $bundle
 *   Entity bundle.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_nutrition_statistics_recalculation($bundle) {
  $triggering_types = array_merge(
    [
      HEDLEY_ACTIVITY_ATTENDANCE_CONTENT_TYPE,
      HEDLEY_ACTIVITY_FAMILY_PLANNING_CONTENT_TYPE,
      HEDLEY_ACTIVITY_NUTRITION_ENCOUNTER_CONTENT_TYPE,
    ],
    HEDLEY_ACTIVITY_HEIGHT_BUNDLES,
    HEDLEY_ACTIVITY_NUTRITION_BUNDLES,
    HEDLEY_ACTIVITY_MUAC_BUNDLES,
    HEDLEY_ACTIVITY_WEIGHT_BUNDLES
  );

  return in_array($bundle, $triggering_types);
}

/**
 * Checks if entity requires Prenatal statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_prenatal_statistics_recalculation($wrapper) {
  $triggering_types = [
    HEDLEY_ACTIVITY_PRENATAL_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_DANGER_SIGNS_CONTENT_TYPE,
  ];
  $bundle = $wrapper->getBundle();

  if (in_array($bundle, $triggering_types)) {
    return TRUE;
  }

  if ($bundle == HEDLEY_ACTIVITY_INDIVIDUAL_PARTICIPANT_CONTENT_TYPE) {
    $encounter_type = $wrapper->field_encounter_type->value();
    return $encounter_type == HEDLEY_STATS_PRENATAL_ENCOUNTER_TYPE;
  }

  return FALSE;
}

/**
 * Checks if entity requires Acute illness statistics recalculation.
 *
 * @param object $wrapper
 *   Entity metadata wrapper.
 *
 * @return bool
 *   True, if statistics recalculation is required.
 */
function hedley_stats_requires_acute_illness_statistics_recalculation($wrapper) {
  $triggering_types = [
    HEDLEY_ACTIVITY_ACUTE_ILLNESS_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_SEND_TO_HC_CONTENT_TYPE,
    HEDLEY_ACTIVITY_ACUTE_ILLNESS_VITALS_CONTENT_TYPE,
    HEDLEY_ACTIVITY_SYMPTOMS_GENERAL_CONTENT_TYPE,
    HEDLEY_ACTIVITY_ISOLATION_CONTENT_TYPE,
    HEDLEY_ACTIVITY_CALL_114_CONTENT_TYPE,
    HEDLEY_ACTIVITY_HC_CONTAC_CONTENT_TYPE,
  ];

  $bundle = $wrapper->getBundle();

  if (in_array($bundle, $triggering_types)) {
    return TRUE;
  }

  if ($bundle == HEDLEY_ACTIVITY_INDIVIDUAL_PARTICIPANT_CONTENT_TYPE) {
    $encounter_type = $wrapper->field_encounter_type->value();
    return $encounter_type == HEDLEY_STATS_ACUTE_ILLNESS_ENCOUNTER_TYPE;
  }

  return FALSE;
}

/**
 * Clears all statistics related caches for a health center.
 *
 * @param int $nid
 *   Health center node ID.
 * @param string $cache_type_for_recalculation
 *   Type of statistics cache for recalculation.
 *   Possible options: Nutrition, Prenatal and Acute illness.
 */
function hedley_stats_clear_caches_for_health_center($nid, $cache_type_for_recalculation) {
  switch ($cache_type_for_recalculation) {
    case HEDLEY_STATS_PRENATAL:
      hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_PRENATAL_DATA, $nid);
      return;

    case HEDLEY_STATS_ACUTE_ILLNESS:
      hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA, $nid);
      return;
  }

  // If we got this far, we need to clear Nutrition stats cache.
  $periods = [
    HEDLEY_STATS_PERIOD_THIS_MONTH,
    HEDLEY_STATS_PERIOD_LAST_MONTH,
    HEDLEY_STATS_PERIOD_TWO_MONTHS_AGO,
    HEDLEY_STATS_PERIOD_PAST_THREE_MONTHS,
    HEDLEY_STATS_PERIOD_ONE_YEAR,
    HEDLEY_STATS_PERIOD_LAST_YEAR,
  ];

  // Clear cache that doesn't have periods.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_TOTAL_ENCOUNTERS, $nid);
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_SESSION_ATTENDANCE, $nid);

  // Clear cache for all the periods.
  foreach ($periods as $period) {
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_FAMILY_PLANNING, $nid, $period);
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_CHILDREN_BENEFICIARIES, $nid, $period);
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_CLEAR, HEDLEY_STATS_SYNC_CASE_MANAGEMENT, $nid, $period);
  }
}

/**
 * Implements hook_advanced_queue_info().
 */
function hedley_stats_advanced_queue_info() {
  $items[HEDLEY_STATS_CALCULATE_STATS] = [
    'label' => t('Calculate the dashboard stats'),
    'worker callback' => 'hedley_stats_calculate_stats_worker',
    'groups' => [
      'hedley',
    ],
    // The number of seconds to retry after.
    'retry after' => 120,
    // The maximum number of attempts after a failure.
    'max attempts' => 3,
  ];

  return $items;
}

/**
 * Advanced queue worker; Calculate stats for a dashboards.
 *
 * @param object $queue_item
 *   The item object to process.
 *
 * @return array
 *   Array indicating if the process succeeded, or an array with
 *   "status" and "result" keys.
 */
function hedley_stats_calculate_stats_worker($queue_item) {
  if (!$health_center_id = $queue_item->data['health_center_nid']) {
    return [
      'status' => ADVANCEDQUEUE_STATUS_FAILURE,
      'result' => t('Does not have Health Center Node ID.'),
    ];
  }

  try {
    hedley_stats_calculate_stats_for_health_center($health_center_id);
  }
  catch (Exception $e) {
    return [
      'status' => ADVANCEDQUEUE_STATUS_FAILURE_RETRY,
      'result' => $e->getMessage(),
    ];
  }

  $params = [
    '@nid' => $health_center_id,
  ];
  return [
    'status' => ADVANCEDQUEUE_STATUS_SUCCESS,
    'result' => t('The statistics has been calculated for health center ID: @nid', $params),
  ];
}

/**
 * Get all the stats for each health center.
 *
 * We don't worry about caching here because each function has its own caching.
 *
 * @param int $health_center_id
 *   The health center node ID.
 * @param string $cached_hash
 *   Optional; If non empty value provided, we do not update cache hash.
 *
 * @return array
 *   The stats or error details if anything went wrong.
 */
function hedley_stats_calculate_stats_for_health_center($health_center_id, $cached_hash = '') {
  try {
    $wrapper = entity_metadata_wrapper('node', $health_center_id);

    // Get all clinics of type 'FBF' for the HC.
    $fbf_clinics = hedley_health_center_get_clinics_by_health_center($health_center_id, 'fbf');
    // Calculate statistics that are provided for FBF clinics only.
    $completed_program = $missed_sessions = [];
    if (!empty($fbf_clinics)) {
      list($completed_program, $missed_sessions) = hedley_stats_get_session_attendance_stats_by_health_center($health_center_id, $fbf_clinics);
    }

    $villages_with_residents = hedley_stats_get_villages_with_residents($health_center_id);
    $health_center_uuid = $wrapper->field_uuid->value();

    $stats = [
      'vid' => 1,
      'type' => 'statistics',
      // UUID of the health center.
      'uuid' => $health_center_uuid,
      'case_management' => hedley_stats_get_case_management($health_center_id),
      'children_beneficiaries' => hedley_stats_get_children_beneficiaries_stats_by_period($health_center_id),
      'completed_program' => $completed_program,
      'family_planning' => hedley_stats_get_family_planning_stats_by_period($health_center_id, HEDLEY_STATS_PERIOD_PAST_THREE_MONTHS),
      'missed_sessions' => $missed_sessions,
      'total_encounters' => hedley_stats_get_total_encounters($health_center_id, $villages_with_residents),
      'acute_illness_data' => hedley_stats_get_acute_illness_data($health_center_id),
      'prenatal_data' => hedley_stats_get_prenatal_data($health_center_id),
      'villages_with_residents' => $villages_with_residents,
    ];

    $now = time();
    // UTC date and time on which statistics were generated.
    $timestamp = date('d-m-Y, H:i', $now - date('Z'));
    $stats['timestamp'] = $timestamp;
    $stats['stats_cache_hash'] = empty($cached_hash) ? md5($now) : $cached_hash;

    // Store in cache only the hash. All statistics have their own cache.
    hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_STATS_CACHE, $health_center_id, NULL, $stats['stats_cache_hash']);

    return $stats;
  }
  catch (Exception $exception) {
    return [
      'status' => ADVANCEDQUEUE_STATUS_FAILURE_RETRY,
      'result' => $exception->getMessage(),
    ];
  }
}

/**
 * Returns a list of villages UUIDs with IDs of its residents.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of villages UUIDs with IDs of its residents.
 *
 * @throws \EntityMetadataWrapperException
 */
function hedley_stats_get_villages_with_residents($health_center_id) {
  $villages_ids = hedley_health_center_get_villages_by_health_center($health_center_id);

  $result = [];
  foreach ($villages_ids as $village_id) {
    $wrapper = entity_metadata_wrapper('node', $village_id);
    $village_uuid = $wrapper->field_uuid->value();
    $residents = hedley_chw_get_village_residents($village_id);
    $result[$village_uuid] = $residents;
  }

  return $result;
}

/**
 * Return acute illnesses data that is used to generate AI statistics.
 *
 * We get data of all encounters for illnesses that were active during
 * past 6 months.
 * We need to know when encounters were created, it's diagnosis, if fever was
 * recorded, and several measurements.
 * Also, we add patient ID, to be able to associate it with its village.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of AI encounters data.
 *
 * @throws \Exception
 */
function hedley_stats_get_acute_illness_data($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA, $health_center_id)) {
    return $cache_data;
  }

  // Pull all acute illness encounters during past 6 month.
  $query = hedley_stats_get_base_query($health_center_id, 'acute_illness_encounter', HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS);

  // Resolve all illnesses associated with those encounters.
  hedley_general_join_field_to_query($query, 'node', 'field_individual_participant');
  $query->groupBy('field_individual_participant.field_individual_participant_target_id');

  $result = $query
    ->execute()
    ->fetchAllAssoc('field_individual_participant');

  $individual_participants = array_keys($result);
  if (empty($individual_participants)) {
    return [];
  }

  // For each illness, pull the patient and outcome data.
  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant');
  $query->condition('node.nid', $individual_participants, 'IN');

  $fields_to_join = [
    'field_person',
    'field_outcome',
    'field_date_concluded',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }

  $result = hedley_stats_run_node_query_in_batches($query);

  $items = [];
  // Prepare illnesses data to be consumed by client side.
  foreach ($result as $row) {
    $items[$row->nid] = [
      'id' => $row->field_person,
      // Field for 'created' is added at hedley_stats_get_base_query().
      'created' => date_format(date_create($row->field_expected), 'Y-m-d'),
      // We use the 'end date' of expected fields here, because the
      // 'date concluded' field is not set when illness is resolved.
      // While we could do that for illness, 'date concluded' field was meant
      // to capture the date when pregnancy has ended - some date in past.
      'date_concluded' => !empty($row->field_expected_field_expected_value2) ? date_format(date_create($row->field_date_concluded), 'Y-m-d') : NULL,
      'outcome' => $row->field_outcome,
      'encounters' => [],
    ];
  }

  // Resolve encounters data.
  $query = hedley_stats_get_base_query($health_center_id, 'acute_illness_encounter');
  $fields_to_join = [
    'field_individual_participant',
    'field_sequence_number',
    'field_acute_illness_diagnosis',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }
  $query->condition('field_individual_participant.field_individual_participant_target_id', $individual_participants, 'IN');

  // Join with AI Encounter table, through which we can join measurements data.
  $query->leftJoin('field_data_field_acute_illness_encounter', 'ai_encounter', 'ai_encounter.field_acute_illness_encounter_target_id = node.nid');

  // Pull data of health center referrals.
  $query->leftJoin('field_data_field_send_to_hc', 'send_to_hc', 'send_to_hc.entity_id = ai_encounter.entity_id');
  $query->addField('send_to_hc', 'field_send_to_hc_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT send_to_hc.field_send_to_hc_value)", 'send_to_hc');

  // Pull data of recorded fever at symptoms.
  $query->leftJoin('field_data_field_fever_period', 'fever_period', 'fever_period.entity_id = ai_encounter.entity_id');
  $query->addField('fever_period', 'field_fever_period_value');
  $query->addExpression("GROUP_CONCAT(fever_period.field_fever_period_value)", 'fever_period');

  // Pull data of recorded fever at vitals.
  $query->leftJoin('field_data_field_body_temperature', 'body_temperature', 'body_temperature.entity_id = ai_encounter.entity_id');
  $query->addField('body_temperature', 'field_body_temperature_value');
  $query->addExpression("GROUP_CONCAT(body_temperature.field_body_temperature_value)", 'body_temperature');

  // Pull data of isolations - COVID suspect.
  $query->leftJoin('field_data_field_isolation', 'isolation', 'isolation.entity_id = ai_encounter.entity_id');
  $query->addField('isolation', 'field_isolation_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT isolation.field_isolation_value)", 'isolation');

  // Pull data of 114 calls - COVID suspect.
  $query->leftJoin('field_data_field_114_contact', '114_contact', '114_contact.entity_id = ai_encounter.entity_id');
  $query->addField('114_contact', 'field_114_contact_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT 114_contact.field_114_contact_value)", 'contact_114');

  // Pull data of 114 recommendations - COVID suspect.
  $query->leftJoin('field_data_field_114_recommendation', '114_recommendation', '114_recommendation.entity_id = ai_encounter.entity_id');
  $query->addField('114_recommendation', 'field_114_recommendation_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT 114_recommendation.field_114_recommendation_value)", 'recommendation_114');

  // Pull data of HC contact - COVID suspect.
  $query->leftJoin('field_data_field_hc_contact', 'hc_contact', 'hc_contact.entity_id = ai_encounter.entity_id');
  $query->addField('hc_contact', 'field_hc_contact_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT hc_contact.field_hc_contact_value)", 'contact_hc');

  // Pull data of HC recommendations - COVID suspect.
  $query->leftJoin('field_data_field_hc_recommendation', 'hc_recommendation', 'hc_recommendation.entity_id = ai_encounter.entity_id');
  $query->addField('hc_recommendation', 'field_hc_recommendation_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT hc_recommendation.field_hc_recommendation_value)", 'recommendation_hc');

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Populate data of the encounters.
  foreach ($result as $row) {
    $fever_by_signs = !empty($row->fever_period) && $row->fever_period > 0;
    $fever_by_vitals = !empty($row->body_temperature) && (float) $row->body_temperature >= 37.5;

    $items[$row->field_individual_participant]['encounters'][] = [
      // Field for 'created' is added at hedley_stats_get_base_query().
      'start_date' => date_format(date_create($row->field_scheduled_date), 'Y-m-d'),
      'sequence_number' => $row->field_sequence_number,
      'diagnosis' => $row->field_acute_illness_diagnosis,
      'fever' => $fever_by_signs || $fever_by_vitals,
      'send_to_hc' => empty($row->send_to_hc) ? [] : explode(',', $row->send_to_hc),
      'isolation' => empty($row->isolation) ? [] : explode(',', $row->isolation),
      'call_114' => empty($row->contact_114) ? [] : explode(',', $row->contact_114),
      'recommendation_114' => empty($row->recommendation_114) ? [] : explode(',', $row->recommendation_114),
      'contact_hc' => empty($row->contact_hc) ? [] : explode(',', $row->contact_hc),
      'recommendation_hc' => empty($row->recommendation_hc) ? [] : explode(',', $row->recommendation_hc),
    ];
  }

  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_ACUTE_ILLNESS_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Return pregnancies data that is used to generate ANC statistics.
 *
 * We pull data for pregnancies started during past 480 days.
 * We need to know when they were created, what was the expected delivery
 * date, and if exist, real delivery date and outcome.
 * Also, we add patient ID, to be able to associate it with its village.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of villages UUIDs with IDs of its residents.
 *
 * @throws \Exception
 */
function hedley_stats_get_prenatal_data($health_center_id) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_PRENATAL_DATA, $health_center_id)) {
    return $cache_data;
  }

  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant', HEDLEY_STATS_PERIOD_480_DAYS);

  $fields_to_join = [
    'field_person',
    'field_encounter_type',
    'field_expected_date_concluded',
    'field_date_concluded',
    'field_outcome',
    'field_outcome_location',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }

  // Get only participants of Antenatal type.
  $query->condition('field_encounter_type.field_encounter_type_value', HEDLEY_STATS_PRENATAL_ENCOUNTER_TYPE);

  $result = hedley_stats_run_node_query_in_batches($query);

  if (empty($result)) {
    return [];
  }

  $items = [];
  // Prepare data to be consumed by client side.
  foreach ($result as $row) {
    $items[$row->nid] = [
      'id' => $row->field_person,
      // Field for 'created' is added at hedley_stats_get_base_query().
      'created' => date_format(date_create($row->field_expected), 'Y-m-d'),
      'expected_date_concluded' => !empty($row->field_expected_date_concluded) ? date_format(date_create($row->field_expected_date_concluded), 'Y-m-d') : NULL,
      'date_concluded' => !empty($row->field_date_concluded) ? date_format(date_create($row->field_date_concluded), 'Y-m-d') : NULL,
      'outcome' => $row->field_outcome,
      'delivery_location' => $row->field_outcome_location,
      'encounters' => [],
    ];
  }

  $individual_participants = array_keys($items);

  $query = hedley_stats_get_base_query($health_center_id, 'prenatal_encounter');
  $fields_to_join = [
    'field_individual_participant',
  ];
  foreach ($fields_to_join as $field) {
    hedley_general_join_field_to_query($query, 'node', $field, FALSE);
  }
  $query->condition('field_individual_participant.field_individual_participant_target_id', $individual_participants, 'IN');

  // Join with Prenatal Encounter table, through which we can join
  // measurements data.
  $query->leftJoin('field_data_field_prenatal_encounter', 'prenatal_encounter', 'prenatal_encounter.field_prenatal_encounter_target_id = node.nid');

  // Pull data of danger signs that were recorded during encounter.
  $query->leftJoin('field_data_field_danger_signs', 'danger_signs', 'danger_signs.entity_id = prenatal_encounter.entity_id');
  $query->addField('danger_signs', 'field_danger_signs_value');
  $query->addExpression("GROUP_CONCAT(DISTINCT danger_signs.field_danger_signs_value)", 'danger_signs');

  $query->groupBy('node.nid');

  $result = hedley_stats_run_node_query_in_batches($query);

  foreach ($result as $row) {
    $items[$row->field_individual_participant]['encounters'][] = [
      // Field for 'created' is added at hedley_stats_get_base_query().
      'start_date' => date_format(date_create($row->field_scheduled_date), 'Y-m-d'),
      'danger_signs' => explode(',', $row->danger_signs),
    ];
  }

  $values = array_values($items);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_PRENATAL_DATA, $health_center_id, NULL, $values);

  return $values;
}

/**
 * Returns active participants for HC, during provided period.
 *
 * Data includes both groups and individual participants.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. By default, it is for one year.
 *
 * @return array
 *   Array with the participants details grouped by clinic type.
 *
 * @throws \Exception
 */
function hedley_stats_get_children_beneficiaries_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_CHILDREN_BENEFICIARIES, $health_center_id, $period)) {
    return $cache_data;
  }

  $items = hedley_stats_get_children_beneficiaries_group_stats($health_center_id, $period);
  $items['individual'] = hedley_stats_get_children_beneficiaries_individual_stats($health_center_id);

  // Store in cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_CHILDREN_BENEFICIARIES, $health_center_id, $period, $items);

  return $items;
}

/**
 * Returns active participants for HC (per clinic type), during provided period.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. By default it is for one year.
 *
 * @return array
 *   Array with the participants details grouped by clinic type.
 *
 * @throws \Exception
 */
function hedley_stats_get_children_beneficiaries_group_stats($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  $query = hedley_stats_get_base_query($health_center_id, 'pmtct_participant');

  $field_names = [
    'field_person',
    'field_adult',
    'field_clinic',
  ];

  foreach ($field_names as $field_name) {
    hedley_general_join_field_to_query($query, 'node', $field_name);
  }

  hedley_general_join_field_to_query($query, 'node', 'field_group_type', TRUE, 'field_clinic.field_clinic_target_id');

  $date = hedley_stats_get_period($period);
  // We want to get all participants that graduate within, or after
  // defined period.
  $query->condition('field_expected.field_expected_value2', $date['start'], '>');

  $result = hedley_stats_run_node_query_in_batches($query);

  $items = [];
  foreach (hedley_stats_get_all_clinic_types() as $clinic_type) {
    $items[$clinic_type] = [];
  }

  foreach ($result as $row) {
    $clinic_type = $row->field_group_type;
    $child_wrapper = entity_metadata_wrapper('node', $row->field_person);
    $birth_date = $child_wrapper->field_birth_date->value();

    if (empty($birth_date)) {
      // Child got no birthdate set. We can't process
      // its data on client, so we skip it.
      continue;
    }

    $adult_wrapper = entity_metadata_wrapper('node', $row->field_adult);

    $items[$clinic_type][] = [
      'created' => hedley_stats_convert_timestamp_to_nominal($row->created),
      'id' => $child_wrapper->getIdentifier(),
      'name' => $child_wrapper->label(),
      'birth_date' => hedley_stats_convert_timestamp_to_nominal($birth_date),
      'gender' => $child_wrapper->field_gender->value(),
      'mother_name' => $adult_wrapper->label(),
      'phone_number' => $adult_wrapper->field_phone_number->value(),
      'graduation_date' => date_format(date_create($row->field_expected_field_expected_value2), 'Y-m-d'),
    ];
  }

  return $items;
}

/**
 * Returns active nutrition participants for HC.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 *
 * @return array
 *   Array with the participants details.
 *
 * @throws \Exception
 */
function hedley_stats_get_children_beneficiaries_individual_stats($health_center_id) {
  $query = hedley_stats_get_base_query($health_center_id, 'individual_participant');

  $field_names = [
    'field_person',
    'field_encounter_type',
  ];

  foreach ($field_names as $field_name) {
    hedley_general_join_field_to_query($query, 'node', $field_name);
  }

  $query->condition('field_encounter_type.field_encounter_type_value', 'nutrition');

  $result = hedley_stats_run_node_query_in_batches($query);

  $items = [];
  foreach ($result as $row) {
    $child_wrapper = entity_metadata_wrapper('node', $row->field_person);
    $birth_date = $child_wrapper->field_birth_date->value();

    if (empty($birth_date)) {
      // Child got no birthdate set. We can't process
      // its data on client, so we skip it.
      continue;
    }

    // Child graduates at age of 13.
    $graduation_date = strtotime('+13 years', $birth_date);

    $items[] = [
      'created' => hedley_stats_convert_timestamp_to_nominal($row->created),
      'id' => $child_wrapper->getIdentifier(),
      'name' => $child_wrapper->label(),
      'birth_date' => hedley_stats_convert_timestamp_to_nominal($birth_date),
      'gender' => $child_wrapper->field_gender->value(),
      'graduation_date' => hedley_stats_convert_timestamp_to_nominal($graduation_date),
      // No need to provide mother details, because we do not present
      // it anywhere, when it comes to individual participant data.
      'mother_name' => '',
      'phone_number' => '',
    ];
  }

  return $items;
}

/**
 * Return family planning related states.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to calculate. Be default it is for one year, as on the client
 *   side we could filter out items, if requested to show smaller periods of
 *   time.
 *
 * @return array
 *   Array with the result.
 *
 * @throws \Exception
 */
function hedley_stats_get_family_planning_stats_by_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_FAMILY_PLANNING, $health_center_id, $period)) {
    return $cache_data;
  }

  $query = hedley_stats_get_base_query($health_center_id, 'family_planning', $period);

  // Join `Signs` field (e.g. Pill, Condoms, etc').
  hedley_general_join_field_to_query($query, 'node', 'field_family_planning_signs');

  // Get the group type.
  hedley_general_join_field_to_query($query, 'node', 'field_session');
  hedley_general_join_field_to_query($query, 'node', 'field_clinic', TRUE, "field_session.field_session_target_id");
  hedley_general_join_field_to_query($query, 'node', 'field_group_type', TRUE, "field_clinic.field_clinic_target_id");
  // Only FBF groups.
  $query->condition('field_group_type.field_group_type_value', 'fbf');

  $query->groupBy('node.nid');
  $query->addExpression('GROUP_CONCAT(field_family_planning_signs.field_family_planning_signs_value)', 'signs');

  $result = hedley_stats_run_node_query_in_batches($query);

  // Prepare data to be consumed by client side.
  foreach ($result as &$row) {
    $row->created = hedley_stats_convert_timestamp_to_nominal($row->created);
    $row->signs = explode(',', $row->signs);

    // Remove unused data, to save bandwidth.
    unset($row->nid);
    unset($row->type);
    unset($row->field_session);
    unset($row->field_clinic);
    unset($row->field_group_type);
    unset($row->field_shards);
    unset($row->field_family_planning_signs);
  }

  // Set the cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_FAMILY_PLANNING, $health_center_id, $period, array_values($result));

  return array_values($result);
}

/**
 * Return Session attendance related states by health center.
 *
 * The period of this statistic is hardcoded for the last three months.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param array $fbf_clinics
 *   A list of FBF clinics IDs that belong to health center.
 *
 * @return array
 *   Array with the result.
 *
 * @throws \Exception
 */
function hedley_stats_get_session_attendance_stats_by_health_center($health_center_id, array $fbf_clinics) {
  if (empty($fbf_clinics)) {
    // No clinics found.
    return [];
  }

  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_SESSION_ATTENDANCE, $health_center_id)) {
    return $cache_data;
  }

  $periods = [
    HEDLEY_STATS_PERIOD_TWO_MONTHS_AGO,
    HEDLEY_STATS_PERIOD_LAST_MONTH,
    HEDLEY_STATS_PERIOD_THIS_MONTH,
  ];

  $completed_program = [];
  $missed_session = [];
  $measurements_types = array_keys(heldey_stats_get_nutrition_measurements_mapping_for_group_encounter());
  // Add photo the content types to make sure the person also has a photo.
  $measurements_types[] = 'photo';

  // Loop through the clinics and get sessions for each clinic and from there
  // get expected people for each clinic.
  foreach ($fbf_clinics as $clinic_id) {
    // Get PMTCT participants by clinic and session dates
    // (all expected people).
    $pmtct_by_clinic = hedley_stats_get_pmtct_participants_by_clinic($clinic_id, 5000);
    if (empty($pmtct_by_clinic)) {
      // No participants were found.
      continue;
    }

    foreach ($pmtct_by_clinic as $pmtct_id) {
      $pmtct_wrapper = entity_metadata_wrapper('node', $pmtct_id);
      $child_id = $pmtct_wrapper->field_person->getIdentifier();
      $child_wrapper = $pmtct_wrapper->field_person;
      $mother_wrapper = $pmtct_wrapper->field_adult;

      if (empty($child_wrapper) || empty($mother_wrapper)) {
        continue;
      }

      $pmtct_join_date = $pmtct_wrapper->created->raw();
      $pmtct_schedule = $pmtct_wrapper->field_expected->value();
      $pmtct_graduate_date = strtotime($pmtct_schedule['value2']);

      $expected_person = [
        'name' => $child_wrapper->label(),
        'gender' => $child_wrapper->field_gender->value(),
        'birth_date' => hedley_stats_convert_timestamp_to_nominal($child_wrapper->field_birth_date->value()),
        'mother_name' => $mother_wrapper->label(),
        'phone_number' => $mother_wrapper->field_phone_number->value(),
        'expected_date' => NULL,
      ];

      foreach ($periods as $period_name) {
        $sessions = hedley_stats_get_clinic_sessions_by_period($clinic_id, $period_name, 1);
        if (empty($sessions)) {
          continue;
        }

        // We know there's only one session, as we have set range to 1.
        $session_id = reset($sessions);
        $session_wrapper = entity_metadata_wrapper('node', $session_id);
        $session_schedule = $session_wrapper->field_scheduled_date->value();
        $session_start_date = strtotime($session_schedule['value']);

        // Participant has graduated before the session has begun.
        if ($pmtct_graduate_date < $session_start_date) {
          continue;
        }

        if (!empty($session_schedule['value2'])) {
          // Since start and end dates for session are always set to 00:00,
          // we add one day to session end date.
          // Otherwise, if session was started and ended at same day, it's
          // as if session was stated and ended on exact same time.
          $session_end_date = strtotime($session_schedule['value2']) + 24 * 60 * 60;
          // Participant has joined after the session has ended.
          if ($pmtct_join_date > $session_end_date) {
            continue;
          }
        }

        $period = hedley_stats_get_period($period_name);

        // Check if patient has missed the session. This can happen
        // only if session has started before patient has graduated the program.
        if ($session_start_date < $pmtct_graduate_date) {
          // Check if the person (patient) has any measurements.
          $measurements = hedley_activity_get_person_measurements_by_period($child_id, $measurements_types, $period, 1);
          if (empty($measurements)) {
            // This person missed the session because they don't have any
            // measurements found for that session on this date so we add it to
            // the list of dates, to be able to filter it in the frontend.
            $expected_person['expected_date'] = hedley_stats_convert_timestamp_to_nominal($session_start_date);
            $missed_session[] = $expected_person;
          }
        }

        if ($pmtct_graduate_date >= $period['start'] && $pmtct_graduate_date <= $period['end']) {
          $expected_person['expected_date'] = hedley_stats_convert_timestamp_to_nominal($session_start_date);
          $completed_program[] = $expected_person;
        }
      }
    }
  }

  // Set the cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_SESSION_ATTENDANCE, $health_center_id, NULL, [
    array_values($completed_program),
    array_values($missed_session),
  ]);

  return [array_values($completed_program), array_values($missed_session)];
}

/**
 * Returns "Total Encounters".
 *
 * Includes total number of encounters for each type of clinic, and
 * total number of individual nutrition encounters.
 * Results are provided for 'global' totals, and broken down by villages.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 *
 * @return array
 *   AN array with total encounters.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_encounters($health_center_id, $villages_with_residents) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_TOTAL_ENCOUNTERS, $health_center_id)) {
    return $cache_data;
  }

  $result['global'] = hedley_stats_get_total_encounters_for_residents($health_center_id);

  $result['villages'] = [];
  foreach ($villages_with_residents as $village_uuid => $residents_ids) {
    $result['villages'][$village_uuid] = hedley_stats_get_total_encounters_for_residents($health_center_id, $residents_ids);
  }

  // Set the cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_TOTAL_ENCOUNTERS, $health_center_id, NULL, $result);

  return $result;
}

/**
 * Returns "Total Encounters" for specified patients.
 *
 * If patients list is not provided (defaults to False),
 * overall totals are calculated.
 *
 * Includes total number of encounters for each type of clinic, and
 * total number of individual nutrition encounters.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param bool|array $patients_ids
 *   Optional; a list of patients IDs, for which totals are counted.
 *
 * @return array
 *   A list with total encounters count.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_encounters_for_residents($health_center_id, $patients_ids = FALSE) {
  $clinic_types = hedley_stats_get_all_clinic_types();

  $result = [];
  foreach ($clinic_types as $clinic_type) {
    $result[$clinic_type] = hedley_stats_get_total_encounters_by_clinic_type($health_center_id, $clinic_type, $patients_ids);
  }

  $result['individual'] = hedley_stats_get_total_nutrition_encounters($health_center_id, $patients_ids);

  return $result;
}

/**
 * Return "Total Encounters" for specified type of clinic, for past 2 years.
 *
 * If patients list is not provided (defaults to False),
 * overall totals are calculated.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $clinic_type
 *   The type of the clinic.
 * @param bool|array $patients_ids
 *   Optional; a list of patients IDs, for which totals are counted.
 *
 * @return array
 *   A list with total encounters count.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_encounters_by_clinic_type($health_center_id, $clinic_type, $patients_ids = FALSE) {
  $result = [
    'last_year' => 0,
    'this_year' => 0,
  ];

  if (is_array($patients_ids) && empty($patients_ids)) {
    // Patients list is empty. Return empty result.
    return $result;
  }

  $queries['last_year'] = hedley_stats_get_base_query($health_center_id, 'attendance', HEDLEY_STATS_PERIOD_LAST_YEAR);
  $queries['this_year'] = hedley_stats_get_base_query($health_center_id, 'attendance', HEDLEY_STATS_PERIOD_ONE_YEAR);

  foreach ($queries as $key => $query) {
    // Get the group type.
    hedley_general_join_field_to_query($query, 'node', 'field_session');
    hedley_general_join_field_to_query($query, 'node', 'field_attended');
    hedley_general_join_field_to_query($query, 'node', 'field_clinic', TRUE, 'field_session.field_session_target_id');
    hedley_general_join_field_to_query($query, 'node', 'field_group_type', TRUE, 'field_clinic.field_clinic_target_id');

    // Only participants who actually attended the sessions.
    $query->condition('field_attended.field_attended_value', TRUE);

    // Only of specific clinic type.
    $query->condition('field_group_type.field_group_type_value', $clinic_type);

    // If patients list specified values.
    if (is_array($patients_ids)) {
      hedley_general_join_field_to_query($query, 'node', 'field_person');
      $query->condition('field_person.field_person_target_id', $patients_ids, 'IN');
    }

    $result[$key] = $query
      ->execute()
      ->rowCount();
  }

  return $result;
}

/**
 * Return "Total Encounters" for individual nutrition encounters, per period.
 *
 * If patients list is not provided (defaults to False),
 * overall totals are calculated.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param bool|array $patients_ids
 *   Optional; a list of patients IDs, for which totals are counted.
 *
 * @return array
 *   A list with total encounters count.
 *
 * @throws \Exception
 */
function hedley_stats_get_total_nutrition_encounters($health_center_id, $patients_ids = FALSE) {
  $result = [
    'last_year' => 0,
    'this_year' => 0,
  ];

  if (is_array($patients_ids) && empty($patients_ids)) {
    // Patients list is empty. Return empty result.
    return $result;
  }

  $queries['last_year'] = hedley_stats_get_base_query($health_center_id, 'nutrition_encounter', HEDLEY_STATS_PERIOD_LAST_YEAR);
  $queries['this_year'] = hedley_stats_get_base_query($health_center_id, 'nutrition_encounter', HEDLEY_STATS_PERIOD_ONE_YEAR);

  foreach ($queries as $key => $query) {
    // If patients list specified values.
    if (is_array($patients_ids)) {
      hedley_general_join_field_to_query($query, 'node', 'field_individual_participant');
      hedley_general_join_field_to_query($query, 'node', 'field_person', TRUE, 'field_individual_participant.field_individual_participant_target_id');

      $query->condition('field_person.field_person_target_id', $patients_ids, 'IN');
    }

    $result[$key] = $query
      ->execute()
      ->rowCount();
  }

  return $result;
}

/**
 * Get the "Case Management" data, for current and previous years.
 *
 * The data is for the "Case Management" table which is divided into 4 types:
 * Stunting, Underweight, Wasting and MUAC.
 *
 * @param int $health_center_id
 *   The health center node ID.
 *
 * @return array
 *   List of nutrition data for person, for current and previous years.
 *
 * @throws \Exception
 */
function hedley_stats_get_case_management($health_center_id) {
  return [
    'this_year' => hedley_stats_get_case_management_for_period($health_center_id),
    'last_year' => hedley_stats_get_case_management_for_period($health_center_id, HEDLEY_STATS_PERIOD_LAST_YEAR),
  ];
}

/**
 * Get the "Case Management" data, within given period.
 *
 * The data is for the "Case Management" table which is divided into 4 types:
 * Stunting, Underweight, Wasting and MUAC.
 *
 * @param int $health_center_id
 *   The health center node ID.
 * @param string $period
 *   Optional; The period for the data, defaults to one year.
 *
 * @return array
 *   List of nutrition data for person, within given period.
 *
 * @throws \Exception
 */
function hedley_stats_get_case_management_for_period($health_center_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR) {
  // Return the cache if exists.
  if ($cache_data = hedley_stats_handle_cache(HEDLEY_STATS_CACHE_GET, HEDLEY_STATS_SYNC_CASE_MANAGEMENT, $health_center_id, $period)) {
    return $cache_data;
  }

  $extend = ($period == HEDLEY_STATS_PERIOD_ONE_YEAR);
  $total_month = $extend ? 13 : 12;

  // Set the data for each month.
  $data_per_month = [];
  for ($i = 1; $i <= $total_month; $i++) {
    // If not changed bellow, NULL will indicate to client that
    // there was no data for current month.
    $data_per_month[$i] = NULL;
  }

  // Set the nutrition for each person.
  $nutrition_per_person = [
    'stunting' => $data_per_month,
    'underweight' => $data_per_month,
    'wasting' => $data_per_month,
    'muac' => $data_per_month,
    'nutrition_signs' => $data_per_month,
  ];

  $data = hedley_stats_get_nutrition_measurements_grouped_by_person($health_center_id, $period, $extend);
  $result = [];

  foreach ($data as $program_type => $people_data) {
    if (empty($people_data)) {
      $result[$program_type] = [];
      continue;
    }

    $people = [];
    foreach ($people_data as $id => $person) {
      $wrapper = entity_metadata_wrapper('node', $id);
      $people[$id] = [
        'id' => $id,
        'name' => trim($wrapper->label()),
        'birth_date' => hedley_stats_convert_timestamp_to_nominal($wrapper->field_birth_date->value()),
        'gender' => $wrapper->field_gender->value(),
        'nutrition' => $nutrition_per_person,
      ];

      foreach ($person as $type => $measurement) {
        $one_day = 24 * 60 * 60;
        foreach ($measurement as $date => $values) {
          // Get the date of the measurement in order to distribute them by
          // months.
          $date_as_timestamp = strtotime($date);
          $month = date('n', $date_as_timestamp);

          // When extend data flag is raised, meaning that we want
          // to add one more month for current year, and if
          // measurement was taken over a year ago,
          // we set it at month 13. It's used to calculate the changes
          // that took place at first month of current year period.
          if ($extend && $date_as_timestamp < strtotime("last day of -1 year") + $one_day) {
            $month = '13';
          };

          foreach ($values as $field_name => $value) {
            // Some z-scores will not be present, when not all measurements
            // are taken for child. For example, without height, there's no
            // z-score length and z-score bmi.
            // In such cases, there's nothing to calculate, and we move
            // on to next measurement.
            if (empty($value)) {
              continue;
            }

            if (in_array($type, ['nutrition', 'nutrition_nutrition'])) {
              if ($value != 'none') {
                // This indicates to front-end of a 'Severe nutrition' case.
                $people[$id]['nutrition']['nutrition_signs'][$month] = -3;
              }
              else {
                // This indicates to front-end of a 'Good nutrition' case.
                $people[$id]['nutrition']['nutrition_signs'][$month] = 3;
              }

              // Move on to next measurement.
              continue;
            }

            // Round up the value, the class will indicate the zscore level.
            $formatted_value = round($value, 2);

            switch ($type) {
              case 'height':
              case 'nutrition_height':
                // The value to display in the table.
                $people[$id]['nutrition']['stunting'][$month] = $formatted_value;
                break;

              case 'weight':
              case 'nutrition_weight':
                if ($field_name == 'field_zscore_age') {
                  // The value to display in the table.
                  $people[$id]['nutrition']['underweight'][$month] = $formatted_value;
                }
                elseif ($field_name == 'field_zscore_length') {
                  // The value to display in the table.
                  $people[$id]['nutrition']['wasting'][$month] = $formatted_value;
                }
                break;

              case 'muac':
              case 'nutrition_muac':
                // The value to display in the table.
                $people[$id]['nutrition']['muac'][$month] = $formatted_value;
                break;
            }
          }
        }
      }
    }

    $result[$program_type] = array_values($people);
  }

  // Set the cache.
  hedley_stats_handle_cache(HEDLEY_STATS_CACHE_SET, HEDLEY_STATS_SYNC_CASE_MANAGEMENT, $health_center_id, $period, $result);

  return $result;
}

/**
 * Returns a list with all available types of clinics.
 *
 * @return array
 *   A list with all available types of clinics.
 */
function hedley_stats_get_all_clinic_types() {
  return [
    HEDLEY_PERSON_CLINIC_TYPE_FBF,
    HEDLEY_PERSON_CLINIC_TYPE_PMTCT,
    HEDLEY_PERSON_CLINIC_TYPE_SORWATHE,
    HEDLEY_PERSON_CLINIC_TYPE_ACHI,
    HEDLEY_PERSON_CLINIC_TYPE_CHW,
  ];
}

/**
 * Returns all nutrition measurements for a health center.
 *
 * Results are for certain period, and grouped by person.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to query.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return array
 *   Nutrition measurements for a health center, within given period.
 *
 * @throws \Exception
 */
function hedley_stats_get_nutrition_measurements_grouped_by_person($health_center_id, $period, $extend = FALSE) {
  $clinic_types = hedley_stats_get_all_clinic_types();

  $result = [];
  foreach ($clinic_types as $clinic_type) {
    $result[$clinic_type] = hedley_stats_get_nutrition_measurements_for_clinic_type_grouped_by_person($health_center_id, $clinic_type, $period, $extend);
  }

  $result['individual'] = hedley_stats_get_nutrition_measurements_for_individual_encounters_grouped_by_person($health_center_id, $period, $extend);

  return $result;
}

/**
 * Gets all nutrition measurements by clinic type, for a health center.
 *
 * Results are for certain period, and grouped by person.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $clinic_type
 *   The type of the clinic.
 * @param string $period
 *   The period to query.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return array
 *   Nutrition measurements by clinic type, for a health center,
 *   within given period.
 *
 * @throws \Exception
 */
function hedley_stats_get_nutrition_measurements_for_clinic_type_grouped_by_person($health_center_id, $clinic_type, $period, $extend = FALSE) {
  // All group measurements with nutrition fields mapping.
  $node_types = heldey_stats_get_nutrition_measurements_mapping_for_group_encounter();

  $query = hedley_stats_get_base_query($health_center_id, array_keys($node_types), $period, $extend);

  // Get the group type.
  hedley_general_join_field_to_query($query, 'node', 'field_session');
  hedley_general_join_field_to_query($query, 'node', 'field_clinic', TRUE, 'field_session.field_session_target_id');
  hedley_general_join_field_to_query($query, 'node', 'field_group_type', TRUE, 'field_clinic.field_clinic_target_id');

  // Get the person.
  hedley_general_join_field_to_query($query, 'node', 'field_person');

  // Get the nutrition signs for this person.
  hedley_general_join_field_to_query($query, 'node', 'field_nutrition_signs', FALSE);

  // Get all other measurements for this person.
  hedley_general_join_field_to_query($query, 'node', 'field_zscore_age', FALSE);
  hedley_general_join_field_to_query($query, 'node', 'field_muac', FALSE);
  hedley_general_join_field_to_query($query, 'node', 'field_zscore_length', FALSE);

  // Filter by clinic type.
  $query->condition('field_group_type.field_group_type_value', $clinic_type);

  $result = hedley_stats_run_node_query_in_batches($query);

  // Group measurements by person.
  $people = [];
  foreach ($result as $measurement) {
    // Get fields for current node type.
    $measurement_fields = $node_types[$measurement->type];

    foreach ($measurement_fields as $measurement_field) {
      $people[$measurement->field_person][$measurement->type][$measurement->field_date_measured][$measurement_field] = $measurement->{$measurement_field};
    }
  }

  return $people;
}

/**
 * Gets all nutrition measurements at individual encounter, for a health center.
 *
 * Results are for certain period, and grouped by person.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string $period
 *   The period to query.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return array
 *   Nutrition measurements at individual encounters, for a health center,
 *   within given per period.
 *
 * @throws \Exception
 */
function hedley_stats_get_nutrition_measurements_for_individual_encounters_grouped_by_person($health_center_id, $period, $extend = FALSE) {
  // All individual encounter measurements with nutrition fields mapping.
  $node_types = heldey_stats_get_nutrition_measurements_mapping_for_individual_encounter();

  $query = hedley_stats_get_base_query($health_center_id, array_keys($node_types), $period, $extend);

  // Get the person.
  hedley_general_join_field_to_query($query, 'node', 'field_person');

  // Get the nutrition signs for this person.
  hedley_general_join_field_to_query($query, 'node', 'field_nutrition_signs', FALSE);

  // Get all other measurements for this person.
  hedley_general_join_field_to_query($query, 'node', 'field_zscore_age', FALSE);
  hedley_general_join_field_to_query($query, 'node', 'field_muac', FALSE);
  hedley_general_join_field_to_query($query, 'node', 'field_zscore_length', FALSE);

  $result = hedley_stats_run_node_query_in_batches($query);

  // Group measurements by person.
  $people = [];
  foreach ($result as $measurement) {
    // Get fields for current node type.
    $measurement_fields = $node_types[$measurement->type];

    foreach ($measurement_fields as $measurement_field) {
      $people[$measurement->field_person][$measurement->type][$measurement->field_date_measured][$measurement_field] = $measurement->{$measurement_field};
    }
  }

  return $people;
}

/**
 * Executes query in batches, with constant number of results at each batch.
 *
 * Complex query can produce, 50K, 100K or even more rows of result.
 * This size may cause 'out of memory' exception.
 * To prevent this, we run these queries in batches. There will be more hits
 * at the DB, but we don't end up running out of memory.
 *
 * @param SelectQuery $query
 *   The query to execute.
 * @param int $batch
 *   Number of results we want to receive at each batch. Defaults to 5000.
 *
 * @return array
 *   Query accumulated result.
 */
function hedley_stats_run_node_query_in_batches(SelectQuery $query, $batch = 5000) {
  $query->orderBy('node.nid');

  $result = [];
  $nid = 0;

  while (TRUE) {
    $batch_query = clone $query;
    // We want to get results for nodes we did not process before.
    $batch_query->condition('nid', $nid, '>');

    $batch_result = $batch_query
      ->range(0, $batch)
      ->execute()
      ->fetchAllAssoc('nid');

    if (empty($batch_result)) {
      // There's no more results, so we know that no more
      // batches are needed, and we can exit the WHILE loop.
      break;
    }

    // Accumulate result.
    $result = array_merge($result, $batch_result);
    // Locate the latest node processed, for the next batch.
    $nid = end($batch_result)->nid;
  }

  return $result;
}

/**
 * Base query for stats - pulls content in given period for Health Center.
 *
 * @param int $health_center_id
 *   The Health center node ID.
 * @param string|array $node_type
 *   Either single content type or an array of types.
 * @param string $period
 *   Optional; The period during which content was taken.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return \SelectQuery
 *   THe query object.
 *
 * @throws \Exception
 */
function hedley_stats_get_base_query($health_center_id, $node_type, $period = FALSE, $extend = FALSE) {
  $query = db_select('node', 'node');
  $query->fields('node', ['nid', 'type', 'created']);

  $encounter_types = [
    'acute_illness_encounter',
    'nutrition_encounter',
    'prenatal_encounter',
  ];
  $participant_types = [
    'individual_participant',
    'pmtct_participant',
  ];

  // If we're dealing with encounter, creation date is
  // resolved using 'field_scheduled_date'.
  if (in_array($node_type, $encounter_types)) {
    $date_field = 'field_scheduled_date';
    hedley_general_join_field_to_query($query, 'node', $date_field, FALSE, NULL, NULL, TRUE);
  }
  // If we're dealing with individual participant, creation date is
  // resolved using 'field_expected'.
  elseif (in_array($node_type, $participant_types)) {
    $date_field = 'field_expected';
    hedley_general_join_field_to_query($query, 'node', $date_field, FALSE, NULL, NULL, TRUE);
  }
  // Dealing with measurements.
  // For all measurement nodes, creation date is
  // resolved using 'field_date_measured'.
  else {
    $date_field = 'field_date_measured';
    hedley_general_join_field_to_query($query, 'node', $date_field);
  }

  // All nodes have the Health center info under `field_shards`.
  $health_center_field = 'field_shards';
  // Filter by health center.
  hedley_general_join_field_to_query($query, 'node', $health_center_field);
  $health_center_field_name = $health_center_field . '.' . $health_center_field . '_target_id';

  $query->condition($health_center_field_name, $health_center_id);

  if ($period) {
    $date_field_name = $date_field . '.' . $date_field . '_value';

    $date = hedley_stats_get_period($period, $extend);
    $query->condition($date_field_name, [
      $date['start'],
      $date['end'],
    ], 'BETWEEN');
  }

  $node_type_operator = is_array($node_type) ? 'IN' : '=';
  $query
    ->condition('type', $node_type, $node_type_operator)
    ->condition('status', NODE_PUBLISHED);

  return $query;
}

/**
 * Get the start date based on period of time.
 *
 * @param string $period
 *   The period to calculate.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return false|array
 *   The date period.
 */
function hedley_stats_get_period($period, $extend = FALSE) {
  $range = hedley_stats_get_range_for_period($period, $extend);

  $db_date_field_format = 'Y-m-d 00:00:00';
  $date = [
    'start' => date($db_date_field_format, $range['start']),
    'end' => date($db_date_field_format, $range['end']),
  ];

  return $date;
}

/**
 * Returns the start and the end of the period as timestamps.
 *
 * @param string $period
 *   The name of the period.
 * @param bool $extend
 *   Optional; If True, data goes back one more month for 'one year' period.
 *
 * @return array
 *   The start and the end of the period timestamps.
 */
function hedley_stats_get_range_for_period($period, $extend = FALSE) {
  $now = time();
  $one_day = 24 * 3600;

  switch ($period) {
    case HEDLEY_STATS_PERIOD_THIS_MONTH:
      return [
        'start' => strtotime("first day of this month"),
        'end' => $now + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_LAST_MONTH:
      return [
        'start' => strtotime("first day of previous month"),
        'end' => strtotime("last day of previous month") + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_TWO_MONTHS_AGO:
      return [
        'start' => strtotime("first day of -2 months"),
        'end' => strtotime("last day of -2 months") + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_PAST_THREE_MONTHS:
      return [
        'start' => strtotime("first day of -2 months"),
        'end' => $now + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_ONE_YEAR:
      $start = strtotime("last day of -1 year") + $one_day;
      if ($extend) {
        $current_month = date('n');
        $current_year = date('Y');
        $start = $start - $one_day * hedley_stats_calculate_days_in_month($current_year - 1, $current_month);
      }

      return [
        'start' => $start,
        'end' => $now + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_LAST_YEAR:
      return [
        'start' => strtotime("last day of -2 years") + $one_day,
        'end' => strtotime("last day of -1 year") + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_480_DAYS:
      return [
        'start' => strtotime("-480 days"),
        'end' => $now + $one_day,
      ];

    case HEDLEY_STATS_PERIOD_PAST_SIX_MONTHS:
      return [
        'start' => strtotime("first day of -5 months"),
        'end' => $now + $one_day,
      ];

  }
}

/**
 * Helper function; Convert Unix timestamp to YYYYMMDD.
 *
 * @param int $timestamp
 *   The Unix timestamp.
 *
 * @return false|string
 *   The converted timestamp.
 */
function hedley_stats_convert_timestamp_to_nominal($timestamp) {
  return date('Y-m-d', $timestamp);
}

/**
 * Measurements types with the z-score fields mapped at group encounter.
 *
 * @return array
 *   The measurements content types with mapping.
 */
function heldey_stats_get_nutrition_measurements_mapping_for_group_encounter() {
  return [
    'height' => [
      'field_zscore_age',
    ],
    'nutrition' => [
      'field_nutrition_signs',
    ],
    'muac' => [
      'field_muac',
    ],
    'weight' => [
      'field_zscore_age',
      'field_zscore_length',
    ],
  ];
}

/**
 * Measurements types with the z-score fields mapped at individual encounter.
 *
 * @return array
 *   The measurements content types with mapping.
 */
function heldey_stats_get_nutrition_measurements_mapping_for_individual_encounter() {
  return [
    'nutrition_height' => [
      'field_zscore_age',
    ],
    'nutrition_nutrition' => [
      'field_nutrition_signs',
    ],
    'nutrition_muac' => [
      'field_muac',
    ],
    'nutrition_weight' => [
      'field_zscore_age',
      'field_zscore_length',
    ],
  ];
}

/**
 * Get PMTCT participants by clinic.
 *
 * @param int $clinic_id
 *   The clinic node ID.
 * @param int $range
 *   The queries' range.
 *
 * @return array
 *   Node IDs if they exist or empty array if no nodes exist.
 */
function hedley_stats_get_pmtct_participants_by_clinic($clinic_id, $range = 100) {

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'pmtct_participant')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_clinic', 'target_id', $clinic_id)
    ->range(0, $range);

  $result = $query->execute();

  return !empty($result['node']) ? array_keys($result['node']) : [];
}

/**
 * Get clinic's sessions by period.
 *
 * @param int $clinic_id
 *   The clinic node ID.
 * @param string $period
 *   The wanted period.
 * @param int $range
 *   The queries' range.
 *
 * @return array
 *   Node IDs if they exist or empty array if no nodes exist.
 */
function hedley_stats_get_clinic_sessions_by_period($clinic_id, $period = HEDLEY_STATS_PERIOD_ONE_YEAR, $range = 100) {
  $dates = hedley_stats_get_period($period);

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'session')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_clinic', 'target_id', $clinic_id)
    // Meaning that we are still expecting those participants.
    ->fieldCondition('field_scheduled_date', 'value', $dates['start'], '>=')
    ->fieldCondition('field_scheduled_date', 'value', $dates['end'], '<=')
    ->propertyOrderBy('nid')
    ->range(0, $range);

  $result = $query->execute();

  return !empty($result['node']) ? array_keys($result['node']) : [];
}

/**
 * Handle stats cache.
 *
 * @param string $method
 *   Whether to get or set cache.
 * @param string $cache_name
 *   The cache name.
 * @param int $health_center_id
 *   The health center node ID.
 * @param string $period
 *   Optional; A period for the cache ID.
 * @param mixed $cache_data
 *   Optional; The cache data to set, if empty it won't be set.
 *
 * @return mixed|null
 *   Either the cache data or nothing if we are setting it.
 */
function hedley_stats_handle_cache($method, $cache_name, $health_center_id, $period = NULL, $cache_data = NULL) {
  $cache_id = $period ? $cache_name . '_' . $health_center_id . '_' . $period : $cache_name . '_' . $health_center_id;

  switch ($method) {
    case HEDLEY_STATS_CACHE_GET:
      $cache = cache_get($cache_id);
      return !empty($cache) ? $cache->data : NULL;

    case HEDLEY_STATS_CACHE_SET:
      if ($cache_data) {
        cache_set($cache_id, $cache_data);
      }
      break;

    case HEDLEY_STATS_CACHE_CLEAR:
      $cache = cache_get($cache_id);
      if (!empty($cache)) {
        cache_clear_all($cache_id, 'cache');
      }
      break;
  }
}

/**
 * Returns number of days in given month of given year.
 *
 * @param int $year
 *   The year.
 * @param int $month
 *   The month.
 *
 * @see: https://stackoverflow.com/questions/9240891/
 *       cal-days-in-month-function-is-not-working#answer-9240933.
 *
 * @return int
 *   Number of days in given month of given year
 */
function hedley_stats_calculate_days_in_month($year, $month) {
  return (int) date('t', mktime(0, 0, 0, $month, 1, $year));
}
