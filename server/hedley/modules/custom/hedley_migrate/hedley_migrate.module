<?php

/**
 * @file
 * Populate Hedley content.
 */

use Faker\Generator;

/**
 * Implements hook_migrate_api().
 */
function hedley_migrate_migrate_api() {
  $api = [
    'api' => 2,
    'groups' => [
      'missing' => [
        'title' => t('Missing Data'),
      ],
    ],
    'migrations' => [
      'HedleyMigrateUsers' => [
        'class_name' => 'HedleyMigrateUsers',
      ],
      'HedleyMigrateClinics' => [
        'class_name' => 'HedleyMigrateClinics',
      ],
      'HedleyMigrateMissingHeights' => [
        'class_name' => 'HedleyMigrateMissingHeights',
        'group_name' => 'missing',
      ],
      'HedleyMigrateMissingWeights' => [
        'class_name' => 'HedleyMigrateMissingWeights',
        'group_name' => 'missing',
      ],
      'HedleyMigrateMissingMuacs' => [
        'class_name' => 'HedleyMigrateMissingMuacs',
        'group_name' => 'missing',
      ],
    ],
  ];

  return $api;
}

/**
 * Implements hook_hedley_faker_node_generate().
 */
function hedley_migrate_hedley_faker_node_generate($node, Generator $faker) {
  if (!$node->uid) {
    // User can't be anonymous, get a random user(not admin or anonymous).
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'user')
      ->propertyCondition('uid', [0, 1], 'NOT IN')
      ->range(0, 200)
      ->execute();

    $node->uid = array_rand($result['user']);
  }

  $node->title = $faker->sentence(6);

  switch ($node->type) {
    case 'child':
      _hedley_migrate_preprocess_child($node, $faker);
      break;

    case 'mother':
      _hedley_migrate_preprocess_mother($node, $faker);
      break;

    case 'weight':
      _hedley_migrate_preprocess_weight($node);
      break;

    case 'height':
      _hedley_migrate_preprocess_height($node);
      break;

    case 'muac':
      _hedley_migrate_preprocess_muac($node);
      break;
  }

  // Adjust XSS.
  _hedley_migrate_preprocess_xss('node', $node->type, $node);
}

/**
 * Implements hook_hedley_faker_taxonomy_term_generate().
 */
function hedley_migrate_hedley_faker_taxonomy_term_generate($term, Generator $faker) {
  $term->name = $faker->sentence(2);

  // Adjust XSS.
  _hedley_migrate_preprocess_xss('taxonomy_term', $term->vocabulary_machine_name, $term);
}

function hedley_migrate_generate_geo_terms_vocabulary() {
  if (taxonomy_vocabulary_machine_name_load('ihangane_villages')) {
    return;
  }

  $vocabulary = (object) array(
    'name' => 'Ihangane villages vocabulary',
    'description' => 'This vocabulary lists all villages',
    'machine_name' => 'ihangane_villages',
  );
  taxonomy_vocabulary_save($vocabulary);

  $migrate_dir = variable_get('hedley_migrate_directory', FALSE) ? variable_get('hedley_migrate_directory') : drupal_get_path('module', 'hedley_migrate');
  $source_file = $migrate_dir . '/csv/villages.csv';

  $index_mapping = [
    'province',
    'district',
    'sector',
    'cell',
    'village',
  ];
  $column_mapping = array_flip($index_mapping);

  $data = [
    $mapping['province'] = [],
    $mapping['district'] = [],
    $mapping['sector'] = [],
    $mapping['cell'] = [],
    $mapping['village'] = [],
  ];

  $locator = [];

  $handler = fopen($source_file, 'r');
  while ($row = fgetcsv($handler)) {
    foreach ($row as $index => $column) {
      _hedley_migrate_process_column($data, $locator, $column, $index, $row, $vocabulary, $column_mapping, $index_mapping);
    }
  }

  fclose($handler);
}

function _hedley_migrate_process_column(&$data, &$locator, $value, $index, $row, $vocab, $mapping, $flipped_mapping) {
  $locator_index = implode('-', array_slice($row, 0, $index + 1));

  if (!empty($locator[$locator_index])) {
    return;
  }

  if ($index != $mapping['province']) {
    $parent_key = $row[$index - 1];
    $parent = $data[$index - 1][$parent_key];
  }
  else {
    $parent = 0;
  }

  $term = (object) [
    'name' => $value,
    'description' => ucfirst($flipped_mapping[$index]) . ' ' . $value,
    'vid' => $vocab->vid,
    'parent' => $parent,
  ];

  taxonomy_term_save($term);
  $data[$index][$value] = $locator[$locator_index] = $term->tid;
}

function hedley_migrate_generate_geo_terms_for_client() {
  // Todo: Load vocabulary and query for provinces according to it's ID.

  $provinces_tids = _hedley_migrate_get_terms_by_parent([0]);
  $provinces = [];
  foreach (taxonomy_term_load_multiple($provinces_tids) as $province) {
    $id = 'toEntityId ' . $province->tid;
    $name = $province->name;

    $provinces[] = "( $id, GeoLocation ($id) \"$name\" Nothing)";
  }

  dpm('[ ' . implode("\n, ", $provinces) . ' ]');

  $districts_tids = _hedley_migrate_get_terms_by_parent($provinces_tids);

  $districts = [];
  foreach (taxonomy_term_load_multiple($districts_tids) as $district) {
    $wrapper = entity_metadata_wrapper('taxonomy_term', $district);
    $parent_tids = $wrapper->parent->value(['identifier' => TRUE]);
    $parent_tid = reset($parent_tids);
    $id = 'toEntityId ' . $district->tid;
    $name = $district->name;
    $parent = '(Just <| toEntityId ' . $parent_tid . ')';

    $districts[] = "( $id, GeoLocation ($id) \"$name\" $parent)";
  }

  dpm('[ ' . implode("\n, ", $districts) . ' ]');

  $sectors_tids = _hedley_migrate_get_terms_by_parent($districts_tids);
  $sectors = [];
  foreach (taxonomy_term_load_multiple($sectors_tids) as $sector) {
    $wrapper = entity_metadata_wrapper('taxonomy_term', $sector);
    $parent_tids = $wrapper->parent->value(['identifier' => TRUE]);
    $parent_tid = reset($parent_tids);
    $id = 'toEntityId ' . $sector->tid;
    $name = $sector->name;
    $parent = '(Just <| toEntityId ' . $parent_tid . ')';

    $sectors[] = "( $id, GeoLocation ($id) \"$name\" $parent)";
  }

  dpm('[ ' . implode("\n, ", $sectors) . ' ]');

  $cells_tids = _hedley_migrate_get_terms_by_parent($sectors_tids);
  $cells = [];
  foreach (taxonomy_term_load_multiple($cells_tids) as $cell) {
    $wrapper = entity_metadata_wrapper('taxonomy_term', $cell);
    $parent_tids = $wrapper->parent->value(['identifier' => TRUE]);
    $parent_tid = reset($parent_tids);
    $id = 'toEntityId ' . $cell->tid;
    $name = $cell->name;
    $parent = '(Just <| toEntityId ' . $parent_tid . ')';

    $cells[] = "( $id, GeoLocation ($id) \"$name\" $parent)";
  }

  dpm('[ ' . implode("\n, ", $cells) . ' ]');


  $villages_tids = _hedley_migrate_get_terms_by_parent($cells_tids);
  $tids_chunks = array_chunk($villages_tids, 256);
  $chunks = [];
  foreach ($tids_chunks as $tid_chunk) {
    $villages = [];
    foreach (taxonomy_term_load_multiple($tid_chunk) as $village) {
      $wrapper = entity_metadata_wrapper('taxonomy_term', $village);
      $parent_tids = $wrapper->parent->value(['identifier' => TRUE]);
      $parent_tid = reset($parent_tids);
      $id = 'toEntityId ' . $village->tid;
      $name = $village->name;
      $parent = '(Just <| toEntityId ' . $parent_tid . ')';

      $villages[] = "( $id, GeoLocation ($id) \"$name\" $parent)";
    }

    $chunks[] = '[ ' . implode("\n, ", $villages) . ' ]';
  }

  dpm(implode(" ++ \n ", $chunks));
}

function _hedley_migrate_get_terms_by_parent($parents) {
  return db_select('taxonomy_term_hierarchy', 'hierarchy')
    ->fields('hierarchy', ['tid'])
    ->condition('hierarchy.parent', $parents, 'IN')
    ->execute()
    ->fetchCol();
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * We should have at least one entity from each bundle with an XSS label.
 *
 * @param string $entity_type
 *   The entity type to alter.
 * @param string $bundle
 *   The bundle of the entity.
 * @param object $entity
 *   Site entity object.
 */
function _hedley_migrate_preprocess_xss($entity_type, $bundle, $entity) {
  // This global var keeps xss indication for each entity type / bundle.
  $_hedley_devel_generate = &drupal_static(__FUNCTION__, []);

  if (!$entity_info = entity_get_info($entity_type)) {
    return;
  }

  $label_property = $entity_info['entity keys']['label'];

  // Validate the current node type has at least one instance with XSS.
  $xss_is_missing = empty($_hedley_devel_generate[$entity_type][$bundle]);

  $randomly_add_xss = rand() % 2 == 0;
  if (!$xss_is_missing && $randomly_add_xss) {
    return;
  }

  // Indicate the current bundle has an XSS instance.
  $_hedley_devel_generate[$entity_type][$bundle] = TRUE;

  $wrapper = entity_metadata_wrapper($entity_type, $entity);

  // Adjust node's title to include XSS.
  $label = $wrapper->label();
  $wrapper->{$label_property}->set("<script>alert('XSS-{$entity_type}-{$bundle}-{$label}')</script>");

  // Handle all text fields.
  foreach (field_info_instances($entity_type, $bundle) as $field_name => $field) {
    $field = field_info_field($field_name);
    if ($field['module'] != 'text') {
      continue;
    }

    // Handle each column.
    foreach ($field['columns'] as $column => $column_info) {
      if ($column == 'format') {
        // We should not allow full html format for XSS attempt.
        if ($wrapper->{$field_name}->format->value() == 'full_html') {
          $wrapper->{$field_name}->format->set('filtered_html');
        }
      }
      else {
        $wrapper->{$field_name}->{$column}->set("<script>alert('XSS-{$entity_type}-{$bundle}-{$field_name}')</script>");
      }
    }
  }
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 * @param \Faker\Generator $faker
 *   The faker generator object.
 */
function _hedley_migrate_preprocess_child($node, Generator $faker) {
  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->title->set($faker->firstName);

  $_hedley_devel_generate = &drupal_static(__FUNCTION__, FALSE);

  if ($_hedley_devel_generate) {
    return;
  }
  $_hedley_devel_generate = TRUE;

}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 * @param \Faker\Generator $faker
 *   The faker generator object.
 */
function _hedley_migrate_preprocess_mother($node, Generator $faker) {
  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->title->set($faker->firstNameFemale);
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 */
function _hedley_migrate_preprocess_weight($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Adjust children's weight to realistic figures.
  $wrapper->field_weight->set(rand(0.5, 60));
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 */
function _hedley_migrate_preprocess_height($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Adjust children's height to realistic figures.
  $wrapper->field_height->set(rand(30, 160));
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 */
function _hedley_migrate_preprocess_muac($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Adjust children's height to realistic figures.
  $wrapper->field_muac->set(rand(10, 40));
}
