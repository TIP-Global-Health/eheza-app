<?php

/**
 * @file
 * Populate Hedley content.
 */

use Faker\Generator;

/**
 * Implements hook_migrate_api().
 */
function hedley_migrate_migrate_api() {
  $api = [
    'api' => 2,
    'groups' => [
      'missing' => [
        'title' => t('Missing Data'),
      ],
      'villages' => [
        'title' => t('Villages'),
      ],
      'batch_2019_02' => [
        'title' => t('Batch data added 2019/02'),
      ],
      'batch_2019_03' => [
        'title' => t('Batch data added 2019/03'),
      ],
      'counseling' => [
        'title' => t('Counseling'),
      ],
      'forms' => [
        'title' => t('Forms'),
      ],
      'batch_2019_04' => [
        'title' => t('Batch data added 2019/04'),
      ],
      'batch_2019_04_2' => [
        'title' => t('Second batch data added 2019/04'),
      ],
      'batch_2019_05' => [
        'title' => t('Batch data added 2019/05'),
      ],
      'batch_2019_05_2' => [
        'title' => t('Second batch data added 2019/05'),
      ],
      'batch_2019_05_3' => [
        'title' => t('Third batch data added 2019/05'),
      ],
    ],
    'migrations' => [
      'HedleyMigrateClinics_2019_02' => [
        'class_name' => 'HedleyMigrateClinics201902',
        'group_name' => 'batch_2019_02',
      ],
      'HedleyMigrateMothers_2019_02' => [
        'class_name' => 'HedleyMigrateMothers201902',
        'group_name' => 'batch_2019_02',
      ],
      'HedleyMigrateChildren_2019_02' => [
        'class_name' => 'HedleyMigrateChildren201902',
        'group_name' => 'batch_2019_02',
      ],
      'HedleyMigrateMothers_2019_03' => [
        'class_name' => 'HedleyMigrateMothers201903',
        'group_name' => 'batch_2019_03',
      ],
      'HedleyMigrateChildren_2019_03' => [
        'class_name' => 'HedleyMigrateChildren201903',
        'group_name' => 'batch_2019_03',
      ],
      'HedleyMigrateMothers_2019_04' => [
        'class_name' => 'HedleyMigrateMothers201904',
        'group_name' => 'batch_2019_04',
      ],
      'HedleyMigrateChildren_2019_04' => [
        'class_name' => 'HedleyMigrateChildren201904',
        'group_name' => 'batch_2019_04',
      ],
      'HedleyMigrateClinics_2019_04' => [
        'class_name' => 'HedleyMigrateClinics201904',
        'group_name' => 'batch_2019_04',
      ],
      'HedleyMigrateMothers_2019_04_2' => [
        'class_name' => 'HedleyMigrateMothers2019042',
        'group_name' => 'batch_2019_04_2',
      ],
      'HedleyMigrateChildren_2019_04_2' => [
        'class_name' => 'HedleyMigrateChildren2019042',
        'group_name' => 'batch_2019_04_2',
      ],
      'HedleyMigrateMothers_2019_05' => [
        'class_name' => 'HedleyMigrateMothers201905',
        'group_name' => 'batch_2019_05',
      ],
      'HedleyMigrateChildren_2019_05' => [
        'class_name' => 'HedleyMigrateChildren201905',
        'group_name' => 'batch_2019_05',
      ],
      'HedleyMigrateMothers_2019_05_2' => [
        'class_name' => 'HedleyMigrateMothers2019052',
        'group_name' => 'batch_2019_05_2',
      ],
      'HedleyMigrateChildren_2019_05_2' => [
        'class_name' => 'HedleyMigrateChildren2019052',
        'group_name' => 'batch_2019_05_2',
      ],
      'HedleyMigrateMothers_2019_05_3' => [
        'class_name' => 'HedleyMigrateMothers2019053',
        'group_name' => 'batch_2019_05_3',
      ],
      'HedleyMigrateChildren_2019_05_3' => [
        'class_name' => 'HedleyMigrateChildren2019053',
        'group_name' => 'batch_2019_05_3',
      ],
      'HedleyMigrateUsers' => [
        'class_name' => 'HedleyMigrateUsers',
      ],
      'HedleyMigrateDevices' => [
        'class_name' => 'HedleyMigrateDevices',
      ],
      'HedleyMigrateClinics' => [
        'class_name' => 'HedleyMigrateClinics',
      ],
      'HedleyMigratePmtctParticipants' => [
        'class_name' => 'HedleyMigratePmtctParticipants',
      ],
      'HedleyMigrateRelationships' => [
        'class_name' => 'HedleyMigrateRelationships',
      ],
      'HedleyMigrateSessions' => [
        'class_name' => 'HedleyMigrateSessions',
      ],
      'HedleyMigrateCatchmentAreas' => [
        'class_name' => 'HedleyMigrateCatchmentAreas',
      ],
      'HedleyMigrateHealthCenters' => [
        'class_name' => 'HedleyMigrateHealthCenters',
      ],
      'HedleyMigratePeople' => [
        'class_name' => 'HedleyMigratePeople',
      ],
      'HedleyMigrateNurses' => [
        'class_name' => 'HedleyMigrateNurses',
      ],
      'HedleyMigrateAttendances' => [
        'class_name' => 'HedleyMigrateAttendances',
      ],
      'HedleyMigrateFamilyPlannings' => [
        'class_name' => 'HedleyMigrateFamilyPlannings',
      ],
      'HedleyMigrateHeights' => [
        'class_name' => 'HedleyMigrateHeights',
      ],
      'HedleyMigrateMuacs' => [
        'class_name' => 'HedleyMigrateMuacs',
      ],
      'HedleyMigrateNutritions' => [
        'class_name' => 'HedleyMigrateNutritions',
      ],
      'HedleyMigratePhotos' => [
        'class_name' => 'HedleyMigratePhotos',
      ],
      'HedleyMigrateWeights' => [
        'class_name' => 'HedleyMigrateWeights',
      ],
      'HedleyMigrateVillages' => [
        'class_name' => 'HedleyMigrateVillages',
        'group_name' => 'villages',
      ],      
      'HedleyMigrateMissingHeights' => [
        'class_name' => 'HedleyMigrateMissingHeights',
        'group_name' => 'missing',
      ],
      'HedleyMigrateMissingWeights' => [
        'class_name' => 'HedleyMigrateMissingWeights',
        'group_name' => 'missing',
      ],
      'HedleyMigrateMissingMuacs' => [
        'class_name' => 'HedleyMigrateMissingMuacs',
        'group_name' => 'missing',
      ],
      'HedleyMigrateCounselingSchedules' => [
        'class_name' => 'HedleyMigrateCounselingSchedules',
        'group_name' => 'counseling',
      ],
      'HedleyMigrateCounselingSessions' => [
        'class_name' => 'HedleyMigrateCounselingSessions',
        'group_name' => 'counseling',
      ],
      'HedleyMigrateCounselingTopics' => [
        'class_name' => 'HedleyMigrateCounselingTopics',
        'group_name' => 'counseling',
      ],
      'HedleyMigrateParticipantForms' => [
        'class_name' => 'HedleyMigrateParticipantForms',
        'group_name' => 'forms',
      ],
    ],
  ];

  return $api;
}

/**
 * Implements hook_hedley_faker_node_generate().
 */
function hedley_migrate_hedley_faker_node_generate($node, Generator $faker) {
  if (!$node->uid) {
    // User can't be anonymous, get a random user(not admin or anonymous).
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'user')
      ->propertyCondition('uid', [0, 1], 'NOT IN')
      ->range(0, 200)
      ->execute();

    $node->uid = array_rand($result['user']);
  }

  $node->title = $faker->sentence(6);

  switch ($node->type) {
    case 'child':
      _hedley_migrate_preprocess_child($node, $faker);
      break;

    case 'mother':
      _hedley_migrate_preprocess_mother($node, $faker);
      break;

    case 'weight':
      _hedley_migrate_preprocess_weight($node);
      break;

    case 'height':
      _hedley_migrate_preprocess_height($node);
      break;

    case 'muac':
      _hedley_migrate_preprocess_muac($node);
      break;
  }

  // Adjust XSS.
  _hedley_migrate_preprocess_xss('node', $node->type, $node);
}

/**
 * Implements hook_hedley_faker_taxonomy_term_generate().
 */
function hedley_migrate_hedley_faker_taxonomy_term_generate($term, Generator $faker) {
  $term->name = $faker->sentence(2);

  // Adjust XSS.
  _hedley_migrate_preprocess_xss('taxonomy_term', $term->vocabulary_machine_name, $term);
}

/**
 * Function creates Taxonomy vocabulary that describes GeoLocations.
 *
 * Currently, it's only use is to generate GeoLocation data structure that
 * will be set on client.
 *
 * Structure:
 *  - Level 0: province
 *  - Level 1: district
 *  - Level 2: sector
 *  - Level 3: cell
 *  - Level 4: village
 */
function hedley_migrate_generate_geo_terms_vocabulary() {
  if (taxonomy_vocabulary_machine_name_load('ihangane_geolocation')) {
    // Vocabulary already exists.
    return;
  }

  // Create new vocabulary.
  $vocabulary = (object) array(
    'name' => 'Ihangane geolocation vocabulary',
    'description' => 'This vocabulary lists all geolocations',
    'machine_name' => 'ihangane_geolocation',
  );
  taxonomy_vocabulary_save($vocabulary);

  // Load input file.
  $migrate_dir = variable_get('hedley_migrate_directory', FALSE) ? variable_get('hedley_migrate_directory') : drupal_get_path('module', 'hedley_migrate');
  $source_file = $migrate_dir . '/csv/geo_locations.csv';

  $column_mapping = ['province', 'district', 'sector', 'cell', 'village'];

  foreach ($column_mapping as $column) {
    $data[] = [];
  }

  // Used to check if term exists (was previously created), so we can
  // skip it.
  $locator = [];

  $handler = fopen($source_file, 'r');
  while ($row = fgetcsv($handler)) {
    foreach ($row as $index => $column) {
      _hedley_migrate_process_column($data, $locator, $index, $row, $vocabulary->vid, $column_mapping);
    }
  }

  fclose($handler);
}

/**
 * Processes a column form input file row.
 *
 * Row contains 5 columns:
 *  [ province, district, sector, cell, village ]
 *
 * Function is invoked for each column in a row.
 *
 * @param array $data
 *   Terms created so far.
 * @param array $locator
 *   Locator array, that helps to determine if term requires creation.
 * @param int $index
 *   Index of column that is being processed.
 * @param array $row
 *   The row that contains processed column.
 * @param int $vocabulary_id
 *   The ID of vocabulary to which terms are added.
 * @param array $column_mapping
 *   Columns mapping array.
 */
function _hedley_migrate_process_column(array &$data, array &$locator, $index, array $row, $vocabulary_id, array $column_mapping) {
  $locator_index = implode('-', array_slice($row, 0, $index + 1));

  if (!empty($locator[$locator_index])) {
    // Term already exists.
    return;
  }

  // Resolve term parent.
  if ($index != 0) {
    $parent_key = $row[$index - 1];
    $parent = $data[$index - 1][$parent_key];
  }
  else {
    $parent = 0;
  }

  // Create the term.
  $term = (object) [
    'name' => ucfirst(strtolower($row[$index])),
    'description' => ucfirst($column_mapping[$index]) . ' ' . $row[$index],
    'vid' => $vocabulary_id,
    'parent' => $parent,
  ];
  taxonomy_term_save($term);

  // Update data and locator arrays with new term.
  $data[$index][$row[$index]] = $locator[$locator_index] = $term->tid;
}

/**
 * Generates static geolocation structure to be used by client.
 */
function hedley_migrate_generate_geolocation_structure_for_client() {
  if (!$vocabulary = taxonomy_vocabulary_machine_name_load('ihangane_geolocation')) {
    // Vocabulary does not exist.
    return;
  }

  $column_mapping = ['province', 'district', 'sector', 'cell', 'village'];
  foreach ($column_mapping as $index => $column) {
    $data[$index] = [];

    $data[$index]['tids'] = $index == 0 ?
      // We specify vocabulary ID only for top level.
      _hedley_migrate_get_children_by_parents([0], $vocabulary->vid) :
      // We know for sure that all other levels belong to same vocabulary.
      _hedley_migrate_get_children_by_parents($data[$index - 1]['tids']);

    $data[$index]['structure'] = hedley_migrate_generate_structure_for_terms_of_type($column, $data[$index]['tids']);
  }
}

/**
 * Generates structure for all terms of specified type.
 *
 * @param string $type
 *   Type that term represents - province/district/sector/cell/village.
 * @param array $tids
 *   All term IDs for provided type.
 * @param int $chunk_size
 *   Number of terms in single chunk, while processing terms array.
 *
 * @return string
 *   Structure that is generated for provided input.
 */
function hedley_migrate_generate_structure_for_terms_of_type($type, array $tids, $chunk_size = 256) {
  $tids_chunks = array_chunk($tids, $chunk_size);
  $chunks = [];

  foreach ($tids_chunks as $tid_chunk) {
    $entities = [];
    foreach (taxonomy_term_load_multiple($tid_chunk) as $term) {
      $id = 'toEntityId ' . $term->tid;
      $name = $term->name;

      if ($type == 'province') {
        $parent = 'Nothing';
      }
      else {
        $wrapper = entity_metadata_wrapper('taxonomy_term', $term);
        $parent_tids = $wrapper->parent->value(['identifier' => TRUE]);
        $parent_tid = reset($parent_tids);
        $parent = "(Just <| toEntityId $parent_tid)";
      }

      $entities[] = "( $id, GeoLocation \"$name\" $parent)";
    }

    $chunks[] = '[ ' . implode("\n, ", $entities) . ' ]';
  }

  return implode(" ++ \n ", $chunks);
}

/**
 * IDs of all children terms for specified parents term IDs.
 *
 * @param array $parents
 *   The IDs of parent terms.
 * @param int|bool $vocabulary_id
 *   The ID of vocabulary to which terms belong. False if it's not important.
 *
 * @return array
 *   The IDs of all children terms for specified parents.
 */
function _hedley_migrate_get_children_by_parents(array $parents, $vocabulary_id = FALSE) {
  $query = db_select('taxonomy_term_hierarchy', 'hierarchy');
  if ($vocabulary_id) {
    $query->innerJoin('taxonomy_term_data', 'data', 'hierarchy.tid = data.tid');
  }

  $query
    ->fields('hierarchy', ['tid'])
    ->condition('hierarchy.parent', $parents, 'IN');

  if ($vocabulary_id) {
    $query->condition('data.vid', $vocabulary_id);
  }

  return $query->execute()->fetchCol();
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * We should have at least one entity from each bundle with an XSS label.
 *
 * @param string $entity_type
 *   The entity type to alter.
 * @param string $bundle
 *   The bundle of the entity.
 * @param object $entity
 *   Site entity object.
 */
function _hedley_migrate_preprocess_xss($entity_type, $bundle, $entity) {
  // This global var keeps xss indication for each entity type / bundle.
  $_hedley_devel_generate = &drupal_static(__FUNCTION__, []);

  if (!$entity_info = entity_get_info($entity_type)) {
    return;
  }

  $label_property = $entity_info['entity keys']['label'];

  // Validate the current node type has at least one instance with XSS.
  $xss_is_missing = empty($_hedley_devel_generate[$entity_type][$bundle]);

  $randomly_add_xss = rand() % 2 == 0;
  if (!$xss_is_missing && $randomly_add_xss) {
    return;
  }

  // Indicate the current bundle has an XSS instance.
  $_hedley_devel_generate[$entity_type][$bundle] = TRUE;

  $wrapper = entity_metadata_wrapper($entity_type, $entity);

  // Adjust node's title to include XSS.
  $label = $wrapper->label();
  $wrapper->{$label_property}->set("<script>alert('XSS-{$entity_type}-{$bundle}-{$label}')</script>");

  // Handle all text fields.
  foreach (field_info_instances($entity_type, $bundle) as $field_name => $field) {
    $field = field_info_field($field_name);
    if ($field['module'] != 'text') {
      continue;
    }

    if ($field_name === 'field_uuid') {
      // This is an auto-populated field.
      continue;
    }

    $wrapper->{$field_name}->set("<script>alert('XSS-{$entity_type}-{$bundle}-{$field_name}')</script>");
  }
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 * @param \Faker\Generator $faker
 *   The faker generator object.
 */
function _hedley_migrate_preprocess_child($node, Generator $faker) {
  $wrapper = entity_metadata_wrapper('node', $node);

  $helpers = _hedley_migrate_participant_helpers();

  $gender = $helpers['gender'][$faker->numberBetween(0, count($helpers['gender']) - 1)];
  $wrapper->field_gender->set($gender);

  $first_name = $gender == 'male' ? $faker->firstNameMale : $faker->firstNameFemale;
  $middle_name = $gender == 'male' ? $faker->firstNameMale : $faker->firstNameFemale;
  $second_name = $faker->lastName;
  $wrapper->title->set("$first_name $middle_name $second_name");

  // Leave this blank, to test our migration scripts.
  $wrapper->field_person->set(NULL);

  $mode_of_delivery = [
    'svd-episiotomy',
    'svd-no-episiotomy',
    'vd-vacuum',
    'cesarean-delivery',
  ];
  $wrapper->field_mode_of_delivery->set($mode_of_delivery[$faker->numberBetween(0, count($mode_of_delivery) - 1)]);

  $_hedley_devel_generate = &drupal_static(__FUNCTION__, FALSE);

  if ($_hedley_devel_generate) {
    return;
  }

  $_hedley_devel_generate = TRUE;
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 * @param \Faker\Generator $faker
 *   The faker generator object.
 */
function _hedley_migrate_preprocess_mother($node, Generator $faker) {
  $wrapper = entity_metadata_wrapper('node', $node);

  $helpers = _hedley_migrate_participant_helpers();

  $gender = $helpers['gender'][$faker->numberBetween(0, count($helpers['gender']) - 1)];

  $first_name = $gender == 'male' ? $faker->firstNameMale : $faker->firstNameFemale;
  $middle_name = $gender == 'male' ? $faker->firstNameMale : $faker->firstNameFemale;
  $second_name = $faker->lastName;
  $wrapper->title->set("$first_name $middle_name $second_name");

  // Leave this blank, to test our migration scripts.
  $wrapper->field_person->set(NULL);

  $hiv_status = [
    'hiv-exposed-infant',
    'negative',
    'negative-dc',
    'positive',
    'unknown',
  ];
  $wrapper->field_hiv_status->set($hiv_status[$faker->numberBetween(0, count($hiv_status) - 1)]);
  $wrapper->field_household_size->set($faker->numberBetween(0, 30));
  $wrapper->field_number_of_children->set($faker->numberBetween(0, 20));
}

/**
 * Generates helper params for participants fields.
 *
 * @return array
 *   Helper params to generate participants fields.
 */
function _hedley_migrate_participant_helpers() {
  return [
    'gender' =>
      ['male', 'female'],
    'geolocation_info' => [
      ['Amajyaruguru', 'Gakenke', 'Busengo', 'Birambo', 'Birambo'],
      ['Amajyaruguru', 'Gakenke', 'Ruli', 'Gikingo', 'Nyamugari'],
      ['Amajyaruguru', 'Gakenke', 'Rushashi', 'Joma', 'Kineza'],
      ['Amajyaruguru', 'Rulindo', 'Burega', 'Butangampundu', 'Kibiraro'],
      ['Amajyaruguru', 'Rulindo', 'Bushoki', 'Mukoto', 'Muko'],
    ],
  ];
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 */
function _hedley_migrate_preprocess_weight($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Adjust children's weight to realistic figures.
  $wrapper->field_weight->set(rand(1, 60));
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 */
function _hedley_migrate_preprocess_height($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Adjust children's height to realistic figures.
  $wrapper->field_height->set(rand(30, 160));
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 */
function _hedley_migrate_preprocess_muac($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Adjust children's height to realistic figures.
  $wrapper->field_muac->set(rand(10, 40));
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Add a random order to the entity field query.
 */
function hedley_migrate_query_random_alter($query) {
  $query->orderRandom();
}

/**
 * Resolves the IDs of nodes which value at '$field' is within '$values'.
 *
 * @param string $type
 *   Node type.
 * @param string $field
 *   Name of the field.
 * @param array $values
 *   List of values.
 *
 * @return array
 *   Nodes IDS, or empty array, if none found.
 */
function hedley_migrate_resolve_for_export($type, $field, array $values) {
  if (!$values) {
    return [];
  }

  $query = new EntityFieldQuery();

  $result = $query->entityCondition('entity_type', 'node')
    ->propertyCondition('type', $type)
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition($field, 'target_id', $values, 'IN')
    ->execute();

  return empty($result['node']) ? [] : array_keys($result['node']);
}

/**
 * Generates DateTime field for export.
 *
 * Supports start and end dates.
 *
 * @param array $date
 *   Input date.
 * @param bool $force_end_date
 *   Whether to force setting end date. If True, sets current date.
 *
 * @return string
 *   Start date as 'yyyy-mm-dd'.
 *   Optional End date (same format), piped by '|' separator.
 */
function hedley_migrate_export_date_field(array $date, $force_end_date = FALSE) {
  $time1 = strtotime($date['value']);

  if (empty($date['value2'])) {

    if (!$force_end_date) {
      return date('Y-m-d', $time1);
    }

    $date['value2'] = date('Y-m-d');
  }

  $time2 = strtotime($date['value2']);

  return date('Y-m-d', $time1) . '|' . date('Y-m-d', $time2);
}
