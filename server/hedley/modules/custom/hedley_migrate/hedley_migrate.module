<?php

/**
 * @file
 * Populate Hedley content.
 */

use Faker\Generator;

/**
 * Implements hook_migrate_api().
 */
function hedley_migrate_migrate_api() {
  $api = [
    'api' => 2,
    'groups' => [
      'missing' => [
        'title' => t('Missing Data'),
      ],
    ],
    'migrations' => [
      'HedleyMigrateUsers' => [
        'class_name' => 'HedleyMigrateUsers',
      ],
      'HedleyMigrateClinics' => [
        'class_name' => 'HedleyMigrateClinics',
      ],
      'HedleyMigrateMissingHeights' => [
        'class_name' => 'HedleyMigrateMissingHeights',
        'group_name' => 'missing',
      ],
      'HedleyMigrateMissingWeights' => [
        'class_name' => 'HedleyMigrateMissingWeights',
        'group_name' => 'missing',
      ],
      'HedleyMigrateMissingMuacs' => [
        'class_name' => 'HedleyMigrateMissingMuacs',
        'group_name' => 'missing',
      ],
    ],
  ];

  return $api;
}

/**
 * Implements hook_hedley_faker_node_generate().
 */
function hedley_migrate_hedley_faker_node_generate($node, Generator $faker) {
  if (!$node->uid) {
    // User can't be anonymous, get a random user(not admin or anonymous).
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'user')
      ->propertyCondition('uid', [0, 1], 'NOT IN')
      ->range(0, 200)
      ->execute();

    $node->uid = array_rand($result['user']);
  }

  $node->title = $faker->sentence(6);

  switch ($node->type) {
    case 'child':
      _hedley_migrate_preprocess_child($node, $faker);
      break;

    case 'mother':
      _hedley_migrate_preprocess_mother($node, $faker);
      break;

    case 'weight':
      _hedley_migrate_preprocess_weight($node);
      break;

    case 'height':
      _hedley_migrate_preprocess_height($node);
      break;

    case 'muac':
      _hedley_migrate_preprocess_muac($node);
      break;
  }

  // Adjust XSS.
  _hedley_migrate_preprocess_xss('node', $node->type, $node);
}

/**
 * Implements hook_hedley_faker_taxonomy_term_generate().
 */
function hedley_migrate_hedley_faker_taxonomy_term_generate($term, Generator $faker) {
  $term->name = $faker->sentence(2);

  // Adjust XSS.
  _hedley_migrate_preprocess_xss('taxonomy_term', $term->vocabulary_machine_name, $term);
}

/**
 * Function creates Taxonomy vocabulary that describes GeoLocations.
 *
 * Currently, it's only use is to generate GeoLocation data structure that
 * will be set on client.
 *
 * Structure:
 *  - Level 0: province
 *  - Level 1: district
 *  - Level 2: sector
 *  - Level 3: cell
 *  - Level 4: village
 */
function hedley_migrate_generate_geo_terms_vocabulary() {
  if (taxonomy_vocabulary_machine_name_load('ihangane_geolocation')) {
    // Vocabulary already exists.
    return;
  }

  // Create new vocabulary.
  $vocabulary = (object) array(
    'name' => 'Ihangane geolocation vocabulary',
    'description' => 'This vocabulary lists all geolocations',
    'machine_name' => 'ihangane_geolocation',
  );
  taxonomy_vocabulary_save($vocabulary);

  // Load input file.
  $migrate_dir = variable_get('hedley_migrate_directory', FALSE) ? variable_get('hedley_migrate_directory') : drupal_get_path('module', 'hedley_migrate');
  $source_file = $migrate_dir . '/csv/villages.csv';

  $column_mapping = ['province', 'district', 'sector', 'cell', 'village'];

  foreach ($column_mapping as $column) {
    $data[] = [];
  }

  // Used to check if term exists (was previously created), so we can
  // skip it.
  $locator = [];

  $handler = fopen($source_file, 'r');
  while ($row = fgetcsv($handler)) {
    foreach ($row as $index => $column) {
      _hedley_migrate_process_column($data, $locator, $index, $row, $vocabulary->vid, $column_mapping);
    }
  }

  fclose($handler);
}

/**
 * Processes a column form input file row.
 *
 * Row contains 5 columns:
 *  [ province, district, sector, cell, village ]
 *
 * Function is invoked for each column in a row.
 *
 * @param array $data
 *   Terms created so far.
 * @param array $locator
 *   Locator array, that helps to determine if term requires creation.
 * @param int $index
 *   Index of column that is being processed.
 * @param array $row
 *   The row that contains processed column.
 * @param int $vocabulary_id
 *   The ID of vocabulary to which terms are added.
 * @param array $column_mapping
 *   Columns mapping array.
 */
function _hedley_migrate_process_column(&$data, &$locator, $index, $row, $vocabulary_id, $column_mapping) {
  $locator_index = implode('-', array_slice($row, 0, $index + 1));

  if (!empty($locator[$locator_index])) {
    // Term already exists.
    return;
  }

  // Resolve term parent.
  if ($index != 0) {
    $parent_key = $row[$index - 1];
    $parent = $data[$index - 1][$parent_key];
  }
  else {
    $parent = 0;
  }

  // Create the term.
  $term = (object) [
    'name' => $row[$index],
    'description' => ucfirst($column_mapping[$index]) . ' ' . $row[$index],
    'vid' => $vocabulary_id,
    'parent' => $parent,
  ];
  taxonomy_term_save($term);

  // Update data and locator arrays with new term.
  $data[$index][$row[$index]] = $locator[$locator_index] = $term->tid;
}

/**
 * Generates static geolocation structure to be used by client.
 */
function hedley_migrate_generate_geolocation_structure_for_client() {
  if (!$vocabulary = taxonomy_vocabulary_machine_name_load('ihangane_geolocation')) {
    // Vocabulary does not exist.
    return;
  }

  $column_mapping = ['province', 'district', 'sector', 'cell', 'village'];
  foreach ($column_mapping as $index => $column) {
    $data[$index] = [];

    $data[$index]['tids'] = $index == 0 ?
      // We specify vocabulary ID only for top level.
      _hedley_migrate_get_children_by_parents([0], $vocabulary->vid) :
      // We know for sure that all other levels belong to same vocabulary.
      _hedley_migrate_get_children_by_parents($data[$index - 1]['tids']);

    $data[$index]['structure'] = hedley_migrate_generate_structure_for_terms_of_type($column, $data[$index]['tids']);
    dpm($data[$index]['structure']);
  }
}

/**
 * Generates structure for all terms of specified type.
 *
 * @param string $type
 *   Type that term represents - province/district/sector/cell/village.
 * @param array $tids
 *   All term IDs for provided type.
 * @param int $chunk_size
 *   Number of terms in single chunk, while processing terms array.
 *
 * @return string
 *   Structure that is generated for provided input.
 */
function hedley_migrate_generate_structure_for_terms_of_type($type, array $tids, $chunk_size = 256) {
  $tids_chunks = array_chunk($tids, $chunk_size);
  $chunks = [];

  foreach ($tids_chunks as $tid_chunk) {
    $entities = [];
    foreach (taxonomy_term_load_multiple($tid_chunk) as $term) {
      $id = 'toEntityId ' . $term->tid;
      $name = $term->name;

      if ($type == 'province' ) {
        $parent = 'Nothing';
      }
      else {
        $wrapper = entity_metadata_wrapper('taxonomy_term', $term);
        $parent_tids = $wrapper->parent->value(['identifier' => TRUE]);
        $parent_tid = reset($parent_tids);
        $parent = '(Just <| toEntityId ' . $parent_tid . ')';
      }

      $entities[] = "( $id, GeoLocation \"$name\" $parent)";
    }

    $chunks[] = '[ ' . implode("\n, ", $entities) . ' ]';
  }

  return implode(" ++ \n ", $chunks);
}

/**
 * IDs of all children terms for specified parents term IDs.
 *
 * @param array $parents
 *   The IDs of parent terms.
 * @param int|bool $vocabulary_id
 *   The ID of vocabulary to which terms belong. False if it's not important.
 *
 * @return array
 *   The IDs of all children terms for specified parents.
 */
function _hedley_migrate_get_children_by_parents($parents, $vocabulary_id = FALSE) {
  $query = db_select('taxonomy_term_hierarchy', 'hierarchy');
  if ($vocabulary_id) {
    $query->innerJoin('taxonomy_term_data', 'data', 'hierarchy.tid = data.tid');
  }

  $query
    ->fields('hierarchy', ['tid'])
    ->condition('hierarchy.parent', $parents, 'IN');

  if ($vocabulary_id) {
    $query->condition('data.vid', $vocabulary_id);
  }

  return $query->execute()->fetchCol();
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * We should have at least one entity from each bundle with an XSS label.
 *
 * @param string $entity_type
 *   The entity type to alter.
 * @param string $bundle
 *   The bundle of the entity.
 * @param object $entity
 *   Site entity object.
 */
function _hedley_migrate_preprocess_xss($entity_type, $bundle, $entity) {
  // This global var keeps xss indication for each entity type / bundle.
  $_hedley_devel_generate = &drupal_static(__FUNCTION__, []);

  if (!$entity_info = entity_get_info($entity_type)) {
    return;
  }

  $label_property = $entity_info['entity keys']['label'];

  // Validate the current node type has at least one instance with XSS.
  $xss_is_missing = empty($_hedley_devel_generate[$entity_type][$bundle]);

  $randomly_add_xss = rand() % 2 == 0;
  if (!$xss_is_missing && $randomly_add_xss) {
    return;
  }

  // Indicate the current bundle has an XSS instance.
  $_hedley_devel_generate[$entity_type][$bundle] = TRUE;

  $wrapper = entity_metadata_wrapper($entity_type, $entity);

  // Adjust node's title to include XSS.
  $label = $wrapper->label();
  $wrapper->{$label_property}->set("<script>alert('XSS-{$entity_type}-{$bundle}-{$label}')</script>");

  // Handle all text fields.
  foreach (field_info_instances($entity_type, $bundle) as $field_name => $field) {
    $field = field_info_field($field_name);
    if ($field['module'] != 'text') {
      continue;
    }

    // Handle each column.
    foreach ($field['columns'] as $column => $column_info) {
      if ($column == 'format') {
        // We should not allow full html format for XSS attempt.
        if ($wrapper->{$field_name}->format->value() == 'full_html') {
          $wrapper->{$field_name}->format->set('filtered_html');
        }
      }
      else {
        $wrapper->{$field_name}->{$column}->set("<script>alert('XSS-{$entity_type}-{$bundle}-{$field_name}')</script>");
      }
    }
  }
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 * @param \Faker\Generator $faker
 *   The faker generator object.
 */
function _hedley_migrate_preprocess_child($node, Generator $faker) {
  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->title->set($faker->firstName);

  $_hedley_devel_generate = &drupal_static(__FUNCTION__, FALSE);

  if ($_hedley_devel_generate) {
    return;
  }
  $_hedley_devel_generate = TRUE;

}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 * @param \Faker\Generator $faker
 *   The faker generator object.
 */
function _hedley_migrate_preprocess_mother($node, Generator $faker) {
  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->title->set($faker->firstNameFemale);
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 */
function _hedley_migrate_preprocess_weight($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Adjust children's weight to realistic figures.
  $wrapper->field_weight->set(rand(0.5, 60));
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 */
function _hedley_migrate_preprocess_height($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Adjust children's height to realistic figures.
  $wrapper->field_height->set(rand(30, 160));
}

/**
 * Alters devel generated Sites to satisfy business logic.
 *
 * @param object $node
 *   Site node object.
 */
function _hedley_migrate_preprocess_muac($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Adjust children's height to realistic figures.
  $wrapper->field_muac->set(rand(10, 40));
}
