<?php

/**
 * @file
 * Code for the Hedley Device feature.
 */

use Ramsey\Uuid\Uuid;

include_once 'hedley_device.features.inc';

// A UUIDv4 (randomly generated) which we'll use for generating a UUIDv5 for
// nodes created on the backend. Nodes created on devices and synced to the
// backend will be given UUIDs by the devices themselves (based on device UUIDs
// assigned when they pair). We could generate this dynamically on install, but
// there doesn't seem to be any disadvantage to just making it a constant.
define('HEDLEY_DEVICE_BACKEND_UUID', 'c700aec4-92c1-46b2-8894-8f4f82869c79');

/**
 * Implements hook_node_insert().
 *
 * We assign the UUID in hodk_node_insert because at that point we have a
 * locally-unique node ID that we can use.
 */
function hedley_device_node_insert($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  if (!$wrapper->__isset('field_uuid')) {
    // We don't have a UUID field to set.
    return;
  }

  if (!empty($wrapper->field_uuid->value())) {
    // The UUID has already been set by a device.
    return;
  }

  $uuid = Uuid::uuid5(HEDLEY_DEVICE_BACKEND_UUID, $node->nid);
  $wrapper->field_uuid->set($uuid->toString());

  // We're already inside the database transaction, so we need to actually
  // update the database in this manner.
  field_attach_update('node', $node);
}

/**
 * Implements hook_node_presave().
 */
function hedley_device_node_presave($node) {
  // Create a revision for all nodes.
  $node->revision = TRUE;

  $wrapper = entity_metadata_wrapper('node', $node);

  // Check validity of UUID. If it's empty, it will be assigned in
  // hook_node_insert, once we know the node ID.
  if ($wrapper->__isset('field_uuid')) {
    $uuid = $wrapper->field_uuid->value();
    if (!empty($uuid) && !Uuid::isValid($uuid)) {
      $message = "The supplied UUID '$uuid' is not a valid UUID. Leave it blank to auto-generate.";
      throw new Exception($message);
    }
  }

  if ($node->type != 'device') {
    // Not a device.
    return;
  }

  if (empty($node->nid)) {
    // New device, so we generate a pairing code.
    $wrapper->field_pairing_code->set(hedley_device_get_unique_pairing_code());

    // And we make a robot user to authenticate for syncing.
    $role = user_role_load_by_name('sync');

    $account = entity_create('user', [
      'name' => $node->title . ' Robot',
      'mail' => 'robot@no-reply.com',
      'roles' => [$role->rid => $role->name],
      'status' => TRUE,
    ]);

    $wrapper = entity_metadata_wrapper('user', $account);
    $wrapper->save();

    // Set the author.
    $node->uid = $account->uid;
  }
  elseif (!hedley_device_check_unique_pairing_code($wrapper->field_pairing_code->value(), $wrapper->getIdentifier())) {
    // Existing device, so throw error if it's not unique.
    throw new Exception('The provided pairing code was not unique.');
  }
}

/**
 * Implements hook_node_delete().
 */
function hedley_device_node_delete($node) {
  // Allow to manually skip this exception.
  if (!empty($node->allow_delete)) {
    return;
  }

  throw new Exception('Cannot delete this node. Consider unpublishing it instead.');
}

/**
 * Return an 8-digit unique pairing code.
 *
 * @return int
 *   The pincode.
 */
function hedley_device_get_unique_pairing_code() {
  $rand = rand(10000000, 99999999);

  if (hedley_device_check_unique_pairing_code($rand)) {
    // Pairing code is unique.
    return $rand;
  }

  // Try again.
  return hedley_device_get_unique_pairing_code();
}

/**
 * Check whether the supplied pairing code is already used.
 *
 * @param string $code
 *   The pairing code to check.
 * @param null|int $nid
 *   Optional; A node ID to ignore.
 *
 * @return bool
 *   TRUE if the supplied pairing code is unique
 */
function hedley_device_check_unique_pairing_code($code, $nid = NULL) {
  if (empty($code)) {
    // An empty pairing code is permissible.
    return TRUE;
  }

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'device')
    ->fieldCondition('field_pairing_code', 'value', $code)
    // Enough to know if there is one more.
    ->range(0, 1);

  if ($nid) {
    $query->propertyCondition('nid', $nid, '<>');
  }

  $count = $query
    ->count()
    ->execute();

  return $count == 0;
}
