<?php

/**
 * @file
 * Code for the RESTful integration.
 */

/**
 * Nodes synced to all devices.
 *
 * The content types and their restful handler for nodes that
 * we sync to all devices.
 */
const HEDLEY_RESTFUL_ALL_DEVICES = [
  'catchment_area' => 'catchment_areas',
  'clinic' => 'clinics',
  'counseling_schedule' => 'counseling-schedule',
  'counseling_topic' => 'counseling-topics',
  'health_center' => 'health_centers',
  'nurse' => 'nurses',
  'participant_form' => 'participants-form',
  'person' => 'people',
  'pmtct_participant' => 'pmtct-participants',
  'prenatal_participant' => 'prenatal-participants',
  'prenatal_encounter' => 'prenatal-encounters',
  'relationship' => 'relationships',
  'session' => 'sessions',
];

/**
 * Nodes synced to just some devices.
 *
 * The content types and their restful handlers for nodes that
 * we sync to just some devices.
 */
const HEDLEY_RESTFUL_SHARDED = [
  'attendance' => 'attendances',
  'breast_exam' => 'breast-exams',
  'counseling_session' => 'counseling-sessions',
  'core_physical_exam' => 'core-physical-exams',
  'family_planning' => 'family-plannings',
  'height' => 'heights',
  'last_menstrual_period' => 'last-menstrual-periods',
  'medical_history' => 'medical-histories',
  'muac' => 'muacs',
  'nutrition' => 'nutritions',
  'obstetrical_exam' => 'obstetrical-exams',
  'obstetric_history' => 'obstetric-histories',
  'participant_consent' => 'participants-consent',
  'prenatal_family_planning' => 'prenatal-family-plannings',
  'prenatal_nutrition' => 'prenatal-nutritions',
  'social_history' => 'social-histories',
  'photo' => 'photos',
  'vitals' => 'vitals',
  'weight' => 'weights',
];

// Make sure that some headers get set.
if (!drupal_is_cli()) {
  header('Access-Control-Allow-Origin: *');
  header('Access-Control-Allow-Credentials: true');
  header('Access-Control-Allow-Headers: Authorization, access-token, Cache-Control, X-Requested-With, Content-Type');
}

/**
 * Implements hook_file_download_access().
 */
function hedley_restful_file_download_access($file_item, $entity_type, $entity) {
  // If we were given an access token, then use it.
  $request = $_GET;

  if (substr($request['q'], 0, 4) == 'api/') {
    // Don't check requests to /api.
    return FALSE;
  }

  if (empty($request['access_token'])) {
    // No access token provided.
    return FALSE;
  }

  $auth_handler = restful_get_authentication_handler('token');
  if (!$auth_handler->applies($request)) {
    // Auth doesn't apply.
    return FALSE;
  }

  $account = $auth_handler->authenticate($request);
  if (!$account) {
    // Did not authenticate.
    return FALSE;
  }

  // Anyone who can view published content can download.
  return user_access('access content', $account);
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function hedley_restful_ctools_plugin_directory($module, $plugin) {
  if ($module == 'restful') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Convert strings to short form dates.
 *
 * From form "2014-11-13 18:00:00" to
 * preserve just the date part, i.e. "2014-11-13".
 *
 * This is suitable only for values which do not have
 * interesting time zone information ... that is, only
 * for values that represent nominal dates without times.
 *
 * @param string $value
 *   The date string, e.g. "2014-11-13 18:00:00".
 *
 * @return false|string
 *   The date portion only, e.g. "2014-11-13".
 */
function hedley_restful_timestamp_only_date($value) {
  $date = explode(' ', $value);
  return $date[0];
}

/**
 * Get restful output programmatically.
 *
 * @return array
 *   The restful output.
 */
function hedley_restful_output_from_handler($handler_name, array $nids, $account) {
  $output = [];
  node_load_multiple($nids);

  $handler = restful_get_restful_handler($handler_name);
  $handler->setAccount($account);

  foreach ($nids as $nid) {
    $response = $handler->get($nid);
    $output[] = $response[0];
  }

  return $output;
}

/**
 * Get restful output for multiple bundles.
 *
 * @return array
 *   The restful output
 */
function hedley_restful_output_for_bundles($bundleHandlers, array $nids, $account) {
  $output = [];

  foreach ($nids as $nid) {
    $wrapper = entity_metadata_wrapper('node', $nid);

    $handler = restful_get_restful_handler($bundleHandlers[$wrapper->getBundle()]);
    $handler->setAccount($account);
    $response = $handler->get($nid);

    $output[] = $response[0];
  }

  return $output;
}

/**
 * Convert a UUID to a nodeId.
 *
 * @param string $uuid
 *   The UUID.
 *
 * @return int
 *   The Node ID.
 *
 * @throws \RestfulBadRequestException
 */
function hedley_restful_uuid_to_nid($uuid) {
  $result = db_select('field_data_field_uuid', 'uuid')
    ->fields('uuid', ['entity_id'])
    ->condition('uuid.field_uuid_value', $uuid)
    ->execute()
    ->fetchField();

  if (empty($result)) {
    throw new RestfulBadRequestException("Could not find UUID: $uuid");
  }

  return $result;
}

/**
 * Run a query in batches.
 *
 * Given a base query, performs the query in batches and calls a callback
 * function with each batch of results.
 *
 * Before calling the callback for each batch, we do a `noad_load_multiple`,
 * so you don't have to.
 *
 * After the callback returns, we reset the cache for the specific IDs in
 * that batch. So, this is good for cases where you only need to access
 * each entity once, and don't want the cache to grow. (We don't clear the
 * cache completely, so any pre-existing nodes will remain).
 *
 * @param \EntityFieldQuery $base_query
 *   The base query. We will clone this query and adjust the offset to
 *    get the results in batches.
 * @param int $batch_size
 *   The size of each batch.
 * @param callable $function
 *   The callback to execute. It will be called with the three parameters.
 *    - The current offset
 *    - The total number of items.
 *    - An array of node IDs, being the current batch of query results.
 */
function hedley_restful_query_in_batches(\EntityFieldQuery $base_query, $batch_size, callable $function) {
  $offset = 0;

  $query_count = clone $base_query;
  $count = $query_count->count()->execute();

  while ($offset < $count) {
    $query = clone $base_query;
    $result = $query->range($offset, $batch_size)->execute();

    if (empty($result['node'])) {
      // None left.
      return;
    }

    $keys = array_keys($result['node']);
    node_load_multiple($keys);

    call_user_func($function, $offset, $count, $keys);

    $offset += $batch_size;
    entity_get_controller('node')->resetCache($keys);
  }
}
