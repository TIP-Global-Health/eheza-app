<?php

/**
 * @file
 * Code for the RESTful integration.
 */

define('HEDLEY_RESTFUL_CLIENT_SIDE_INDEXEDDB_SCHEMA_VERSION', 7);

/**
 * Nodes synced to all devices.
 *
 * The content types and their restful handler for nodes that
 * we sync to all devices.
 */
const HEDLEY_RESTFUL_ALL_DEVICES = [
  'catchment_area' => 'catchment_areas',
  'clinic' => 'clinics',
  'counseling_schedule' => 'counseling-schedule',
  'counseling_topic' => 'counseling-topics',
  'health_center' => 'health_centers',
  'nurse' => 'nurses',
  'participant_form' => 'participants-form',
  'person' => 'people',
  'pmtct_participant' => 'pmtct-participants',
  'individual_participant' => 'individual-participants',
  'prenatal_encounter' => 'prenatal-encounters',
  'nutrition_encounter' => 'nutrition-encounters',
  'relationship' => 'relationships',
  'session' => 'sessions',
];

/**
 * Nodes synced to just some devices.
 *
 * The content types and their restful handlers for nodes that
 * we sync to just some devices.
 */
const HEDLEY_RESTFUL_SHARDED = [
  'attendance' => 'attendances',
  'breast_exam' => 'breast-exams',
  'counseling_session' => 'counseling-sessions',
  'core_physical_exam' => 'core-physical-exams',
  'danger_signs' => 'danger-signs',
  'family_planning' => 'family-plannings',
  'height' => 'heights',
  'last_menstrual_period' => 'last-menstrual-periods',
  'medical_history' => 'medical-histories',
  'medication' => 'medications',
  'muac' => 'muacs',
  'nutrition' => 'nutritions',
  'obstetrical_exam' => 'obstetrical-exams',
  'obstetric_history' => 'obstetric-histories',
  'obstetric_history_step2' => 'obstetric-histories-step2',
  'participant_consent' => 'participants-consent',
  'prenatal_family_planning' => 'prenatal-family-plannings',
  'prenatal_nutrition' => 'prenatal-nutritions',
  'resource' => 'resources',
  'social_history' => 'social-histories',
  'photo' => 'photos',
  'prenatal_photo' => 'prenatal-photos',
  'vitals' => 'vitals',
  'weight' => 'weights',
];

// Make sure that some headers get set.
if (!drupal_is_cli()) {
  header('Access-Control-Allow-Origin: *');
  header('Access-Control-Allow-Credentials: true');
  header('Access-Control-Allow-Headers: Authorization, access-token, Cache-Control, X-Requested-With, Content-Type');
}

/**
 * Implements hook_file_download_access().
 */
function hedley_restful_file_download_access($file_item, $entity_type, $entity) {
  // If we were given an access token, then use it.
  $request = $_GET;

  if (substr($request['q'], 0, 4) == 'api/') {
    // Don't check requests to /api.
    return FALSE;
  }

  if (empty($request['access_token'])) {
    // No access token provided.
    return FALSE;
  }

  $auth_handler = restful_get_authentication_handler('token');
  if (!$auth_handler->applies($request)) {
    // Auth doesn't apply.
    return FALSE;
  }

  $account = $auth_handler->authenticate($request);
  if (!$account) {
    // Did not authenticate.
    return FALSE;
  }

  // Anyone who can view published content can download.
  return user_access('access content', $account);
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function hedley_restful_ctools_plugin_directory($module, $plugin) {
  if ($module == 'restful') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Convert strings to short form dates.
 *
 * From form "2014-11-13 18:00:00" to
 * preserve just the date part, i.e. "2014-11-13".
 *
 * This is suitable only for values which do not have
 * interesting time zone information ... that is, only
 * for values that represent nominal dates without times.
 *
 * @param string $value
 *   The date string, e.g. "2014-11-13 18:00:00".
 *
 * @return false|string
 *   The date portion only, e.g. "2014-11-13".
 */
function hedley_restful_timestamp_only_date($value) {
  $date = explode(' ', $value);
  return $date[0];
}

/**
 * Get restful output programmatically.
 *
 * @return array
 *   The restful output.
 */
function hedley_restful_output_from_handler($handler_name, array $nids, $account) {
  $output = [];
  node_load_multiple($nids);

  $handler = restful_get_restful_handler($handler_name);
  $handler->setAccount($account);

  foreach ($nids as $nid) {
    $response = $handler->get($nid);
    $output[] = $response[0];
  }

  return $output;
}

/**
 * Get restful output for multiple bundles.
 *
 * @return array
 *   The restful output
 */
function hedley_restful_output_for_bundles($bundleHandlers, array $nids, $account) {
  $output = [];

  foreach ($nids as $nid) {
    $wrapper = entity_metadata_wrapper('node', $nid);

    $handler = restful_get_restful_handler($bundleHandlers[$wrapper->getBundle()]);
    $handler->setAccount($account);
    $response = $handler->get($nid);

    $output[] = $response[0];
  }

  return $output;
}

/**
 * Resolve node ID using provided UUID.
 *
 * @param string $uuid
 *   The UUID.
 *
 * @return int
 *   The Node ID. False, if not found.
 */
function hedley_restful_resolve_nid_for_uuid($uuid) {
  $result = db_select('field_data_field_uuid', 'uuid')
    ->fields('uuid', ['entity_id'])
    ->condition('uuid.field_uuid_value', $uuid)
    ->execute()
    ->fetchField();

  return empty($result) ? FALSE : $result;
}

/**
 * Convert a UUID to a node ID.
 *
 * @param string $uuid
 *   The UUID.
 *
 * @return int
 *   The Node ID.
 *
 * @throws \RestfulBadRequestException
 */
function hedley_restful_uuid_to_nid($uuid) {
  $result = hedley_restful_resolve_nid_for_uuid($uuid);

  if ($result === FALSE) {
    throw new RestfulBadRequestException("Could not find UUID: $uuid");
  }

  return $result;
}

/**
 * Run a query in batches.
 *
 * Given a base query, performs the query in batches and calls a callback
 * function with each batch of results.
 *
 * Before calling the callback for each batch, we do a `noad_load_multiple`,
 * so you don't have to.
 *
 * After the callback returns, we reset the cache for the specific IDs in
 * that batch. So, this is good for cases where you only need to access
 * each entity once, and don't want the cache to grow. (We don't clear the
 * cache completely, so any pre-existing nodes will remain).
 *
 * @param \EntityFieldQuery $base_query
 *   The base query. We will clone this query and adjust the offset to
 *    get the results in batches.
 * @param int $batch_size
 *   The size of each batch.
 * @param callable $function
 *   The callback to execute. It will be called with the three parameters.
 *    - The current offset
 *    - The total number of items.
 *    - An array of node IDs, being the current batch of query results.
 */
function hedley_restful_query_in_batches(\EntityFieldQuery $base_query, $batch_size, callable $function) {
  $offset = 0;

  $query_count = clone $base_query;
  $count = $query_count->count()->execute();

  while ($offset < $count) {
    $query = clone $base_query;
    $result = $query->range($offset, $batch_size)->execute();

    if (empty($result['node'])) {
      // None left.
      return;
    }

    $keys = array_keys($result['node']);
    node_load_multiple($keys);

    call_user_func($function, $offset, $count, $keys);

    $offset += $batch_size;
    entity_get_controller('node')->resetCache($keys);
  }
}

/**
 * Join a field to a DB Select query, and add its main value.
 *
 * @param SelectQuery $query
 *   Query to join to.
 * @param string $entity_type
 *   Type of the host entity of the field. Or NULL to avoid filtering the field
 *   table by entity type.
 * @param string $field_name
 *   Field name.
 * @param bool $require
 *   Whether filter out rows where this field would be NULL.
 * @param string $entity_id_selector
 *   SQL selector for the column by which the field is joined. The entity ID is
 *   used by default.
 * @param string $field_alias
 *   The field alias.
 *
 * @throws Exception
 */
function hedley_restful_join_field_to_query(SelectQuery $query, $entity_type, $field_name, $require = TRUE, $entity_id_selector = NULL, $field_alias = NULL, $second_value = FALSE) {
  $field = field_info_field($field_name);
  $table_name = _field_sql_storage_tablename($field);

  if (!$entity_id_selector) {
    if (!$entity_type) {
      throw new Exception('Entity type is required when ID selector is not specified');
    }
    // Set default entity ID selector.
    switch ($entity_type) {
      case 'user':
        $entity_id_selector = 'users.uid';
        break;

      case 'node':
        $entity_id_selector = 'node.nid';
        break;

      default:
        throw new Exception(format_string('hedley_general_join_field_to_query() is not implemented for entity_type: "@type"', ['@type' => $entity_type]));
    }
  }

  switch ($field['type']) {
    case 'entityreference':
      $column_suffix = 'target_id';
      break;

    case 'image':
    case 'file':
      $column_suffix = 'fid';
      break;

    default:
      $column_suffix = 'value';

  }

  $field_alias = $field_alias ?: $field_name;
  $query->addField($field_alias, $field_name . '_' . $column_suffix, $field_alias);
  if ($second_value) {
    $column_suffix = 'value2';
    $query->addField($field_alias, $field_name . '_' . $column_suffix, $field_alias);
  }

  $join = $require ? 'innerJoin' : 'leftJoin';
  $arguments = [':type' => $entity_type];
  $conditions[] = "$entity_id_selector = $field_alias.entity_id";
  if ($entity_type) {
    $conditions[] = "$field_alias.entity_type = :type";
  }

  $query->$join($table_name, $field_alias, implode(' AND ', $conditions), $arguments);

}
