<?php

/**
 * @file
 * Code for the Hedley General feature.
 */

/**
 * Creating a new AQ task of a specific queue if not exist.
 *
 * @param string $machine_name
 *   The machine name of the queue.
 * @param int|string $unique_id
 *   An arbitrary ID to avoid duplicating tasks.
 * @param array $data
 *   The data to add to the AQ task.
 * @param array $statuses
 *   Optional; The task statuses which considered as exist.
 *
 * @return int
 *   Task ID, if created successfully.
 */
function hedley_general_add_task_to_advanced_queue_by_id($machine_name, $unique_id, array $data, array $statuses = [
  ADVANCEDQUEUE_STATUS_QUEUED,
  ADVANCEDQUEUE_STATUS_PROCESSING,
]) {
  // Make sure a task with the same ID doesn't exist already in the given
  // queue, using the queue machine name as a prefix.
  // (the `$task_title` us being used as a unique ID for the given queue).
  $task_title = $machine_name . '_' . $unique_id;
  if (hedley_general_advanced_queue_task_exists($machine_name, $task_title, $statuses)) {
    // Prevent from flooding the queue.
    return FALSE;
  }

  return hedley_general_add_task_to_advanced_queue($machine_name, ['title' => $task_title] + $data);
}

/**
 * Check whether a specific task exist and not processed yet.
 *
 * @param string $queue_machine_name
 *   The machine name of the queue.
 * @param string $title
 *   The title of the task to search.
 * @param array $statuses
 *   The statuses to filter by.
 *
 * @return bool
 *   TRUE if the task exist and not processed yet, otherwise returns FALSE.
 */
function hedley_general_advanced_queue_task_exists($queue_machine_name, $title, array $statuses = [
  ADVANCEDQUEUE_STATUS_QUEUED,
  ADVANCEDQUEUE_STATUS_PROCESSING,
]) {
  return (bool) db_select('advancedqueue', 'a')
    ->fields('a')
    ->condition('name', $queue_machine_name)
    ->condition('title', $title)
    ->condition('status', $statuses, 'IN')
    ->countQuery()
    ->execute()
    ->fetchField();
}

/**
 * Add a new task to a specific advanced queue.
 *
 * @param string $queue_machine_name
 *   The machine name of the queue.
 * @param array $task_arguments
 *   The arguments we should pass to the task.
 *
 * @return int
 *   The new advancedqueue_item ID.
 */
function hedley_general_add_task_to_advanced_queue($queue_machine_name, array $task_arguments) {
  // Get the requested queue.
  $queue = new AdvancedQueue($queue_machine_name);

  $task = [
    'timestamp' => REQUEST_TIME,
  ];

  $task += $task_arguments;

  $item_id = $queue->createItem($task);

  if (!$item_id) {
    $args = [
      '@name' => $queue_machine_name,
      '@args' => serialize($task),
    ];
    drupal_set_message(format_string('Failed to create AQ job for queue "@name". Item arguments: "@args"', $args), 'error');
  }

  return $item_id;
}

/**
 * Get the AQ Item ID by name.
 *
 * @param string $item_title
 *   The unique AQ Item name.
 * @param bool $all_status
 *   Determine if AQ of any status should be retrieved. Defaults to FALSE.
 *
 * @return bool|int
 *   FALSE if no Advanced queue Item is found, otherwise its ID.
 */
function hedley_general_get_aq_item_by_title($item_title, $all_status = FALSE) {
  $status = [
    ADVANCEDQUEUE_STATUS_QUEUED,
    ADVANCEDQUEUE_STATUS_FAILURE_RETRY,
  ];

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'advancedqueue_item')
    ->propertyCondition('title', $item_title);

  if (!$all_status) {
    $query->propertyCondition('status', $status, 'IN');
  }

  $result = $query
    // Get the latest one.
    ->propertyOrderBy('item_id', 'DESC')
    ->range(0, 1)
    ->execute();

  return !empty($result['advancedqueue_item']) ? key($result['advancedqueue_item']) : FALSE;
}

/**
 * Returns a list of measurements IDs that were taken during certain encounter.
 *
 * @param int $encounter_id
 *   ID of individual encounter.
 * @param string $encounter_type
 *   Type of individual encounter.
 *
 * @return array
 *   List of measurements IDs.
 */
function hedley_general_get_individual_encounter_measurements($encounter_id, $encounter_type) {
  $types = [
    'acute_illness',
    'nutrition',
    'prenatal',
  ];

  if (!in_array($encounter_type, $types)) {
    return [];
  }

  $table = "{field_data_field_{$encounter_type}_encounter}";
  $target_field = "field_{$encounter_type}_encounter_target_id";

  $query = db_select($table, 't');
  $query->addField('t', 'entity_id');
  $query->condition($target_field, $encounter_id);

  return $query->execute()->fetchCol();
}

/**
 * Returns a list of measurements IDs that were taken for certain person.
 *
 * @param int $person_id
 *   The ID of person we query for measurements.
 * @param array $measurement_types
 *   List of content types that are considered as measurements.
 *
 * @return array
 *   List of measurements IDs.
 */
function hedley_general_get_person_measurements($person_id, array $measurement_types) {
  $query = db_select('field_data_field_person', 't');
  $query->addField('t', 'entity_id');
  $query->condition('bundle', $measurement_types, 'IN');
  $query->condition('field_person_target_id', $person_id);

  return $query->execute()->fetchCol();
}

/**
 * Returns list of content types that are considered as measurements.
 *
 * We return both group and individual encounters measurements.
 *
 * @return array
 *   List of content types that are considered as measurements.
 */
function hedley_general_get_measurement_types() {
  $measurement_types = [];
  $content_types = array_keys(node_type_get_types());

  foreach ($content_types as $type) {
    $fields = hedley_general_get_content_type_fields($type);

    // Group encounter measurements got the 'session' field.
    // Individual encounter measurements measurements got named field.
    $measurement_indicator_fields = [
      'field_session',
      'field_nutrition_encounter',
      'field_prenatal_encounter',
      'field_acute_illness_encounter',
    ];

    foreach ($measurement_indicator_fields as $indicator) {
      if (in_array($indicator, $fields)) {
        $measurement_types[] = $type;
        break;
      }
    }
  }

  return $measurement_types;
}

/**
 * Returns list of fields names on certain content type.
 *
 * @param string $type
 *   Content type bundle.
 *
 * @return array
 *   List of fields names.
 */
function hedley_general_get_content_type_fields($type) {
  $query = db_select('field_config_instance', 'ci');
  $query->addField('ci', 'field_name');
  $query->condition('bundle', $type);

  return $query->execute()->fetchCol();
}
