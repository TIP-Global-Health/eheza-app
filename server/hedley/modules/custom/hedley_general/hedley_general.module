<?php

/**
 * @file
 * Code for the Hedley General feature.
 */

/**
 * Creating a new AQ task of a specific queue if not exist.
 *
 * @param string $machine_name
 *   The machine name of the queue.
 * @param int|string $unique_id
 *   An arbitrary ID to avoid duplicating tasks.
 * @param array $data
 *   The data to add to the AQ task.
 * @param array $statuses
 *   Optional; The task statuses which considered as exist.
 *
 * @return int
 *   Task ID, if created successfully.
 */
function hedley_general_add_task_to_advanced_queue_by_id($machine_name, $unique_id, array $data, array $statuses = [
  ADVANCEDQUEUE_STATUS_QUEUED,
  ADVANCEDQUEUE_STATUS_PROCESSING,
]) {
  // Make sure a task with the same ID doesn't exist already in the given
  // queue, using the queue machine name as a prefix.
  // (the `$task_title` us being used as a unique ID for the given queue).
  $task_title = $machine_name . '_' . $unique_id;
  if (hedley_general_advanced_queue_task_exists($machine_name, $task_title, $statuses)) {
    // Prevent from flooding the queue.
    return FALSE;
  }

  return hedley_general_add_task_to_advanced_queue($machine_name, ['title' => $task_title] + $data);
}

/**
 * Check whether a specific task exists, and not yet / being processed.
 *
 * @param string $queue_machine_name
 *   The machine name of the queue.
 * @param string $title
 *   The title of the task to search.
 * @param array $statuses
 *   The statuses to filter by.
 *
 * @return bool
 *   TRUE if the task exists and not and not yet / being processed.
 */
function hedley_general_advanced_queue_task_exists($queue_machine_name, $title, array $statuses = [
  ADVANCEDQUEUE_STATUS_QUEUED,
  ADVANCEDQUEUE_STATUS_PROCESSING,
]) {
  $tasks = db_select('advancedqueue', 'aq')
    ->fields('aq', ['item_id', 'status', 'created'])
    ->condition('title', $title)
    ->condition('name', $queue_machine_name)
    ->condition('status', $statuses, 'IN')
    ->range(0, 100)
    ->execute()
    ->fetchAll();

  foreach ($tasks as $task) {
    if ($task->status == ADVANCEDQUEUE_STATUS_QUEUED) {
      // Task did not start processing.
      return TRUE;
    }

    if ($task->status == ADVANCEDQUEUE_STATUS_PROCESSING) {
      if (time() - $task->created < variable_get('hedley_aq_task_max_processing_period', 20 * 60)) {
        // Task is being processed, and did not exceed allowed time period,
        // which is set to 20 minutes, by default.
        return TRUE;
      }
    }
  }

  return FALSE;
}

/**
 * Add a new task to a specific advanced queue.
 *
 * @param string $queue_machine_name
 *   The machine name of the queue.
 * @param array $task_arguments
 *   The arguments we should pass to the task.
 *
 * @return int
 *   The new advancedqueue_item ID.
 */
function hedley_general_add_task_to_advanced_queue($queue_machine_name, array $task_arguments) {
  // Get the requested queue.
  $queue = new AdvancedQueue($queue_machine_name);

  $task = [
    'timestamp' => REQUEST_TIME,
  ];

  $task += $task_arguments;

  $item_id = $queue->createItem($task);

  if (!$item_id) {
    $args = [
      '@name' => $queue_machine_name,
      '@args' => serialize($task),
    ];
    drupal_set_message(format_string('Failed to create AQ job for queue "@name". Item arguments: "@args"', $args), 'error');
  }

  return $item_id;
}

/**
 * Get the AQ Item ID by name.
 *
 * @param string $item_title
 *   The unique AQ Item name.
 * @param bool $all_status
 *   Determine if AQ of any status should be retrieved. Defaults to FALSE.
 *
 * @return bool|int
 *   FALSE if no Advanced queue Item is found, otherwise its ID.
 */
function hedley_general_get_aq_item_by_title($item_title, $all_status = FALSE) {
  $status = [
    ADVANCEDQUEUE_STATUS_QUEUED,
    ADVANCEDQUEUE_STATUS_FAILURE_RETRY,
  ];

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'advancedqueue_item')
    ->propertyCondition('title', $item_title);

  if (!$all_status) {
    $query->propertyCondition('status', $status, 'IN');
  }

  $result = $query
    // Get the latest one.
    ->propertyOrderBy('item_id', 'DESC')
    ->range(0, 1)
    ->execute();

  return !empty($result['advancedqueue_item']) ? key($result['advancedqueue_item']) : FALSE;
}

/**
 * Returns a list of measurements IDs that were taken during certain encounter.
 *
 * @param int $encounter_id
 *   ID of individual encounter.
 * @param string $encounter_type
 *   Type of individual encounter.
 *
 * @return array
 *   List of measurements IDs.
 */
function hedley_general_get_individual_encounter_measurements($encounter_id, $encounter_type) {
  $types = [
    'acute_illness',
    'nutrition',
    'prenatal',
  ];

  if (!in_array($encounter_type, $types)) {
    return [];
  }

  $table = "{field_data_field_{$encounter_type}_encounter}";
  $target_field = "field_{$encounter_type}_encounter_target_id";

  $query = db_select($table, 't');
  $query->addField('t', 'entity_id');
  $query->condition($target_field, $encounter_id);

  return $query->execute()->fetchCol();
}

/**
 * Returns a list of measurements IDs that were taken for certain person.
 *
 * @param int $person_id
 *   The ID of person we query for measurements.
 * @param array $measurement_types
 *   Optional; List of content types that are considered as measurements.
 *
 * @return array
 *   List of measurements IDs.
 */
function hedley_general_get_person_measurements($person_id, array $measurement_types = []) {
  if (empty($measurement_types)) {
    $measurement_types = hedley_general_get_measurement_types();
  }

  $query = db_select('field_data_field_person', 't');
  $query->addField('t', 'entity_id');
  $query->condition('bundle', $measurement_types, 'IN');
  $query->condition('field_person_target_id', $person_id);

  return $query->execute()->fetchCol();
}

/**
 * Returns list of content types that are considered as measurements.
 *
 * We return both group and individual encounters measurements.
 *
 * @return array
 *   List of content types that are considered as measurements.
 */
function hedley_general_get_measurement_types() {
  $measurement_types = [];
  $content_types = array_keys(node_type_get_types());

  foreach ($content_types as $type) {
    $fields = hedley_general_get_content_type_fields($type);

    // Group encounter measurements got the 'session' field.
    // Individual encounter measurements got encounter type field.
    $measurement_indicator_fields = [
      'field_session',
      'field_nutrition_encounter',
      'field_prenatal_encounter',
      'field_acute_illness_encounter',
      'field_home_visit_encounter',
      'field_well_child_encounter',
    ];

    foreach ($measurement_indicator_fields as $indicator) {
      if (in_array($indicator, $fields)) {
        $measurement_types[] = $type;
        break;
      }
    }
  }

  return $measurement_types;
}

/**
 * Returns list of fields names on certain content type.
 *
 * @param string $type
 *   Content type bundle.
 *
 * @return array
 *   List of fields names.
 */
function hedley_general_get_content_type_fields($type) {
  $query = db_select('field_config_instance', 'ci');
  $query->addField('ci', 'field_name');
  $query->condition('bundle', $type);

  return $query->execute()->fetchCol();
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Add to a query which to get all entities that have field_deleted set
 * to False, or not set at all (an indication that entity is not deleted).
 */
function hedley_general_query_exclude_deleted_alter(QueryAlterableInterface $query) {
  $query->leftJoin('field_data_field_deleted', 'fd', 'node.nid = fd.entity_id');
  $or = db_or()
    ->isNull('fd.field_deleted_value')
    ->condition('fd.field_deleted_value', FALSE);
  $query->condition($or);
}

/**
 * Join a field to a DB Select query, and add its main value.
 *
 * @param SelectQuery $query
 *   Query to join to.
 * @param string $entity_type
 *   Type of the host entity of the field. Or NULL to avoid filtering the field
 *   table by entity type.
 * @param string $field_name
 *   Field name.
 * @param bool $require
 *   Whether filter out rows where this field would be NULL.
 * @param string $entity_id_selector
 *   SQL selector for the column by which the field is joined. The entity ID is
 *   used by default.
 * @param string $field_alias
 *   The field alias.
 *
 * @throws Exception
 */
function hedley_general_join_field_to_query(SelectQuery $query, $entity_type, $field_name, $require = TRUE, $entity_id_selector = NULL, $field_alias = NULL, $second_value = FALSE) {
  $field = field_info_field($field_name);
  $table_name = _field_sql_storage_tablename($field);

  if (!$entity_id_selector) {
    if (!$entity_type) {
      throw new Exception('Entity type is required when ID selector is not specified');
    }
    // Set default entity ID selector.
    switch ($entity_type) {
      case 'user':
        $entity_id_selector = 'users.uid';
        break;

      case 'node':
        $entity_id_selector = 'node.nid';
        break;

      default:
        throw new Exception(format_string(' hedley_general_join_field_to_query() is not implemented for entity_type: "@type"', ['@type' => $entity_type]));
    }
  }

  switch ($field['type']) {
    case 'entityreference':
      $column_suffix = 'target_id';
      break;

    case 'image':
    case 'file':
      $column_suffix = 'fid';
      break;

    default:
      $column_suffix = 'value';
  }

  $field_alias = $field_alias ?: $field_name;
  $query->addField($field_alias, $field_name . '_' . $column_suffix, $field_alias);
  if ($second_value) {
    $column_suffix = 'value2';
    $query->addField($field_alias, $field_name . '_' . $column_suffix, $field_alias);
  }

  $join = $require ? 'innerJoin' : 'leftJoin';
  $arguments = [':type' => $entity_type];
  $conditions[] = "$entity_id_selector = $field_alias.entity_id";
  if ($entity_type) {
    $conditions[] = "$field_alias.entity_type = :type";
  }

  $query->$join($table_name, $field_alias, implode(' AND ', $conditions), $arguments);
}

/**
 * Resolve a shard based on HC field of the node.
 *
 * @param int $nid
 *   The node ID.
 *
 * @return int|bool
 *   Node ID of the shard. False, if shard wasn't successfully resolved.
 */
function hedley_general_shard_by_health_center($nid) {
  // We have this check to allow SimpleTest to pass.
  if (!$nid) {
    return FALSE;
  }

  $wrapper = entity_metadata_wrapper('node', $nid);
  if (!isset($wrapper->field_health_center)) {
    return FALSE;
  }
  $shard = $wrapper->field_health_center->getIdentifier();

  return !empty($shard) ? $shard : FALSE;
}

/**
 * Resolve shards based on Person field of the node.
 *
 * @param int $nid
 *   The node ID.
 *
 * @return array
 *   List of shards node IDs. Empty array, if none are found.
 */
function hedley_general_shards_by_person($nid) {
  // We have this check to allow SimpleTest to pass.
  if (!$nid) {
    return [];
  }

  $wrapper = entity_metadata_wrapper('node', $nid);
  if (!isset($wrapper->field_shards)) {
    return [];
  }
  $shards = $wrapper->field_shards->value(['identifier' => TRUE]);

  return !empty($shards) ? $shards : [];
}
