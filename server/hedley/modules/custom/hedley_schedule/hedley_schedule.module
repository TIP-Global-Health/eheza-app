<?php

/**
 * @file
 * Code for the Hedley Schedule feature.
 */

include_once 'hedley_schedule.features.inc';

/**
 * Indicate whether to create a revision.
 *
 * Invoked from hedley_device_node_presave.
 *
 * @param object $node
 *   The node being saved.
 *
 * @return bool
 *   TRUE if we should make a revision.
 */
function hedley_schedule_create_revision($node) {
  return in_array($node->type, [
    'catchment_area',
    'clinic',
    'health_center',
    'session',
  ]);
}

/**
 * Implements hook_node_presave().
 *
 * @throws \Exception
 *   Doesn't allow saving a session if there's already a session with the same
 *   clinic and start date.
 */
function hedley_schedule_node_presave($node) {
  if ($node->type != 'session') {
    // Handles only "session" nodes saves.
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $clinic_node = $wrapper->field_clinic->value();
  $scheduled_dates = $wrapper->field_scheduled_date->value();

  if (empty($clinic_node) || empty($scheduled_dates)) {
    // No clinic or dates are available.
    return;
  }

  if (!hedley_schedule_clinic_has_sessions($clinic_node->nid, $scheduled_dates['value'])) {
    // No sessions found.
    return;
  }

  if ($sessions_nids = hedley_schedule_clinic_get_sessions_by_date($clinic_node->nid, $scheduled_dates['value'])) {
    foreach ($sessions_nids as $session_nid) {
      if ($session_nid != $node->nid) {
        throw new Exception('This session cannot be saved, there is already a session with the same starting date and same clinic.');
      }
    }
  }

  // When unpublishing a "session" node, check if it's a training session and
  // unpublish all its measurements if it is. Otherwise, don't let it be
  // unpublished.
  if (empty($node->original)) {
    // This isn't a modification.
    return;
  }

  if (($node->status != NODE_NOT_PUBLISHED) || ($node->original->status != NODE_PUBLISHED)) {
    // We're not unpublishing the node.
    return;
  }

  // The measurements content types.
  $measurement_types = hedley_activity_get_measurements_content_types();

  // We need to unpublsh the session's measurements if the session is valid for
  // being unpublished.
  if ($wrapper->field_training->value()) {
    foreach ($measurement_types as $measurement_type) {
      $nids = hedley_activity_get_measurements_by_session($wrapper->getIdentifier(), $measurement_type);
      $nodes = node_load_multiple($nids);
      foreach ($nodes as $node) {
        $node->status = NODE_NOT_PUBLISHED;
        node_save($node);
      }
    }
  }
  else {
    foreach ($measurement_types as $measurement_type) {
      $has_measurements = !empty(hedley_activity_get_measurements_by_session($wrapper->getIdentifier(), $measurement_type));

      if ($has_measurements) {
        throw new Exception('This session cannot be unpublished because it has existing measurements');
      }
    }
  }
}

/**
 * Check if a clinic has sessions for a specific dates.
 *
 * @param int $clinic_nid
 *   The clinic node ID.
 * @param string $scheduled_starting_date
 *   The starting date for the session.
 *
 * @return int
 *   The count of sessions.
 */
function hedley_schedule_clinic_has_sessions($clinic_nid, $scheduled_starting_date) {
  $query = new EntityFieldQuery();

  return $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'session')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_clinic', 'target_id', $clinic_nid)
    ->fieldCondition('field_scheduled_date', 'value', $scheduled_starting_date)
    ->count()
    ->execute();
}

/**
 * Get a clinic sessions by the starting date.
 *
 * @param int $clinic_nid
 *   The clinic node ID.
 * @param string $scheduled_starting_date
 *   The starting date.
 * @param int $range
 *   Optional; Range of nodes to get.
 *
 * @return array|null
 *   Node IDs if they exist or nothing if no nodes exist.
 */
function hedley_schedule_clinic_get_sessions_by_date($clinic_nid, $scheduled_starting_date, $range = 1) {
  $query = new EntityFieldQuery();

  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'session')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_clinic', 'target_id', $clinic_nid)
    ->fieldCondition('field_scheduled_date', 'value', $scheduled_starting_date)
    ->range(0, $range)
    ->execute();

  return !empty($result['node']) ? array_keys($result['node']) : NULL;
}
