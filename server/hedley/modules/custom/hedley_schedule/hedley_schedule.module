<?php

/**
 * @file
 * Code for the Hedley Schedule feature.
 */

include_once 'hedley_schedule.features.inc';

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Hide title from the "counseling" node form because we set it programmatically
 * after in the presave.
 *
 * @see hedley_schedule_node_presave()
 */
function hedley_schedule_form_counseling_node_form_alter(&$form, &$form_state) {
  $form['title']['#access'] = FALSE;
}

/**
 * Implements hook_node_presave().
 *
 * @throws \Exception
 *   Doesn't allow saving a session if there's already a session with the same
 *   clinic and start date.
 */
function hedley_schedule_node_presave($node) {
  if ($node->type == 'session') {
    // Handles only "session" nodes saves.
    $wrapper = entity_metadata_wrapper('node', $node);
    $clinic_node = $wrapper->field_clinic->value();
    $scheduled_dates = $wrapper->field_scheduled_date->value();

    if (empty($clinic_node) || empty($scheduled_dates)) {
      // No clinic or dates are available.
      return;
    }

    if (!hedley_schedule_clinic_has_sessions($clinic_node->nid, $scheduled_dates['value'])) {
      // No sessions found.
      return;
    }

    if ($sessions_nids = hedley_schedule_clinic_get_sessions_by_date($clinic_node->nid, $scheduled_dates['value'])) {
      foreach ($sessions_nids as $session_nid) {
        if ($session_nid != $node->nid) {
          throw new Exception('This session cannot be saved, there is already a session with the same starting date and same clinic.');
        }
      }
    }
  }

  if ($node->type == 'counseling') {
    // Handles only "counseling" nodes saves.
    if ($node->title) {
      // No need to set title if it exists.
      return;
    }

    $wrapper = entity_metadata_wrapper('node', $node);
    if (!$child_name = $wrapper->field_child->value()) {
      // Don't set the title if the child is empty, something is wrong, set a
      // message.
      drupal_set_message(t('The counseling node cannot be without a child reference.'), 'error');
      return;
    }

    $child_name = $wrapper->field_child->label();
    $title = "Counseling session for $child_name";

    $wrapper->title->set($title);
  }
}

/**
 * Implements hook_node_delete().
 *
 * When deleting a "session" node, check if it's a training session and delete
 * all it's measurements if it is, if not, then we check if it has any
 * measurements at all and stop the deletion request if it does.
 *
 * @throws \Exception
 *   Doesn't allow deleting a session if it's not a training session and it has
 *   any measurements at all.
 */
function hedley_schedule_node_delete($node) {
  if ($node->type != 'session') {
    // Handles only "session" nodes deletions.
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $session_nid = $wrapper->getIdentifier();

  // The measurements content types.
  $measurement_types = hedley_activity_get_measurements_content_types();

  // We need to delete the sessions measurements if the session is valid for
  // deletion.
  if ($wrapper->field_training->value()) {
    $measurement_nodes = [];
    foreach ($measurement_types as $measurement_type) {
      if ($add_measurement_nodes = hedley_activity_get_measurements_by_session($session_nid, $measurement_type)) {
        $measurement_nodes = array_merge($add_measurement_nodes, $measurement_nodes);
      }
    }

    node_delete_multiple($measurement_nodes);
  }
  else {
    foreach ($measurement_types as $measurement_type) {
      $has_measurements = !empty(hedley_activity_get_measurements_by_session($wrapper->getIdentifier(), $measurement_type));

      if ($has_measurements) {
        throw new Exception('This session cannot be deleted because it has existing measurements');
      }
    }
  }
}

/**
 * Check if a clinic has sessions for a specific dates.
 *
 * @param int $clinic_nid
 *   The clinic node ID.
 * @param string $scheduled_starting_date
 *   The starting date for the session.
 *
 * @return int
 *   The count of sessions.
 */
function hedley_schedule_clinic_has_sessions($clinic_nid, $scheduled_starting_date) {
  $query = new EntityFieldQuery();

  return $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'session')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_clinic', 'target_id', $clinic_nid)
    ->fieldCondition('field_scheduled_date', 'value', $scheduled_starting_date)
    ->count()
    ->execute();
}

/**
 * Get a clinic sessions by the starting date.
 *
 * @param int $clinic_nid
 *   The clinic node ID.
 * @param string $scheduled_starting_date
 *   The starting date.
 * @param int $range
 *   Optional; Range of nodes to get.
 *
 * @return array|null
 *   Node IDs if they exist or nothing if no nodes exist.
 */
function hedley_schedule_clinic_get_sessions_by_date($clinic_nid, $scheduled_starting_date, $range = 1) {
  $query = new EntityFieldQuery();

  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'session')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_clinic', 'target_id', $clinic_nid)
    ->fieldCondition('field_scheduled_date', 'value', $scheduled_starting_date)
    ->range(0, $range)
    ->execute();

  return !empty($result['node']) ? array_keys($result['node']) : NULL;
}

/**
 * Get session entities scheduled for today.
 *
 * @param int $range
 *   Optional; Range of nodes to get.
 *
 * @return array|null
 *   Node IDs if they exist or nothing if no nodes exist.
 */
function hedley_schedule_get_today_sessions($range = 50) {
  $today = date('Y-m-d');

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'session')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_scheduled_date', 'value', $today)
    ->range(0, $range)
    ->execute();

  return !empty($result['node']) ? array_keys($result['node']) : NULL;
}
