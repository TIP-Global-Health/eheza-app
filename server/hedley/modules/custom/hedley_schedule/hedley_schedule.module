<?php

/**
 * @file
 * Code for the Hedley Schedule feature.
 */

define('HEDLEY_SCHEDULE_MEASUREMENT_CONTENT_TYPES', [
  'family_planning',
  'height',
  'muac',
  'nutrition',
  'photo',
  'weight',
]);

include_once 'hedley_schedule.features.inc';

/**
 * Implements hook_node_presave().
 *
 * @throws \Exception
 *   Doesn't allow saving a session if there's already a session with the same
 *   clinic and start date.
 */
function hedley_schedule_node_presave($node) {
  if ($node->type != 'session') {
    // Handles only "session" nodes saves.
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $clinic = $wrapper->field_clinic->value();
  $scheduled_dates = $wrapper->field_scheduled_date->value();

  $filter_fields = [
    'field_clinic' => [
      'column' => 'target_id',
      'value' => $clinic->nid,
    ],
    'field_scheduled_date' => [
      'column' => 'value',
      'value' => $scheduled_dates['value'],
    ],
  ];

  if (!empty(hedley_schedule_get_sessions(1, $filter_fields))) {
    throw new Exception('This session cannot be saved, there is already a session with the same starting date and same clinic.');
  }
}

/**
 * Implements hook_node_delete().
 *
 * When deleting a "session" node, check if it's a training session and delete
 * all it's measurements if it is, if not, then we check if it has any
 * measurements at all and stop the deletion request if it does.
 *
 * @throws \Exception
 *   Doesn't allow deleting a session if it's not a training session and it has
 *   any measurements at all.
 */
function hedley_schedule_node_delete($node) {
  if ($node->type != 'session') {
    // Handles only "session" nodes deletions.
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $session_nid = $wrapper->getIdentifier();
  // We need to delete the sessions measurements if the session is valid for
  // deletion.
  if ($wrapper->field_training->value()) {
    foreach (HEDLEY_SCHEDULE_MEASUREMENT_CONTENT_TYPES as $measurement_type) {
      $measurement_nodes = hedley_activity_get_measurements_entities_by_session($session_nid, $measurement_type);
      node_delete_multiple($measurement_nodes);
    }
  }
  else {
    foreach (HEDLEY_SCHEDULE_MEASUREMENT_CONTENT_TYPES as $measurement_type) {
      $has_measurements = !empty(hedley_activity_get_measurements_entities_by_session($wrapper->getIdentifier(), $measurement_type)) ? TRUE : FALSE;

      if ($has_measurements) {
        throw new Exception('This session cannot be deleted because it has existing measurements');
      }
    }
  }
}

/**
 * Get sessions with a range and with the option of filtering by fields.
 *
 * This API function gives the option to filter by any field in the content
 * type.
 *
 * @param $range
 *   The desired range for the entities.
 * @param array $fields
 *   The filtering fields, example of usage:
 *   [
 *    'field_name' => [
 *    'column' => 'value',
 *    'value' => 'foo',
 *   ]
 *
 * @return array|null
 *   Node IDs if they exist or nothing if no nodes exist.
 */
function hedley_schedule_get_sessions($range, array $fields = []) {
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'session')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->range(0, $range);

  if (!empty($fields)) {
    foreach ($fields as $field_name => $field) {
      $query->fieldCondition($field_name, $field['column'], $field['value']);
    }
  }

  $result = $query->execute();

  return !empty($result['node']) ? array_keys($result['node']) : NULL;
}
