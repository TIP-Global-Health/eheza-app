<?php

/**
 * @file
 * Code for the Hedley Reports feature.
 */

include_once 'hedley_reports.features.inc';

/**
 * @file
 * Code for the Hedley Reports feature.
 */

define('HEDLEY_REPORTS_CALCULATE_AGGREGATED_DATA', 'hedley_reports_calculate_reports_data');

const RDT_POSITIVE_VALUES = ['positive', 'positive-and-pregnant'];

/**
 * Implements hook_menu().
 */
function hedley_reports_menu() {
  $items['admin/reports/statistical-queries'] = array(
    'title' => 'Statistical Queries',
    'description' => 'View Statistical Queries',
    'page callback' => 'hedley_reports_statistical_queries_report_callback_menu',
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/statistical-queries/all'] = array(
    'title' => 'Entire Population',
    'description' => 'View report for Entire Population',
    'page callback' => 'hedley_reports_statistical_queries_report_callback_global',
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/statistical-queries/demographics/%'] = array(
    'title' => 'Province',
    'description' => 'View report for province',
    'page callback' => 'hedley_reports_statistical_queries_report_callback_province',
    'page arguments' => [4],
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/statistical-queries/demographics/%/%'] = array(
    'title' => 'District',
    'description' => 'View report for district',
    'page callback' => 'hedley_reports_statistical_queries_report_callback_district',
    'page arguments' => [4, 5],
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/statistical-queries/demographics/%/%/%'] = array(
    'title' => 'Sector',
    'description' => 'View report for sector',
    'page callback' => 'hedley_reports_statistical_queries_report_callback_sector',
    'page arguments' => [4, 5, 6],
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/statistical-queries/demographics/%/%/%/%'] = array(
    'title' => 'Cell',
    'description' => 'View report for cell',
    'page callback' => 'hedley_reports_statistical_queries_report_callback_cell',
    'page arguments' => [4, 5, 6, 7],
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/statistical-queries/demographics/%/%/%/%/%'] = array(
    'title' => 'Village',
    'description' => 'View report for village',
    'page callback' => 'hedley_reports_statistical_queries_report_callback_village',
    'page arguments' => [4, 5, 6, 7, 8],
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/statistical-queries/health-center/%'] = array(
    'title' => 'Health center',
    'description' => 'View report for health center',
    'page callback' => 'hedley_reports_statistical_queries_report_callback_health_center',
    'page arguments' => [4],
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/completion'] = array(
    'title' => 'Completion report',
    'description' => 'View Completion report',
    'page callback' => 'hedley_reports_completion_report_callback_menu',
    // @todo : what access do we need here?
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/completion/all'] = array(
    'title' => 'Entire Population',
    'description' => 'View Completion report for Entire Population',
    'page callback' => 'hedley_reports_completion_report_callback_global',
    // @todo : what access do we need here?
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  $items['admin/reports/completion/health-center/%'] = array(
    'title' => 'Health center',
    'description' => 'View Completion report for health center',
    'page callback' => 'hedley_reports_completion_report_callback_health_center',
    'page arguments' => [4],
    // @todo : what access do we need here?
    'access callback' => 'hedley_reports_statistical_queries_report_access',
  );

  return $items;
}

/**
 * Grants access to Statistical Queries viewers, superuser and administrators.
 *
 * @return bool
 *   TRUE if the user has access, FALSE otherwise.
 */
function hedley_reports_statistical_queries_report_access() {
  $statistical_queries_manager_role = user_role_load_by_name('Statistical Queries Manager');

  return user_has_role($statistical_queries_manager_role->rid) || hedley_admin_administrators_access();
}

/**
 * Implements hook_node_insert().
 */
function hedley_reports_node_insert($node) {
  // Generate initial Reports data for newly created person.
  if ($node->type == 'person') {
    hedley_reports_trigger_recalculation_for_created_person($node);
    return;
  }

  hedley_reports_trigger_recalculation_by_new_content($node);
}

/**
 * Implements hook_node_update().
 */
function hedley_reports_node_update($node) {
  if ($node->type == 'person') {
    hedley_reports_trigger_recalculation_for_edited_person($node);
  }
}

/**
 * Implements hook_advanced_queue_info().
 */
function hedley_reports_advanced_queue_info() {
  $items[HEDLEY_REPORTS_CALCULATE_AGGREGATED_DATA] = [
    'label' => t('Calculate Statistical Queries data'),
    'worker callback' => 'hedley_reports_calculate_aggregated_data_worker',
    'groups' => [
      'hedley',
    ],
    // The number of seconds to retry after.
    'retry after' => 120,
    // The maximum number of attempts after a failure.
    'max attempts' => 3,
  ];

  return $items;
}

/**
 * Advanced queue worker; Calculate aggregated Reports data for person.
 *
 * @param object $queue_item
 *   The item object to process.
 *
 * @return array
 *   Array indicating if the process succeeded, or an array with
 *   "status" and "result" keys.
 */
function hedley_reports_calculate_aggregated_data_worker($queue_item) {
  if (!$person_id = $queue_item->data['person_id']) {
    return [
      'status' => ADVANCEDQUEUE_STATUS_FAILURE,
      'result' => t('Does not have Person Node ID.'),
    ];
  }

  try {
    $person = node_load($person_id);
    hedley_reports_calculate_aggregated_data_for_person($person);
  }
  catch (Exception $e) {
    return [
      'status' => ADVANCEDQUEUE_STATUS_FAILURE_RETRY,
      'result' => $e->getMessage(),
    ];
  }

  $params = [
    '@nid' => $person_id,
  ];
  return [
    'status' => ADVANCEDQUEUE_STATUS_SUCCESS,
    'result' => t('Statistical Queries data has been calculated for person ID: @nid', $params),
  ];
}

/**
 * Callback for Elm application of Statistical Queries menu.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_statistical_queries_report_callback_menu() {
  return hedley_reports_callback_menu_by_page('reports-menu');
}

/**
 * Generates data for a callback menu page.
 *
 * @param string $page
 *   The page identifier used to build the Elm app.
 *
 * @return array
 *   A renderable array containing the Elm app with site name
 *   and health centers data.
 */
function hedley_reports_callback_menu_by_page($page) {
  $site = variable_get('hedley_general_site_name', '');

  $health_centers_data = [];
  $health_center_ids = hedley_health_center_get_all_health_centers_ids();
  $nodes = node_load_multiple($health_center_ids);
  foreach ($nodes as $node) {
    $health_centers_data[] = [
      'id' => $node->nid,
      'name' => $node->title,
    ];
  }

  return hedley_general_build_elm_app($page, [
    'site' => $site,
    'health_centers' => $health_centers_data,
  ]);
}

/**
 * Triggers calculation of Reports data, for newly created person.
 *
 * @param object $node
 *   The node object of a person.
 *
 * @throws EntityMetadataWrapperException
 */
function hedley_reports_trigger_recalculation_for_created_person($node) {
  // If we got this far, schedule generating NCDA data using AQ.
  hedley_general_add_task_to_advanced_queue_by_id(HEDLEY_REPORTS_CALCULATE_AGGREGATED_DATA, $node->nid, [
    'person_id' => $node->nid,
  ]);
}

/**
 * Triggers recalculation of person's Reports data, when edited.
 *
 * Recalculation is required only when birthdate is edited.
 * Note: Currently, editing geo fields of person is not allowed.
 *
 * @param object $node
 *   The node object of a person.
 *
 * @throws EntityMetadataWrapperException
 */
function hedley_reports_trigger_recalculation_for_edited_person($node) {
  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper_orig = entity_metadata_wrapper('node', $node->original);

  $birth_date = $wrapper->field_birth_date->value();
  $birth_date_orig = $wrapper_orig->field_birth_date->value();

  if ($birth_date == $birth_date_orig) {
    return;
  }

  hedley_general_add_task_to_advanced_queue_by_id(HEDLEY_REPORTS_CALCULATE_AGGREGATED_DATA, $node->nid, [
    'person_id' => $node->nid,
  ]);
}

/**
 * Triggers recalculation of person's NCDA data based on it's measurement node.
 *
 * @param object $node
 *   The node object of a measurement.
 *
 * @throws EntityMetadataWrapperException
 */
function hedley_reports_trigger_recalculation_by_new_content($node) {
  $triggering_encounters = [
    HEDLEY_ACTIVITY_ACUTE_ILLNESS_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_NUTRITION_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_HOME_VISIT_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_PRENATAL_ENCOUNTER_CONTENT_TYPE,
    HEDLEY_ACTIVITY_WELL_CHILD_ENCOUNTER_CONTENT_TYPE,
  ];
  $triggering_measurements = hedley_reports_get_triggering_measurement_types();

  if (!in_array($node->type, array_merge($triggering_encounters, $triggering_measurements))) {
    // Not a triggering content.
    return;
  }

  if (in_array($node->type, $triggering_encounters)) {
    // For encounters, resolving person ID through individual participant.
    $participant_id = $node->field_individual_participant[LANGUAGE_NONE][0]['target_id'];
    if (empty($participant_id)) {
      // Can't resolve to which participant encounter belongs.
      return;
    }
    $wrapper = entity_metadata_wrapper('node', $participant_id);
  }
  else {
    // For measurements, resolving person ID directly from measurement.
    $wrapper = entity_metadata_wrapper('node', $node);
  }

  if (!$wrapper->__isset('field_person')) {
    // Can't resolve to which person measurement belongs.
    return;
  }

  $person_id = $wrapper->field_person->value(['identifier' => TRUE]);
  // Trigger recalculation using AQ.
  hedley_general_add_task_to_advanced_queue_by_id(HEDLEY_REPORTS_CALCULATE_AGGREGATED_DATA, $person_id, [
    'person_id' => $person_id,
  ]);
}

/**
 * Retrieves measurement types that trigger Reports data recalculation.
 *
 * @return array
 *   The array of triggering measurement types.
 */
function hedley_reports_get_triggering_measurement_types() {
  return array_unique(array_merge(
    HEDLEY_ACTIVITY_HEIGHT_BUNDLES,
    HEDLEY_ACTIVITY_WEIGHT_BUNDLES,
    HEDLEY_ACTIVITY_REPORTS_GROUP_MEASUREMENT_BUNDLES,
  ));
}

/**
 * Generate raw data for reports, and store in field on person node.
 *
 * @param object $person
 *   Person node for which Reports data is generated.
 *
 * @return bool
 *   True, if data was calculated for person.
 *
 * @throws EntityMetadataWrapperException
 */
function hedley_reports_calculate_aggregated_data_for_person($person) {
  $birth_date = strtotime($person->field_birth_date[LANGUAGE_NONE][0]['value']);
  if (empty($birth_date)) {
    // We must know the birthdate to be able to present reports data.
    return FALSE;
  }
  $data = [
    'id' => $person->nid,
    'created' => date("Y-m-d", $person->created),
    'birth_date' => date("Y-m-d", $birth_date),
    'gender' => $person->field_gender[LANGUAGE_NONE][0]['value'],
  ];

  $sessions_ids = $zscores_by_encounter = [];
  $measurements_bundles = hedley_reports_get_triggering_measurement_types();
  $measurements_ids = hedley_general_get_person_measurements($person->nid, $measurements_bundles);
  $measurements = node_load_multiple($measurements_ids);
  foreach ($measurements as $measurement) {
    switch ($measurement->type) {
      case HEDLEY_ACTIVITY_NUTRITION_HEIGHT_CONTENT_TYPE:
        $encounter_id = $measurement->field_nutrition_encounter[LANGUAGE_NONE][0]['target_id'];
        $zscore_age = $measurement->field_zscore_age[LANGUAGE_NONE][0]['value'];
        if (!empty($zscore_age)) {
          if (empty($zscores_by_encounter[$encounter_id])) {
            $zscores_by_encounter[$encounter_id] = ['s' => $zscore_age];
          }
          else {
            $zscores_by_encounter[$encounter_id]['s'] = $zscore_age;
          }
        }
        break;

      case HEDLEY_ACTIVITY_WELL_CHILD_HEIGHT_CONTENT_TYPE:
        $encounter_id = $measurement->field_well_child_encounter[LANGUAGE_NONE][0]['target_id'];
        $zscore_age = $measurement->field_zscore_age[LANGUAGE_NONE][0]['value'];
        if (!empty($zscore_age)) {
          if (empty($zscores_by_encounter[$encounter_id])) {
            $zscores_by_encounter[$encounter_id] = ['s' => $zscore_age];
          }
          else {
            $zscores_by_encounter[$encounter_id]['s'] = $zscore_age;
          }
        }
        break;

      case HEDLEY_ACTIVITY_NUTRITION_WEIGHT_CONTENT_TYPE:
        $encounter_id = $measurement->field_nutrition_encounter[LANGUAGE_NONE][0]['target_id'];
        $zscore_age = $measurement->field_zscore_age[LANGUAGE_NONE][0]['value'];
        $zscore_length = $measurement->field_zscore_length[LANGUAGE_NONE][0]['value'];
        if (!empty($zscore_age)) {
          if (empty($zscores_by_encounter[$encounter_id])) {
            $zscores_by_encounter[$encounter_id] = ['w' => $zscore_age, 'u' => $zscore_length];
          }
          else {
            $zscores_by_encounter[$encounter_id]['w'] = $zscore_age;
            $zscores_by_encounter[$encounter_id]['u'] = $zscore_length;
          }
        }
        break;

      case HEDLEY_ACTIVITY_WELL_CHILD_WEIGHT_CONTENT_TYPE:
        $encounter_id = $measurement->field_well_child_encounter[LANGUAGE_NONE][0]['target_id'];
        $zscore_age = $measurement->field_zscore_age[LANGUAGE_NONE][0]['value'];
        $zscore_length = $measurement->field_zscore_length[LANGUAGE_NONE][0]['value'];
        if (!empty($zscore_age)) {
          if (empty($zscores_by_encounter[$encounter_id])) {
            $zscores_by_encounter[$encounter_id] = ['w' => $zscore_age, 'u' => $zscore_length];
          }
          else {
            $zscores_by_encounter[$encounter_id]['w'] = $zscore_age;
            $zscores_by_encounter[$encounter_id]['u'] = $zscore_length;
          }
        }
        break;

      case HEDLEY_ACTIVITY_HEIGHT_CONTENT_TYPE:
        $encounter_id = $measurement->field_session[LANGUAGE_NONE][0]['target_id'];
        $sessions_ids[] = $encounter_id;
        $zscore_age = $measurement->field_zscore_age[LANGUAGE_NONE][0]['value'];
        if (!empty($zscore_age)) {
          if (empty($zscores_by_encounter[$encounter_id])) {
            $zscores_by_encounter[$encounter_id] = ['s' => $zscore_age];
          }
          else {
            $zscores_by_encounter[$encounter_id]['s'] = $zscore_age;
          }
        }
        break;

      case HEDLEY_ACTIVITY_WEIGHT_CONTENT_TYPE:
        $encounter_id = $measurement->field_session[LANGUAGE_NONE][0]['target_id'];
        $sessions_ids[] = $encounter_id;
        $zscore_age = $measurement->field_zscore_age[LANGUAGE_NONE][0]['value'];
        $zscore_length = $measurement->field_zscore_length[LANGUAGE_NONE][0]['value'];
        if (!empty($zscore_age)) {
          if (empty($zscores_by_encounter[$encounter_id])) {
            $zscores_by_encounter[$encounter_id] = ['w' => $zscore_age, 'u' => $zscore_length];
          }
          else {
            $zscores_by_encounter[$encounter_id]['w'] = $zscore_age;
            $zscores_by_encounter[$encounter_id]['u'] = $zscore_length;
          }
        }
        break;

      default:
        $encounter_id = $measurement->field_session[LANGUAGE_NONE][0]['target_id'];
        $sessions_ids[] = $encounter_id;
    }
  }

  $encounters_data = [];
  $ai_diagnosis_mapping = hedley_reports_ai_diagnosis_mapping();
  $encounter_types_to_load = [
    HEDLEY_STATS_PRENATAL_ENCOUNTER_TYPE,
    HEDLEY_STATS_ACUTE_ILLNESS_ENCOUNTER_TYPE,
    HEDLEY_STATS_CHILD_SCOREBOARD_ENCOUNTER_TYPE,
    HEDLEY_STATS_HIV_ENCOUNTER_TYPE,
    HEDLEY_STATS_HOME_VISIT_ENCOUNTER_TYPE,
    HEDLEY_STATS_NCD_ENCOUNTER_TYPE,
    HEDLEY_STATS_NUTRITION_ENCOUNTER_TYPE,
    HEDLEY_STATS_TUBERCULOSIS_ENCOUNTER_TYPE,
    HEDLEY_STATS_SPV_ENCOUNTER_TYPE,
  ];
  $individual_participants_ids = hedley_person_individual_participants_for_person($person->nid, $encounter_types_to_load);
  $individual_participants = node_load_multiple($individual_participants_ids);
  foreach ($individual_participants as $individual_participant) {
    $encounters_ids = hedley_person_encounters_for_individual_participant($individual_participant->nid);
    if (empty($encounters_ids)) {
      continue;
    }
    $participant_type = $individual_participant->field_encounter_type[LANGUAGE_NONE][0]['value'];
    $encounters = node_load_multiple($encounters_ids);
    foreach ($encounters as $encounter) {
      $encounter_date = date("Y-m-d", strtotime($encounter->field_scheduled_date[LANGUAGE_NONE][0]['value']));
      switch ($participant_type) {
        case HEDLEY_STATS_ACUTE_ILLNESS_ENCOUNTER_TYPE:
          $encounter_type = $encounter->field_ai_encounter_type[LANGUAGE_NONE][0]['value'];
          $diagnosis = $encounter->field_acute_illness_diagnosis[LANGUAGE_NONE][0]['value'];
          $mapped_diagnosis = !empty($ai_diagnosis_mapping[$diagnosis]) ? $ai_diagnosis_mapping[$diagnosis] : '';
          $encounter_data = "$encounter_date|$encounter_type|$mapped_diagnosis";
          break;

        case HEDLEY_STATS_PRENATAL_ENCOUNTER_TYPE:
          $encounter_type = $encounter->field_prenatal_encounter_type[LANGUAGE_NONE][0]['value'];
          $encounter_data = "$encounter_date $encounter_type";
          break;

        case HEDLEY_STATS_NUTRITION_ENCOUNTER_TYPE:
        case HEDLEY_STATS_SPV_ENCOUNTER_TYPE:
          $nutrition = hedley_reports_nutrition_metrics_to_string($zscores_by_encounter[$encounter->nid]);
          $encounter_data = "$encounter_date $nutrition";
          break;

        // For remaining types recording only encounter date.
        default:
          $encounter_data = $encounter_date;
      }

      if (empty($encounters_data[$participant_type][$individual_participant->nid])) {
        $encounters_data[$participant_type][$individual_participant->nid] = [$encounter_data];
      }
      else {
        $encounters_data[$participant_type][$individual_participant->nid][] = $encounter_data;
      }
    }

    // Adding participant data for pregnancies.
    if ($participant_type == HEDLEY_STATS_PRENATAL_ENCOUNTER_TYPE) {
      $participant_data = [
        'created' => date("Y-m-d", $individual_participant->created),
      ];
      $edd_date = $individual_participant->field_expected_date_concluded[LANGUAGE_NONE][0]['value'];
      if (!empty($edd_date)) {
        $participant_data['edd'] = date("Y-m-d", strtotime($edd_date));
      }
      $date_concluded = $individual_participant->field_date_concluded[LANGUAGE_NONE][0]['value'];
      if (!empty($date_concluded)) {
        $participant_data['dc'] = date("Y-m-d", strtotime($date_concluded));
      }
      $participant_data['encounters'] = $encounters_data[$participant_type][$individual_participant->nid];
      $encounters_data[$participant_type][$individual_participant->nid] = $participant_data;
    }
  }

  if (!empty($encounters_data)) {
    foreach ($encounters_data as $key => $data_type) {
      $encounters_data[$key] = array_values($data_type);
    }
    $data['individual'] = $encounters_data;
  }

  // Load group data.
  $sessions_ids = array_unique($sessions_ids);
  $sessions = node_load_multiple($sessions_ids);
  $clinics_ids = [];
  foreach ($sessions as $session) {
    $clinics_ids[] = $session->field_clinic[LANGUAGE_NONE][0]['target_id'];
  }
  $clinics_ids = array_unique($clinics_ids);
  $clinics = node_load_multiple($clinics_ids);
  $group_type_by_clinic = [];
  foreach ($clinics as $clinic) {
    $group_type_by_clinic[$clinic->nid] = $clinic->field_group_type[LANGUAGE_NONE][0]['value'];
  }

  $sessions_data = [];
  foreach ($sessions as $session) {
    $clinic_id = $session->field_clinic[LANGUAGE_NONE][0]['target_id'];
    $group_type = $group_type_by_clinic[$clinic_id];
    $encounter_date = date("Y-m-d", strtotime($session->field_scheduled_date[LANGUAGE_NONE][0]['value']));
    $nutrition = hedley_reports_nutrition_metrics_to_string($zscores_by_encounter[$session->nid]);
    $session_data = "$encounter_date $nutrition";

    if (empty($sessions_data[$group_type])) {
      $sessions_data[$group_type] = [$session_data];
    }
    else {
      $sessions_data[$group_type][] = $session_data;
    }
  }
  if (!empty($sessions_data)) {
    $data['group_nutrition'] = $sessions_data;
  }

  $encoded_data = json_encode($data);
  $person->field_reports_data[LANGUAGE_NONE][0]['value'] = $encoded_data;
  node_save($person);

  return TRUE;
}

/**
 * Converts nutrition metrics values to a comma-separated string.
 *
 * This function takes an associative array of nutrition metrics and
 * converts it into a string where the values are separated by commas.
 * The keys for the array should be 's' for stunting, 'w' for wasting,
 * and 'u' for underweight. If a key is missing or its value is empty,
 * an empty string is used in its place.
 *
 * @param array|null $values
 *   An associative array of nutrition metrics with the following possible keys:
 *   - 's': The stunting metric.
 *   - 'w': The wasting metric.
 *   - 'u': The underweight metric.
 *
 * @return string
 *   A string with the stunting, wasting, and underweight metrics separated
 *   by commas. If the input array is empty, returns ',,'.
 */
function hedley_reports_nutrition_metrics_to_string($values) {
  if (empty($values)) {
    return ',,';
  }

  $stunting = !empty($values['s']) ? $values['s'] : '';
  $wasting = !empty($values['w']) ? $values['w'] : '';
  $underweight = !empty($values['u']) ? $values['u'] : '';

  return "$stunting,$wasting,$underweight";
}

/**
 * Callback for aggregated Reports elm application of all patients.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_statistical_queries_report_callback_global() {
  return hedley_reports_build_statistical_queries_results_app();
}

/**
 * Callback for aggregated Reports elm application of province.
 *
 * @param string $province
 *   Province name.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_statistical_queries_report_callback_province($province) {
  return hedley_reports_build_statistical_queries_results_app($province);
}

/**
 * Callback for aggregated Reports elm application of district.
 *
 * @param string $province
 *   Province name.
 * @param string $district
 *   District name.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_statistical_queries_report_callback_district($province, $district) {
  return hedley_reports_build_statistical_queries_results_app($province, $district);
}

/**
 * Callback for aggregated Reports elm application of sector.
 *
 * @param string $province
 *   Province name.
 * @param string $district
 *   District name.
 * @param string $sector
 *   Sector name.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_statistical_queries_report_callback_sector($province, $district, $sector) {
  return hedley_reports_build_statistical_queries_results_app($province, $district, $sector);
}

/**
 * Callback for aggregated Reports elm application of cell.
 *
 * @param string $province
 *   Province name.
 * @param string $district
 *   District name.
 * @param string $sector
 *   Sector name.
 * @param string $cell
 *   Cell name.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_statistical_queries_report_callback_cell($province, $district, $sector, $cell) {
  return hedley_reports_build_statistical_queries_results_app($province, $district, $sector, $cell);
}

/**
 * Callback for aggregated Reports elm application of village.
 *
 * @param string $province
 *   Province name.
 * @param string $district
 *   District name.
 * @param string $sector
 *   Sector name.
 * @param string $cell
 *   Cell name.
 * @param string $village
 *   Village name.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_statistical_queries_report_callback_village($province, $district, $sector, $cell, $village) {
  return hedley_reports_build_statistical_queries_results_app($province, $district, $sector, $cell, $village);
}

/**
 * Callback for aggregated Reports elm application of health center.
 *
 * @param int $health_center
 *   Health center ID.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_statistical_queries_report_callback_health_center($health_center) {
  return hedley_reports_build_statistical_queries_results_app(NULL, NULL, NULL, NULL, NULL, $health_center);
}

/**
 * Build results app for aggregated Reports.
 *
 * Based on input fields, determines administrative divisions for which
 * data is provided.
 *
 * @param string|null $province
 *   Province name (optional).
 * @param string|null $district
 *   District name (optional).
 * @param string|null $sector
 *   Sector name (optional).
 * @param string|null $cell
 *   Cell name (optional).
 * @param string|null $village
 *   Village name (optional).
 * @param int|null $health_center
 *   Health center ID (optional).
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_build_statistical_queries_results_app($province = NULL, $district = NULL, $sector = NULL, $cell = NULL, $village = NULL, $health_center = NULL) {
  $data = [];

  if (empty($province)) {
    if (empty($health_center)) {
      $data['entity_name'] = 'Global';
      $data['entity_type'] = 'global';
    }
    else {
      $wrapper = entity_metadata_wrapper('node', $health_center);
      $data['entity_name'] = $wrapper->label();
      $data['entity_type'] = 'health-center';
    }
  }
  elseif (empty($district)) {
    $data['entity_name'] = $province;
    $data['entity_type'] = 'province';
  }
  elseif (empty($sector)) {
    $data['entity_name'] = $district;
    $data['entity_type'] = 'district';
  }
  elseif (empty($cell)) {
    $data['entity_name'] = $sector;
    $data['entity_type'] = 'sector';
  }
  elseif (empty($village)) {
    $data['entity_name'] = $cell;
    $data['entity_type'] = 'cell';
  }
  else {
    $data['entity_name'] = $village;
    $data['entity_type'] = 'village';
  }

  $data['site'] = variable_get('hedley_general_site_name', '');

  if (in_array($data['entity_type'], ['sector', 'cell', 'village'])) {
    // For smaller data sets, we generate results on fly.
    $data['results'] = hedley_reports_generate_results_data($province, $district, $sector, $cell, $village, $health_center);
  }
  else {
    list($data['results'], $data['additional']) = hedley_reports_load_results_data('statistical-query', $data['entity_type'], $province, $district, $health_center);
  }

  return hedley_general_build_elm_app('reports-results', $data);
}

/**
 * Generate aggregated Reports data which is stored on person nodes.
 *
 * @param string|null $province
 *   Province name.
 * @param string|null $district
 *   District name.
 * @param string|null $sector
 *   Sector name.
 * @param string|null $cell
 *   Cell name.
 * @param string|null $village
 *   Village name.
 * @param int|null $health_center
 *   Health center ID.
 *
 * @return array
 *   An array of generated data.
 */
function hedley_reports_generate_results_data($province, $district, $sector, $cell, $village, $health_center) {
  $base_query = new EntityFieldQuery();
  $base_query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'person')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_reports_data', 'value', NULL, 'IS NOT NULL')
    ->addTag('exclude_deleted');

  if (!empty($province)) {
    $base_query->fieldCondition('field_province', 'value', $province);
  }

  if (!empty($district)) {
    $base_query->fieldCondition('field_district', 'value', $district);
  }

  if (!empty($sector)) {
    $base_query->fieldCondition('field_sector', 'value', $sector);
  }

  if (!empty($cell)) {
    $base_query->fieldCondition('field_cell', 'value', $cell);
  }

  if (!empty($village)) {
    $base_query->fieldCondition('field_village', 'value', $village);
  }

  if (!empty($health_center)) {
    $base_query->fieldCondition('field_shards', 'target_id', $health_center);
  }

  $data = [];
  $nid = 0;
  $batch = 400;
  while (TRUE) {
    // Free up memory.
    drupal_static_reset();

    $query = clone $base_query;
    if ($nid) {
      $query->propertyCondition('nid', $nid, '>');
    }

    $result = $query
      ->range(0, $batch)
      ->execute();

    if (empty($result['node'])) {
      // No more items left.
      break;
    }

    $ids = array_keys($result['node']);
    $nodes = node_load_multiple($ids);
    foreach ($nodes as $node) {
      $json_data = $node->field_reports_data[LANGUAGE_NONE][0]['value'];
      if (empty($json_data)) {
        continue;
      }

      $data[] = json_decode($json_data);
      // Explicitly unset large variables after use for memory optimization.
      unset($json_data);
    }

    $nid = end($ids);
    // Explicitly unset large variables after use for memory optimization.
    unset($nodes);
  }

  return $data;
}

/**
 * Loads data in scope, stored at Report Data node.
 *
 * @param string $report_variant
 *   Type of report to load.
 * @param string $scope
 *   Scope of data to load.
 * @param string|null $province
 *   Province name.
 * @param string|null $district
 *   District name.
 * @param int|null $health_center
 *   Health center ID.
 *
 * @return array
 *   Stored data.
 */
function hedley_reports_load_results_data($report_variant, $scope, $province = NULL, $district = NULL, $health_center = NULL) {
  $node_id = hedley_reports_load_results_data_node($report_variant, $scope, $province, $district, $health_center);
  if (!$node_id) {
    return [];
  }

  $node = node_load($node_id);
  $file = file_load($node->field_data_file[LANGUAGE_NONE][0]['fid']);
  if (!$file) {
    return [];
  }

  // Get the real path of the file.
  $file_path = drupal_realpath($file->uri);
  // Open the gzipped file and read its contents.
  $gz_fp = gzopen($file_path, 'r');
  if (!$gz_fp) {
    return [];
  }

  $data = '';
  while (!gzeof($gz_fp)) {
    $data .= gzread($gz_fp, 4096);
  }
  gzclose($gz_fp);

  $additional_data = '';
  if (!empty($node->field_reports_data)) {
    $additional_data = $node->field_reports_data[LANGUAGE_NONE][0]['value'];
  }

  return [json_decode($data), json_decode($additional_data)];
}

/**
 * Generates data in scope and creates/updates Report Data node.
 *
 * @param array $data
 *   Data to write into file.
 * @param string $report_variant
 *   Type of report to load.
 * @param string $scope
 *   Scope of data to generate.
 * @param string|null $province
 *   Province name.
 * @param string|null $district
 *   District name.
 * @param int|null $health_center
 *   Health center ID.
 *
 * @throws Exception
 */
function hedley_reports_create_or_update_results_data_node(array $data, $report_variant, $scope, $province = NULL, $district = NULL, $health_center = NULL) {
  $data_file_id = hedley_reports_create_data_file($data);
  $node_id = hedley_reports_load_results_data_node($report_variant, $scope, $province, $district, $health_center);
  if (!$node_id) {
    // Create the Report Data node.
    $node = new stdClass();
    $node->type = 'report_data';
    node_object_prepare($node);
    $node->title = hedley_reports_generate_results_data_node_title($report_variant, $scope, $province, $district, $health_center);
    $node->uid = 1;
    $node->status = NODE_PUBLISHED;
    $node->language = LANGUAGE_NONE;
    $node->field_report_variant[LANGUAGE_NONE][0]['value'] = $report_variant;
    $node->field_data_scope[LANGUAGE_NONE][0]['value'] = $scope;
    // Attach the file to the node's file field.
    $node->field_data_file[LANGUAGE_NONE][0] = [
      'fid' => $data_file_id,
      'display' => 1,
    ];
    if (!empty($province)) {
      $node->field_province[LANGUAGE_NONE][0]['value'] = $province;
    }
    if (!empty($district)) {
      $node->field_district[LANGUAGE_NONE][0]['value'] = $district;
    }
    if (!empty($health_center)) {
      $node->field_health_center[LANGUAGE_NONE][0]['target_id'] = $health_center;
    }
  }
  else {
    // Update the Report Data node.
    $node = node_load($node_id);
    $old_file = file_load($node->field_data_file[LANGUAGE_NONE][0]['fid']);
    if ($old_file) {
      // Delete the old file.
      file_delete($old_file, TRUE);
    }
    // Attach new file.
    $node->field_data_file[LANGUAGE_NONE][0] = [
      'fid' => $data_file_id,
      'display' => 1,
    ];
  }

  if ($report_variant == 'statistical-query') {
    $additional_data = [
      'nutrition_report_data' => hedley_reports_generate_nutrition_report_data($data),
    ];
    $node->field_reports_data[LANGUAGE_NONE][0]['value'] = json_encode($additional_data);
  }

  // Save the node.
  node_save($node);
}

/**
 * Loads Report Data node of provided variant, storing data defined at scope.
 *
 * @param string $report_variant
 *   Type of report to load.
 * @param string $scope
 *   Scope of data to load.
 * @param string|null $province
 *   Province name.
 * @param string|null $district
 *   District name.
 * @param int|null $health_center
 *   Health center ID.
 *
 * @return int|false
 *   Report Data node ID, or False, if not found.
 */
function hedley_reports_load_results_data_node($report_variant, $scope, $province = NULL, $district = NULL, $health_center = NULL) {
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'report_data')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_report_variant', 'value', $report_variant)
    ->fieldCondition('field_data_scope', 'value', $scope)
    // There can be only single node.
    ->range(0, 1);

  if (!empty($province)) {
    $query->fieldCondition('field_province', 'value', $province);
  }

  if (!empty($district)) {
    $query->fieldCondition('field_district', 'value', $district);
  }

  if (!empty($health_center)) {
    $query->fieldCondition('field_health_center', 'target_id', $health_center);
  }

  $result = $query->execute();

  return empty($result['node']) ? FALSE : key($result['node']);
}

/**
 * Creates a file with provided data as a content.
 *
 * @param array $data
 *   Data to write into file.
 *
 * @return int
 *   Created file ID.
 */
function hedley_reports_create_data_file(array $data) {
  // Create a temporary file with the content.
  $file_content = json_encode($data);
  $file_path = 'private://report-data-' . time() . '.txt.gz';
  $file_uri = file_unmanaged_save_data($file_content, $file_path, FILE_EXISTS_REPLACE);
  // Compress the content and save it to a .gz file.
  $gz_file_path = hedley_reports_gz_compress_file($file_content, $file_path);
  // Create the file object and save it.
  $file = (object) array(
    'uid' => 1,
    'filename' => drupal_basename($file_uri),
    'uri' => $gz_file_path,
    'filemime' => 'application/gzip',
    'status' => NODE_PUBLISHED,
    'display' => 1,
    'timestamp' => REQUEST_TIME,
  );
  file_save($file);

  return $file->fid;
}

/**
 * Helper function to compress file content using gzip.
 *
 * @param string $data
 *   The data to be compressed.
 * @param string $file_path
 *   The file path where the compressed data will be saved.
 *
 * @return string
 *   The path to the gzipped file.
 */
function hedley_reports_gz_compress_file($data, $file_path) {
  $gz_fp = gzopen($file_path, 'w9');
  gzwrite($gz_fp, $data);
  gzclose($gz_fp);
  return $file_path;
}

/**
 * Provides a mapping for AI diagnosis codes.
 *
 * This function returns an associative array where the keys are diagnosis
 * identifiers and the values are corresponding codes.
 *
 * @return array
 *   An associative array mapping diagnosis identifiers to their codes.
 */
function hedley_reports_ai_diagnosis_mapping() {
  return [
    'covid19' => 'a',
    'covid19-severe' => 'b',
    'covid19-pneumonia' => 'c',
    'covid19-low-risk' => 'd',
    'malaria-complicated' => 'e',
    'malaria-uncomplicated' => 'f',
    'malaria-uncomplicated-pregnant' => 'g',
    'gi-complicated' => 'h',
    'gi-uncomplicated' => 'i',
    'ri-complicated' => 'j',
    'ri-uncomplicated' => 'k',
    'cough-and-cold' => 'l',
    'fever-of-unknown-origin' => 'm',
    'undetermined' => 'n',
    'tuberculosis-suspect' => 'o',
    'none' => 'z',
  ];
}

/**
 * Generates Report Data node title for provided variant and scope.
 *
 * @param string $report_variant
 *   Type of report to load.
 * @param string $scope
 *   Scope of data to load.
 * @param string|null $province
 *   Province name.
 * @param string|null $district
 *   District name.
 * @param int|null $health_center
 *   Health center ID.
 *
 * @return string
 *   Report Data node title.
 */
function hedley_reports_generate_results_data_node_title($report_variant, $scope, $province = NULL, $district = NULL, $health_center = NULL) {
  $prefix = ucwords(str_replace("-", " ", $report_variant));

  switch ($scope) {
    case 'province':
      $suffix = "Province $province";
      break;

    case 'district':
      $suffix = "District $district";
      break;

    case 'health-center':
      $suffix = "Health Center ID $health_center";
      break;

    default:
      $suffix = 'Glodal';
  }

  return "$prefix report data - $suffix";
}

/**
 * Retrieves all unique districts for a given province.
 *
 * @param string $province
 *   The province for which to retrieve the unique districts.
 *
 * @return array
 *   An array of unique districts for the specified province.
 */
function hedley_reports_get_unique_districts_by_province($province) {
  $query = db_select('field_data_field_district', 'fd')
    ->fields('fd', ['field_district_value'])
    ->distinct(TRUE)
    ->condition('fp.field_province_value', $province);
  $query->join('field_data_field_province', 'fp', 'fd.entity_id = fp.entity_id');
  $result = $query->execute();

  $districts = [];
  foreach ($result as $record) {
    $districts[] = $record->field_district_value;
  }

  return $districts;
}

/**
 * Generates nutrition report data from the given patient reports data.
 *
 * This function processes patients reports data to generate various
 * nutritional metrics such as prevalence and incidence of stunting,
 * wasting, and underweight.
 *
 * @param array $data
 *   An array of patient data objects.
 *
 * @return array
 *   An array containing various metrics and data tables.
 */
function hedley_reports_generate_nutrition_report_data(array $data) {
  $impacted = [];
  $nutrition_data = [];

  foreach ($data as $patient_data) {
    if (hedley_reports_calculate_year_difference($patient_data->birth_date) > 5) {
      continue;
    }

    $data_for_patient = [
      'id' => $patient_data->id,
      'encounters' => [],
    ];

    if (isset($patient_data->group_nutrition)) {
      if (isset($patient_data->group_nutrition->pmtct)) {
        $data_for_patient['encounters'] = array_merge($data_for_patient['encounters'], $patient_data->group_nutrition->pmtct);
      }
      if (isset($patient_data->group_nutrition->fbf)) {
        $data_for_patient['encounters'] = array_merge($data_for_patient['encounters'], $patient_data->group_nutrition->fbf);
      }
      if (isset($patient_data->group_nutrition->sorwathe)) {
        $data_for_patient['encounters'] = array_merge($data_for_patient['encounters'], $patient_data->group_nutrition->sorwathe);
      }
      if (isset($patient_data->group_nutrition->chw)) {
        $data_for_patient['encounters'] = array_merge($data_for_patient['encounters'], $patient_data->group_nutrition->chw);
      }
      if (isset($patient_data->group_nutrition->achi)) {
        $data_for_patient['encounters'] = array_merge($data_for_patient['encounters'], $patient_data->group_nutrition->achi);
      }
    }

    if (isset($patient_data->individual)) {
      if (isset($patient_data->individual->nutrition)) {
        foreach ($patient_data->individual->nutrition as $items) {
          $data_for_patient['encounters'] = array_merge($data_for_patient['encounters'], $items);
        }
      }
      if (isset($patient_data->individual->{"well-child"})) {
        foreach ($patient_data->individual->{"well-child"} as $items) {
          $data_for_patient['encounters'] = array_merge($data_for_patient['encounters'], $items);
        }
      }
    }

    $nutrition_data[] = $data_for_patient;

    if (count($data_for_patient['encounters']) > 1) {
      $impacted[] = $data_for_patient['id'];
    }
  }

  // Filtering out encounters performed before Jan 01 of starting year.
  // Starting year is current year, minus 3, as Nutrition report shows
  // data from previous 2 years, and we need prior year as well, to
  // compute Incidence.
  $today = new DateTime();
  $starting_year = $today->format('Y') - 3;
  // Initialize the dictionary (associative array in PHP)
  $encounters_by_month = [];
  foreach ($nutrition_data as $nutrition_data_item) {
    foreach ($nutrition_data_item['encounters'] as $index => $encounter_data) {
      $parts = explode(' ', $encounter_data);
      $start_date_as_string = $parts[0];
      $start_date = DateTime::createFromFormat('Y-m-d', $start_date_as_string);
      $start_date_year = $start_date->format('Y');
      if ($start_date_year < $starting_year) {
        unset($nutrition_data_item['encounters'][$index]);
        continue;
      }

      $start_date_month = $start_date->format('m');
      $encounter_zscores = explode(',', $parts[1]);
      $nutrition_data = [
        'stunting' => ($encounter_zscores[0] === '') ? NULL : (float) $encounter_zscores[0],
        'wasting' => ($encounter_zscores[1] === '') ? NULL : (float) $encounter_zscores[1],
        'underweight' => ($encounter_zscores[2] === '') ? NULL : (float) $encounter_zscores[2],
      ];

      $encounter_metrics = hedley_reports_nutrition_encounter_data_to_nutrition_metrics($nutrition_data_item['id'], $nutrition_data);
      $key = "$start_date_year-$start_date_month";
      if (isset($encounters_by_month[$key])) {
        $encounters_by_month[$key] = hedley_reports_sum_nutrition_metrics([$encounters_by_month[$key], $encounter_metrics]);
      }
      else {
        $encounters_by_month[$key] = $encounter_metrics;
      }
    }
  }

  $encounters_by_month_for_impacted = [];
  foreach ($encounters_by_month as $key => $encounter) {
    $encounters_by_month_for_impacted[$key] = [
      'stunting_normal' => hedley_reports_filter_impacted_ids($encounter['stunting_normal'], $impacted),
      'stunting_moderate' => hedley_reports_filter_impacted_ids($encounter['stunting_moderate'], $impacted),
      'stunting_severe' => hedley_reports_filter_impacted_ids($encounter['stunting_severe'], $impacted),
      'wasting_normal' => hedley_reports_filter_impacted_ids($encounter['wasting_normal'], $impacted),
      'wasting_moderate' => hedley_reports_filter_impacted_ids($encounter['wasting_moderate'], $impacted),
      'wasting_severe' => hedley_reports_filter_impacted_ids($encounter['wasting_severe'], $impacted),
      'underweight_normal' => hedley_reports_filter_impacted_ids($encounter['underweight_normal'], $impacted),
      'underweight_moderate' => hedley_reports_filter_impacted_ids($encounter['underweight_moderate'], $impacted),
      'underweight_severe' => hedley_reports_filter_impacted_ids($encounter['underweight_severe'], $impacted),
    ];
  }

  $prevalence_by_month_one_visit_or_more_data = hedley_reports_generate_monthly_prevalence_data($encounters_by_month);
  $prevalence_by_month_two_visits_or_more_data = hedley_reports_generate_monthly_prevalence_data($encounters_by_month_for_impacted);
  $incidence_by_month_one_visit_or_more_data = hedley_reports_generate_monthly_incidence_data($encounters_by_month);
  $incidence_by_month_two_visits_or_more_data = hedley_reports_generate_monthly_incidence_data($encounters_by_month_for_impacted);
  $incidence_by_quarter_one_visit_or_more_data = hedley_reports_generate_quarterly_incidence_data($encounters_by_month);
  $incidence_by_quarter_two_visits_or_more_data = hedley_reports_generate_quarterly_incidence_data($encounters_by_month_for_impacted);
  $incidence_by_year_one_visit_or_more_data = hedley_reports_generate_yearly_incidence_data($encounters_by_month);
  $incidence_by_year_two_visits_or_more_data = hedley_reports_generate_yearly_incidence_data($encounters_by_month_for_impacted);

  return [
    hedley_reports_nutrition_metrics_to_table_data('prevalence-1', $prevalence_by_month_one_visit_or_more_data),
    hedley_reports_nutrition_metrics_to_table_data('prevalence-2', $prevalence_by_month_two_visits_or_more_data),
    hedley_reports_nutrition_metrics_to_table_data('incidence-month-1', $incidence_by_month_one_visit_or_more_data),
    hedley_reports_nutrition_metrics_to_table_data('incidence-month-2', $incidence_by_month_two_visits_or_more_data),
    hedley_reports_nutrition_metrics_to_table_data('incidence-quarter-1', $incidence_by_quarter_one_visit_or_more_data),
    hedley_reports_nutrition_metrics_to_table_data('incidence-quarter-2', $incidence_by_quarter_two_visits_or_more_data),
    hedley_reports_nutrition_metrics_to_table_data('incidence-year-1', $incidence_by_year_one_visit_or_more_data),
    hedley_reports_nutrition_metrics_to_table_data('incidence-year-2', $incidence_by_year_two_visits_or_more_data),
  ];
}

/**
 * Converts nutrition metrics to table data format.
 *
 * @param string $type
 *   The type of the table data.
 * @param array $metrics
 *   The metrics to be converted.
 *
 * @return array
 *   The formatted table data.
 */
function hedley_reports_nutrition_metrics_to_table_data($type, array $metrics) {
  $result = [
    'type' => $type,
    'period' => [],
    'stunting_moderate' => [],
    'stunting_severe' => [],
    'wasting_moderate' => [],
    'wasting_severe' => [],
    'underweight_moderate' => [],
    'underweight_severe' => [],
  ];

  foreach ($metrics as $key => $values) {
    $result['period'][] = (string) $key;
    $result['stunting_moderate'][] = $values['stunting_moderate'];
    $result['stunting_severe'][] = $values['stunting_severe'];
    $result['wasting_moderate'][] = $values['wasting_moderate'];
    $result['wasting_severe'][] = $values['wasting_severe'];
    $result['underweight_moderate'][] = $values['underweight_moderate'];
    $result['underweight_severe'][] = $values['underweight_severe'];
  }

  return $result;
}

/**
 * Generates monthly prevalence data from encounters metrics grouped by month.
 *
 * @param array $encounters_by_month
 *   Encounters metrics data grouped by month.
 *
 * @return array
 *   Monthly prevalence data.
 */
function hedley_reports_generate_monthly_prevalence_data(array $encounters_by_month) {
  $result = [];
  $current_timestamp = time();
  for ($index = 1; $index <= 12; $index++) {
    $target_timestamp = strtotime("-$index month", $current_timestamp);
    $target_date_year = date('Y', $target_timestamp);
    $target_date_month = date('m', $target_timestamp);
    $key = "$target_date_year-$target_date_month";
    $data_set = (!empty($encounters_by_month[$key]) ? $encounters_by_month[$key] : hedley_reports_empty_nutrition_metrics());
    $result[$key] = hedley_reports_generate_prevalence_nutrition_metrics_results($data_set);
  }

  return $result;
}

/**
 * Generates monthly incidence data from encounters metrics grouped  by month.
 *
 * @param array $encounters_by_month
 *   Encounters metrics data grouped by month.
 *
 * @return array
 *   Monthly incidence data.
 */
function hedley_reports_generate_monthly_incidence_data(array $encounters_by_month) {
  $result = [];
  $current_timestamp = time();

  for ($index = 1; $index <= 12; $index++) {
    $target_timestamp = strtotime("-$index month", $current_timestamp);
    $target_date_year = date('Y', $target_timestamp);
    $target_date_month = date('m', $target_timestamp);
    $key = "$target_date_year-$target_date_month";
    $data_set = (!empty($encounters_by_month[$key]) ? $encounters_by_month[$key] : hedley_reports_empty_nutrition_metrics());

    // Per definition, for month, previous data set contains data
    // of 3 months that came prior.
    $previous_data_set = hedley_reports_empty_nutrition_metrics();
    for ($gap = 1; $gap <= 3; $gap++) {
      $gap_timestamp = strtotime("-$gap month", $target_timestamp);
      $gap_date_year = date('Y', $gap_timestamp);
      $gap_date_month = date('m', $gap_timestamp);
      $gap_key = "$gap_date_year-$gap_date_month";
      $gap_data_set = (!empty($encounters_by_month[$gap_key]) ? $encounters_by_month[$gap_key] : hedley_reports_empty_nutrition_metrics());
      $previous_data_set = hedley_reports_sum_nutrition_metrics([$previous_data_set, $gap_data_set]);
    }
    $result[$key] = hedley_reports_generate_incidence_nutrition_metrics_results($data_set, $previous_data_set);
  }

  return $result;
}

/**
 * Generate quarterly incidence table data.
 *
 * @param array $encounters_by_month
 *   An associative array where keys are tuples (year, month) and values
 *   are Nutrition Metrics.
 *
 * @return array
 *   An array containing the quarterly incidence table data.
 */
function hedley_reports_generate_quarterly_incidence_data(array $encounters_by_month) {
  $data_sets_by_quarter = [];
  // We calculate data for the previous 5 quarters.
  for ($index = 1; $index <= 5; $index++) {
    $data_sets_by_quarter[] = hedley_reports_resolve_data_set_for_quarter($index, $encounters_by_month);
  }

  $result = [];
  $current_timestamp = time();
  // Showing data of the previous 4 quarters.
  for ($index = 1; $index <= 4; $index++) {
    $selected_date = strtotime("-" . (3 * $index) . " months", $current_timestamp);

    $year = (int) date('Y', $selected_date);
    $month = (int) date('n', $selected_date);
    $quarter = ceil($month / 3);

    $data_set = $data_sets_by_quarter[$index - 1];
    $previous_data_set = $data_sets_by_quarter[$index];

    $key = "$year-$quarter";

    $result[$key] = hedley_reports_generate_incidence_nutrition_metrics_results($data_set, $previous_data_set);
  }

  return $result;
}

/**
 * Generate yearly incidence table data.
 *
 * @param array $encounters_by_month
 *   An associative array where keys are tuples (year, month) and values
 *   are Nutrition Metrics.
 *
 * @return array
 *   An array containing the yearly incidence table data.
 */
function hedley_reports_generate_yearly_incidence_data(array $encounters_by_month) {
  // We show data of previous 2 years. So, if at 2024, we show
  // data for 2023 and 2022. We calculate set for 3 years (so claculating
  // 2021 as well), as for incidence each year requires a set of previous year.
  for ($index = 1; $index <= 3; $index++) {
    $data_sets_by_year[] = hedley_reports_resolve_data_set_for_year($index, $encounters_by_month);
  }

  $result = [];
  $current_timestamp = time();
  // Showing data of previous 2 years.
  for ($index = 1; $index <= 2; $index++) {
    $selected_date = strtotime("-$index years", $current_timestamp);
    $year = (int) date('Y', $selected_date);

    $data_set = $data_sets_by_year[$index - 1];
    $previous_data_set = $data_sets_by_year[$index];

    $result[$year] = hedley_reports_generate_incidence_nutrition_metrics_results($data_set, $previous_data_set);
  }

  return $result;
}

/**
 * Generates prevalence nutrition metrics results.
 *
 * This function calculates the prevalence percentages for stunting, wasting,
 * and underweight categories based on the provided metrics.
 *
 * @param array $metrics
 *   An array containing nutritional metrics grouped by categories.
 *
 * @return array
 *   An array containing the calculated prevalence percentages for
 *   each category.
 */
function hedley_reports_generate_prevalence_nutrition_metrics_results(array $metrics) {
  $stunting_total = array_unique(array_merge($metrics['stunting_moderate'], $metrics['stunting_severe'], $metrics['stunting_normal']));
  $wasting_total = array_unique(array_merge($metrics['wasting_moderate'], $metrics['wasting_severe'], $metrics['wasting_normal']));
  $underweight_total = array_unique(array_merge($metrics['underweight_moderate'], $metrics['underweight_severe'], $metrics['underweight_normal']));

  return [
    'stunting_moderate' => hedley_reports_calculate_percentage($metrics['stunting_moderate'], $stunting_total),
    'stunting_severe' => hedley_reports_calculate_percentage($metrics['stunting_severe'], $stunting_total),
    'wasting_moderate' => hedley_reports_calculate_percentage($metrics['wasting_moderate'], $wasting_total),
    'wasting_severe' => hedley_reports_calculate_percentage($metrics['wasting_severe'], $wasting_total),
    'underweight_moderate' => hedley_reports_calculate_percentage($metrics['underweight_moderate'], $underweight_total),
    'underweight_severe' => hedley_reports_calculate_percentage($metrics['underweight_severe'], $underweight_total),
  ];
}

/**
 * Generate incidence nutrition metrics results.
 *
 * @param array $current_period_metric
 *   An associative array containing current period metrics.
 * @param array $previous_period_metric
 *   An associative array containing previous period metrics.
 *
 * @return array
 *   An associative array containing the incidence nutrition metrics results.
 */
function hedley_reports_generate_incidence_nutrition_metrics_results(array $current_period_metric, array $previous_period_metric) {
  // STUNTING.
  $previous_period_stunting_moderate_severe = array_unique(array_merge($previous_period_metric['stunting_moderate'], $previous_period_metric['stunting_severe']));
  $previous_period_stunting_total = array_unique(array_merge($previous_period_stunting_moderate_severe, $previous_period_metric['stunting_normal']));

  $stunting_moderate_tested_in_previous_period = array_intersect(array_unique($current_period_metric['stunting_moderate']), $previous_period_stunting_total);
  $stunting_moderate_not_identified_in_previous_period = array_diff(array_unique($current_period_metric['stunting_moderate']), $previous_period_stunting_moderate_severe);

  $stunting_severe_tested_in_previous_period = array_intersect(array_unique($current_period_metric['stunting_severe']), $previous_period_stunting_total);
  $stunting_severe_not_identified_in_previous_period = array_diff(array_unique($current_period_metric['stunting_severe']), array_unique($previous_period_metric['stunting_severe']));

  // WASTING.
  $previous_period_wasting_moderate_severe = array_unique(array_merge($previous_period_metric['wasting_moderate'], $previous_period_metric['wasting_severe']));
  $previous_period_wasting_total = array_unique(array_merge($previous_period_wasting_moderate_severe, $previous_period_metric['wasting_normal']));

  $wasting_moderate_tested_in_previous_period = array_intersect(array_unique($current_period_metric['wasting_moderate']), $previous_period_wasting_total);
  $wasting_moderate_not_identified_in_previous_period = array_diff(array_unique($current_period_metric['wasting_moderate']), $previous_period_wasting_moderate_severe);

  $wasting_severe_tested_in_previous_period = array_intersect(array_unique($current_period_metric['wasting_severe']), $previous_period_wasting_total);
  $wasting_severe_not_identified_in_previous_period = array_diff(array_unique($current_period_metric['wasting_severe']), array_unique($previous_period_metric['wasting_severe']));

  // UNDERWEIGHT.
  $previous_period_underweight_moderate_severe = array_unique(array_merge($previous_period_metric['underweight_moderate'], $previous_period_metric['underweight_severe']));
  $previous_period_underweight_total = array_unique(array_merge($previous_period_underweight_moderate_severe, $previous_period_metric['underweight_normal']));

  $underweight_moderate_tested_in_previous_period = array_intersect(array_unique($current_period_metric['underweight_moderate']), $previous_period_underweight_total);
  $underweight_moderate_not_identified_in_previous_period = array_diff(array_unique($current_period_metric['underweight_moderate']), $previous_period_underweight_moderate_severe);

  $underweight_severe_tested_in_previous_period = array_intersect(array_unique($current_period_metric['underweight_severe']), $previous_period_underweight_total);
  $underweight_severe_not_identified_in_previous_period = array_diff(array_unique($current_period_metric['underweight_severe']), array_unique($previous_period_metric['underweight_severe']));

  return [
    'stunting_moderate' => hedley_reports_calculate_percentage(array_intersect($stunting_moderate_tested_in_previous_period, $stunting_moderate_not_identified_in_previous_period), $previous_period_stunting_total),
    'stunting_severe' => hedley_reports_calculate_percentage(array_intersect($stunting_severe_tested_in_previous_period, $stunting_severe_not_identified_in_previous_period), $previous_period_stunting_total),
    'wasting_moderate' => hedley_reports_calculate_percentage(array_intersect($wasting_moderate_tested_in_previous_period, $wasting_moderate_not_identified_in_previous_period), $previous_period_wasting_total),
    'wasting_severe' => hedley_reports_calculate_percentage(array_intersect($wasting_severe_tested_in_previous_period, $wasting_severe_not_identified_in_previous_period), $previous_period_wasting_total),
    'underweight_moderate' => hedley_reports_calculate_percentage(array_intersect($underweight_moderate_tested_in_previous_period, $underweight_moderate_not_identified_in_previous_period), $previous_period_underweight_total),
    'underweight_severe' => hedley_reports_calculate_percentage(array_intersect($underweight_severe_tested_in_previous_period, $underweight_severe_not_identified_in_previous_period), $previous_period_underweight_total),
  ];
}

/**
 * Calculates the percentage of the nominator over the total.
 *
 * This function calculates the percentage value of the nominator divided
 * by the total. It returns the result as a string rounded to three
 * decimal places.
 *
 * @param array $nominator
 *   The subset of items for which the percentage is to be calculated.
 * @param array $total
 *   The total set of items used as the base for the percentage calculation.
 *
 * @return string
 *   The percentage value as a string, rounded to three decimal places.
 */
function hedley_reports_calculate_percentage(array $nominator, array $total) {
  if (empty($total)) {
    return "0%";
  }
  $result = (string) round((count($nominator) / count($total)) * 100, 3);
  return "$result%";
}

/**
 * Resolve data set for a year.
 *
 * @param int $year_index
 *   The year index.
 * @param array $encounters_by_month
 *   An associative array where keys are tuples (year, month) and values are
 *   Nutrition Metrics.
 *
 * @return array
 *   The aggregated nutrition metrics for the specified year.
 */
function hedley_reports_resolve_data_set_for_year($year_index, array $encounters_by_month) {
  // Calculate the selected date by subtracting months.
  $selected_date = strtotime("-$year_index years", time());
  $selected_year = (int) date('Y', $selected_date);

  $nutrition_metrics = [];
  foreach ($encounters_by_month as $key => $encounter) {
    $year = (int) explode('-', $key)[0];

    if ($year == $selected_year) {
      $nutrition_metrics[] = $encounter;
    }
  }

  return hedley_reports_sum_nutrition_metrics($nutrition_metrics);
}

/**
 * Resolve data set for a quarter.
 *
 * @param int $quarter_index
 *   The quarter index.
 * @param array $encounters_by_month
 *   An associative array where keys are tuples (year, month) and values are
 *   Nutrition Metrics.
 *
 * @return array
 *   The aggregated nutrition metrics for the specified quarter.
 */
function hedley_reports_resolve_data_set_for_quarter($quarter_index, array $encounters_by_month) {
  // Calculate the selected date by subtracting months.
  $selected_date = strtotime("-" . (3 * ($quarter_index - 1)) . " months", time());

  list($year, $quarter) = hedley_reports_resolve_quarter_date_info($selected_date);

  $months = hedley_reports_quarter_to_months($quarter);

  $nutrition_metrics = [];
  foreach ($months as $month) {
    $month = $month < 10 ? "0" . $month : $month;

    if (isset($encounters_by_month["$year-$month"])) {
      $nutrition_metrics[] = $encounters_by_month["$year-$month"];
    }
  }

  return hedley_reports_sum_nutrition_metrics($nutrition_metrics);
}

/**
 * Resolve the previous quarter date information.
 *
 * @param int $timestamp
 *   The timestamp.
 *
 * @return array
 *   An array containing the year and the quarter.
 */
function hedley_reports_resolve_quarter_date_info($timestamp) {
  $year = (int) date('Y', $timestamp);
  $month = (int) date('n', $timestamp);
  $quarter = ceil($month / 3);

  if ($quarter == 1) {
    return [$year - 1, 4];
  }

  return [$year, $quarter - 1];
}

/**
 * Get the months for a given quarter.
 *
 * @param int $quarter
 *   The quarter.
 *
 * @return array
 *   An array of months in the quarter.
 */
function hedley_reports_quarter_to_months($quarter) {
  $months = [];
  for ($i = 1; $i <= 3; $i++) {
    $months[] = 3 * ($quarter - 1) + $i;
  }
  return $months;
}

/**
 * Calculates the year difference between two dates.
 *
 * This function calculates the difference in years between two dates.
 * If the second date is not provided, the current date is used.
 *
 * @param string $fromDateString
 *   The starting date in 'Y-m-d' format.
 * @param string|null $toDateString
 *   The ending date in 'Y-m-d' format. Defaults to the current date
 *   if not provided.
 *
 * @return int|string
 *   The difference in years as an integer, or an error message if the date
 *   format is invalid.
 */
function hedley_reports_calculate_year_difference($fromDateString, $toDateString = NULL) {
  // Convert the from date string to a DateTime object.
  $fromDate = DateTime::createFromFormat('Y-m-d', $fromDateString);
  if (!$fromDate) {
    return "Invalid from date format.";
  }

  // Use the current date if to date is not provided.
  if ($toDateString === NULL) {
    $toDate = new DateTime();
  }
  else {
    // Convert the to date string to a DateTime object.
    $toDate = DateTime::createFromFormat('Y-m-d', $toDateString);
    if (!$toDate) {
      return "Invalid to date format.";
    }
  }

  // Calculate the difference between the two dates.
  $interval = $toDate->diff($fromDate);

  // Determine the sign of the difference.
  $yearDifference = $interval->y;
  if ($toDate < $fromDate) {
    $yearDifference = -$yearDifference;
  }

  // Return the difference in years.
  return $yearDifference;
}

/**
 * Converts nutrition encounter data to nutrition metrics.
 *
 * This function processes encounter data to categorize nutritional status
 * (normal, moderate, severe) for stunting, wasting, and underweight.
 *
 * @param int $person_id
 *   The ID of the person whose data is being processed.
 * @param array $data
 *   The nutritional data with keys 'stunting', 'wasting', and 'underweight'.
 *
 * @return array
 *   An array containing categorized nutritional metrics.
 */
function hedley_reports_nutrition_encounter_data_to_nutrition_metrics($person_id, array $data) {
  list($stunting_normal, $stunting_moderate, $stunting_severe) = hedley_reports_categorize_z_score($data['stunting'], $person_id);
  list($wasting_normal, $wasting_moderate, $wasting_severe) = hedley_reports_categorize_z_score($data['wasting'], $person_id);
  list($underweight_normal, $underweight_moderate, $underweight_severe) = hedley_reports_categorize_z_score($data['underweight'], $person_id);

  return [
    'stunting_normal' => $stunting_normal,
    'stunting_moderate' => $stunting_moderate,
    'stunting_severe' => $stunting_severe,
    'wasting_normal' => $wasting_normal,
    'wasting_moderate' => $wasting_moderate,
    'wasting_severe' => $wasting_severe,
    'underweight_normal' => $underweight_normal,
    'underweight_moderate' => $underweight_moderate,
    'underweight_severe' => $underweight_severe,
  ];
}

/**
 * Sums multiple sets of nutrition metrics.
 *
 * This function combines multiple sets of nutrition metrics into a single set.
 *
 * @param array $metrics_list
 *   An array of nutrition metrics to be summed.
 *
 * @return array
 *   The combined nutrition metrics.
 */
function hedley_reports_sum_nutrition_metrics(array $metrics_list) {
  $result = hedley_reports_empty_nutrition_metrics();

  foreach ($metrics_list as $metrics) {
    $result['stunting_normal'] = array_merge($result['stunting_normal'], $metrics['stunting_normal']);
    $result['stunting_moderate'] = array_merge($result['stunting_moderate'], $metrics['stunting_moderate']);
    $result['stunting_severe'] = array_merge($result['stunting_severe'], $metrics['stunting_severe']);
    $result['wasting_normal'] = array_merge($result['wasting_normal'], $metrics['wasting_normal']);
    $result['wasting_moderate'] = array_merge($result['wasting_moderate'], $metrics['wasting_moderate']);
    $result['wasting_severe'] = array_merge($result['wasting_severe'], $metrics['wasting_severe']);
    $result['underweight_normal'] = array_merge($result['underweight_normal'], $metrics['underweight_normal']);
    $result['underweight_moderate'] = array_merge($result['underweight_moderate'], $metrics['underweight_moderate']);
    $result['underweight_severe'] = array_merge($result['underweight_severe'], $metrics['underweight_severe']);
  }

  return $result;
}

/**
 * Categorizes a z-score into nutritional status categories.
 *
 * This function categorizes a given z-score into normal, moderate, or severe
 * nutritional status for a person.
 *
 * @param float|null $score
 *   The z-score to be categorized.
 * @param int $person_id
 *   The ID of the person whose z-score is being categorized.
 *
 * @return array
 *   An array containing three sub-arrays for normal, moderate,
 *   and severe categories.
 */
function hedley_reports_categorize_z_score($score, $person_id) {
  if ($score === NULL) {
    return [[], [], []];
  }

  if ($score <= -3) {
    return [[], [], [$person_id]];
  }

  if ($score <= -2) {
    return [[], [$person_id], []];
  }

  return [[$person_id], [], []];
}

/**
 * Creates an empty set of nutrition metrics.
 *
 * This function generates an empty array structure for nutrition metrics,
 * with keys for normal, moderate, and severe categories of stunting,
 * wasting, and underweight.
 *
 * @return array
 *   An empty set of nutrition metrics.
 */
function hedley_reports_empty_nutrition_metrics() {
  return [
    'stunting_normal' => [],
    'stunting_moderate' => [],
    'stunting_severe' => [],
    'wasting_normal' => [],
    'wasting_moderate' => [],
    'wasting_severe' => [],
    'underweight_normal' => [],
    'underweight_moderate' => [],
    'underweight_severe' => [],
  ];
}

/**
 * Filters a list of IDs to only include those that are impacted.
 *
 * @param array $ids
 *   An array of IDs to be filtered.
 * @param array $impacted
 *   An array of impacted IDs.
 *
 * @return array
 *   An array of IDs that are present in the impacted list.
 */
function hedley_reports_filter_impacted_ids(array $ids, array $impacted) {
  return array_filter($ids, function ($id) use ($impacted) {
    return in_array($id, $impacted);
  });
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Adds a condition to select entities that don't have field_reports_data set.
 */
function hedley_ncda_query_exclude_set_reports_data_alter(QueryAlterableInterface $query) {
  $query->leftJoin('field_data_field_reports_data', 'fnd', 'node.nid = fnd.entity_id');
  $query->isNull('fnd.field_reports_data_value');
}

/**
 * Resolves all Nurse IDs.
 *
 * This function  queries the database for all entities
 * with the role of 'nurse' and returns their IDs.
 *
 * @return array
 *   An array of nurse node IDs.
 */
function hedley_ncda_resolve_nurses_ids() {
  $query = db_select('field_data_field_role', 'fr');
  $query->addField('fr', 'entity_id');
  $query->condition('fr.field_role_value', 'nurse');
  return $query->execute()->fetchCol();
}

/**
 * Callback for Elm application of Completion report menu.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_completion_report_callback_menu() {
  return hedley_reports_callback_menu_by_page('completion-menu');
}

/**
 * Callback for Completion report of all patients.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_completion_report_callback_global() {
  return hedley_reports_build_completion_results_app();
}

/**
 * Callback for Completion report of health center.
 *
 * @param int $health_center
 *   Health center ID.
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_completion_report_callback_health_center($health_center) {
  return hedley_reports_build_completion_results_app($health_center);
}

/**
 * Build results app for Completion Report.
 *
 * Based on input fields, determines administrative divisions for which
 * data is provided.
 *
 * @param int|null $health_center
 *   Health center ID (optional).
 *
 * @return string
 *   The HTML markup for the Elm application.
 */
function hedley_reports_build_completion_results_app($health_center = NULL) {
  $data = [];

  if (empty($health_center)) {
    $data['entity_name'] = 'Global';
    $data['entity_type'] = 'global';
  }
  else {
    $wrapper = entity_metadata_wrapper('node', $health_center);
    $data['entity_name'] = $wrapper->label();
    $data['entity_type'] = 'health-center';
  }

  $data['site'] = variable_get('hedley_general_site_name', '');

  list($data['results'], $data['additional']) = hedley_reports_load_results_data('completion', $data['entity_type'], NULL, NULL, $health_center);

  return hedley_general_build_elm_app('completion-results', $data);
}

/**
 * Generates completion data for an individual nutrition encounter.
 *
 * @param object $encounter
 *   The encounter node object.
 *
 * @return array
 *   An array containing the completion data for given encounter.
 */
function hedley_reports_generate_completion_data_for_nutrition_individual_encounter($encounter) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping = [
    'nutrition_height' => 'a',
    'nutrition_nutrition' => 'b',
    'nutrition_photo' => 'c',
    'nutrition_weight' => 'd',
    'nutrition_muac' => 'e',
    'nutrition_contributing_factors' => 'f',
    'nutrition_follow_up' => 'g',
    'nutrition_health_education' => 'h',
    'nutrition_send_to_hc' => 'i',
    'nutrition_ncda' => 'j',
  ];

  // Activities that are always taken during encounter.
  $expected = [
    'nutrition_height',
    'nutrition_nutrition',
    'nutrition_photo',
    'nutrition_weight',
  ];

  // Was encounter recorded by nurse or CHW.
  $taken_by = $encounter->field_nutrition_encounter_type[LANGUAGE_NONE][0]['value'];
  // Resolve encounter start date.
  $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
  $start_date_obj = new DateTime($start_date);

  // Loading all measurements that belong to encounter.
  $measurements_ids = hedley_reports_load_individual_encounter_measurements_ids($encounter);

  if (empty($measurements_ids)) {
    $completion = hedley_reports_generate_completion_result($expected, [], $mapping);

    return [
      'start_date' => $start_date,
      'taken_by' => $taken_by,
      'completion' => $completion,
    ];
  }

  // Try to resolve age in months at a time encounter was performed.
  $age_in_months = hedley_reports_resolve_age_in_months_for_individual_encounter($encounter, $start_date_obj);

  // MUAC is taken starting age of 6 months.
  if (isset($age_in_months) && $age_in_months >= 6) {
    $expected[] = 'nutrition_muac';
  }

  // Ordering measurements by type.
  $measurements_by_type = [];
  $measurements = node_load_multiple($measurements_ids);
  foreach ($measurements as $measurement) {
    $measurements_by_type[$measurement->type] = $measurement;
  }

  $assessment = '';
  if (!empty($measurements_by_type['nutrition_nutrition'])) {
    $assessment = $measurements_by_type['nutrition_nutrition']->field_nutrition_assesment[LANGUAGE_NONE][0]['value'];
  }
  elseif (!empty($measurements_by_type['nutrition_follow_up'])) {
    $assessment = $measurements_by_type['nutrition_follow_up']->field_nutrition_assesment[LANGUAGE_NONE][0]['value'];
  }

  // If assessment was made, we expect all next steps activities.
  if (!empty($assessment) && $assessment !== 'none') {
    $expected = array_merge(
      $expected,
      [
        'nutrition_contributing_factors',
        'nutrition_follow_up',
        'nutrition_health_education',
        'nutrition_send_to_hc',
      ]
    );
  }

  // NCDA activity is taken by nurse only.
  if ($taken_by == 'nurse' && hedley_reports_ncda_expected($age_in_months, $start_date_obj)) {
    $expected[] = 'nutrition_ncda';
  }

  $completion = hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping);

  return [
    'start_date' => $start_date,
    'taken_by' => $taken_by,
    'completion' => $completion,
  ];
}

/**
 * Generates completion data for a group nutrition encounter.
 *
 * Nutrition group encounter is done for adult+child pair, where for both
 * measurements are recorded.
 *
 * @param object $attendance
 *   The attendance node object.
 *
 * @return array
 *   An array containing the completion data for group encounter.
 */
function hedley_reports_generate_completion_data_for_nutrition_group_encounter($attendance) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping_child = [
    'height' => 'a',
    'nutrition' => 'b',
    'photo' => 'c',
    'weight' => 'd',
    'muac' => 'e',
    'contributing_factors' => 'f',
    'follow_up' => 'g',
    'group_health_education' => 'h',
    'group_send_to_hc' => 'i',
    'group_ncda' => 'j',
    'child_fbf' => 'k',
  ];

  $mapping_mother = [
    'family_planning' => 'a',
    'mother_fbf' => 'b',
    'lactation' => 'c',
  ];

  // Attendance points to mother. We need to resolve the child (or children)
  // that have participated in the session.
  $adult_id = $attendance->field_person[LANGUAGE_NONE][0]['target_id'];
  $session_id = $attendance->field_session[LANGUAGE_NONE][0]['target_id'];
  $session = node_load($session_id);
  $clinic_id = $session->field_clinic[LANGUAGE_NONE][0]['target_id'];

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'pmtct_participant')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_adult', 'target_id', $adult_id)
    ->fieldCondition('field_clinic', 'target_id', $clinic_id)
    ->addTag('exclude_deleted')
    ->execute();

  // Flag that signals that adult is mother to a child (or children),
  // and therefore, we expect to find mother activities.
  $is_mother = FALSE;
  $session_participants_ids = [$adult_id];

  if (!empty($result['node'])) {
    $participants_ids = array_keys($result['node']);
    $participants = node_load_multiple($participants_ids);
    foreach ($participants as $participant) {
      $session_participants_ids[] = $participant->field_person[LANGUAGE_NONE][0]['target_id'];
      // It's enough to determine that we found mother for one of the children.
      if (!$is_mother) {
        $is_mother = $participant->field_adult_activities[LANGUAGE_NONE][0]['value'] == 'mother';
      }
    }
  }

  // Resolve encounter start date. We go by the date of attendance
  // measurement, since session may have lasted several days.
  $start_date = explode(' ', $attendance->field_date_measured[LANGUAGE_NONE][0]['value'])[0];
  $start_date_obj = new DateTime($start_date);
  // Resolve data of clinic.
  $clinic = node_load($clinic_id);
  $clinic_type = $clinic->field_group_type[LANGUAGE_NONE][0]['value'];
  $taken_by = ($clinic_type == 'chw') ? 'chw' : 'nurse';

  // Initial return data.
  $return = [
    'start_date' => $start_date,
    'taken_by' => $taken_by,
    'children' => [],
  ];

  // Loading all measurements that were taken for mother and children.
  $session_measurements_types = array_merge(array_keys($mapping_mother), array_keys($mapping_child));
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', $session_measurements_types, 'IN')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_person', 'target_id', $session_participants_ids, 'IN')
    ->fieldCondition('field_session', 'target_id', $session_id)
    ->execute();

  if (empty($result['node'])) {
    // No measurement loaded - no reason to proceed.
    return $return;
  }

  $measurements_ids = array_keys($result['node']);
  $measurements = node_load_multiple($measurements_ids);
  $measurements_by_participant = [];
  foreach ($measurements as $measurement) {
    $child_id = $measurement->field_person[LANGUAGE_NONE][0]['target_id'];
    $measurements_by_participant[$child_id][] = $measurement;
  }

  // Date on which 'Fbf' feature was launched.
  $fbf_launch_date = '2020-06-15';
  $fbf_launch_date_obj = new DateTime($fbf_launch_date);

  // Processing measurements by participant type.
  foreach ($measurements_by_participant as $person_id => $measurements) {
    $person = node_load($person_id);
    // Ordering measurements by type.
    $measurements_by_type = [];
    foreach ($measurements as $measurement) {
      $measurements_by_type[$measurement->type] = $measurement;
    }

    // Handling adult (mother or caregiver).
    if ($person_id == $adult_id) {
      // We do not expect to see activities for caregiver.
      if ($is_mother) {
        $expected = ['family_planning'];

        // Lactation (and possibly Mother FBF) activity are shown
        // for sessions taking place at FBF and ACHI clinics.
        if ($start_date_obj >= $fbf_launch_date_obj && in_array($clinic_type, ['fbf', 'achi'])) {
          $expected[] = 'lactation';

          // Mother FBF activity is shown if Lactation activity indicated
          // that mother is breastfeeding, and mother Ubudehe is 1 or 2.
          if (!empty($measurements_by_type['lactation'])) {
            $lactation_sign = $measurements_by_type['lactation']->field_lactation_signs[LANGUAGE_NONE][0]['value'];
            $ubudehe = $person->field_ubudehe[LANGUAGE_NONE][0]['value'];
            if ($lactation_sign == 'breastfeeding' && in_array($ubudehe, [1, 2])) {
              $expected[] = 'mother_fbf';
            }
          }
        }

        $return['mother'] = hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping_mother);
      }
    }
    // Handling child.
    else {
      // Activities that are always taken during encounter.
      $expected = [
        'height',
        'nutrition',
        'photo',
        'weight',
      ];

      // Try to resolve age in months at a time encounter was performed.
      try {
        // Get birthdate and date measured.
        $birth_date = explode(' ', $person->field_birth_date[LANGUAGE_NONE][0]['value'])[0];

        // Calculate age in months.
        $birth_date_obj = new DateTime($birth_date);
        $interval = $start_date_obj->diff($birth_date_obj);
        $age_in_months = ($interval->y * 12) + $interval->m;
      }
      catch (Exception $e) {
        $age_in_months = NULL;
      }

      // MUAC is taken starting age of 6 months.
      if (isset($age_in_months) && $age_in_months >= 6) {
        $expected[] = 'muac';
      }

      // Date on which 'Group Next Steps' feature was launched.
      $group_next_steps_launch_date = '2021-06-07';
      $group_next_steps_launch_date_obj = new DateTime($group_next_steps_launch_date);
      // We may expect Next Steps activities on after
      // 'Group Next Steps' feature was launched.
      if ($start_date_obj >= $group_next_steps_launch_date_obj) {
        $assessment = '';
        if (!empty($measurements_by_type['nutrition'])) {
          $assessment = $measurements_by_type['nutrition']->field_nutrition_assesment[LANGUAGE_NONE][0]['value'];
        }
        elseif (!empty($measurements_by_type['follow_up'])) {
          $assessment = $measurements_by_type['follow_up']->field_nutrition_assesment[LANGUAGE_NONE][0]['value'];
        }

        // If assessment was made, we expect all next steps activities.
        if (!empty($assessment) && $assessment !== 'none') {
          $expected = array_merge(
            $expected,
            [
              'contributing_factors',
              'follow_up',
              'group_health_education',
              'group_send_to_hc',
            ]
          );
        }
      }

      // Child FBF activity is shown for sessions taking
      // place at FBF and ACHI clinics.
      if ($start_date_obj >= $fbf_launch_date_obj && in_array($clinic_type, ['fbf', 'achi'])) {
        $expected[] = 'child_fbf';
      }

      // NCDA activity is taken by nurse only.
      if ($taken_by == 'nurse' && hedley_reports_ncda_expected($age_in_months, $start_date_obj)) {
        $expected[] = 'group_ncda';
      }

      $return['children'][] = hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping_child);
    }
  }

  $return['children'] = implode('$', $return['children']);

  return $return;
}

/**
 * Generates completion data for acute illness encounters taken during illness.
 *
 * @param object $participant
 *   The participant node object representing illness.
 * @param bool $exclude_set
 *   Indicate whether to exclude encounters with report data already set.
 */
function hedley_reports_generate_completion_data_for_acute_illness($participant, $exclude_set) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping = [
    'acute_findings' => 'a',
    'acute_illness_contacts_tracing' => 'b',
    'acute_illness_core_exam' => 'c',
    'acute_illness_danger_signs' => 'd',
    'acute_illness_follow_up' => 'e',
    'acute_illness_muac' => 'f',
    'acute_illness_nutrition' => 'g',
    'acute_illness_vitals' => 'h',
    'call_114' => 'i',
    'covid_testing' => 'j',
    'exposure' => 'k',
    'hc_contact' => 'l',
    'health_education' => 'm',
    'isolation' => 'n',
    'malaria_testing' => 'o',
    'medication_distribution' => 'p',
    'send_to_hc' => 'q',
    'symptoms_general' => 'r',
    'symptoms_gi' => 's',
    'symptoms_respiratory' => 't',
    'travel_history' => 'u',
    'treatment_history' => 'v',
    'treatment_ongoing' => 'w',
  ];

  // Load all encounters of current participant.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'acute_illness_encounter')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_individual_participant', 'target_id', $participant->nid)
    ->propertyOrderBy('nid')
    ->execute();

  if (empty($result['node'])) {
    return;
  }

  // Encounters are sorted ASC.
  $encounters = node_load_multiple(array_keys($result['node']));
  $encounters_data = [];
  foreach ($encounters as $encounter) {
    // Skip encounter if exclusion flag is raised and it's report data is set.
    if ($exclude_set && !empty($encounter->field_reports_data[LANGUAGE_NONE][0]['value'])) {
      continue;
    }

    // Loading all measurements that belong to encounter.
    $measurements_ids = hedley_reports_load_individual_encounter_measurements_ids($encounter);
    // If encounter type field is empty, we default to CHW, since
    // CHW mode was developed before nurse mode.
    if (empty($encounter->field_ai_encounter_type)) {
      $encounter_type = 'chw-encounter';
    }
    else {
      $encounter_type = $encounter->field_ai_encounter_type[LANGUAGE_NONE][0]['value'];
    }

    $measurements = !empty($measurements_ids) ? node_load_multiple($measurements_ids) : [];
    // Ordering measurements by type.
    $measurements_by_type = [];
    foreach ($measurements as $measurement) {
      $measurements_by_type[$measurement->type] = $measurement;
    }

    $encounters_data[] = [
      'encounter' => $encounter,
      'encounter_type' => $encounter_type,
      'taken_by' => $encounter_type == 'chw-encounter' ? 'chw' : 'nurse',
      'measurements_by_type' => $measurements_by_type,
    ];
  }

  // If we have more than one encounter for illness, and first
  // encounter got no measurements, we drop that encounter.
  // This case should not be happening, because no diagnosis at
  // first encounter should prevent running additional encounters,
  // but actual data at DB shows these cases are present.
  if (count($encounters_data) > 1 && empty($encounters_data[0]['measurements_by_type'])) {
    array_shift($encounters_data);
  }

  foreach ($encounters_data as $index => $encounter_data) {
    $encounter = $encounter_data['encounter'];
    $encounter_type = $encounter_data['encounter_type'];
    $measurements_by_type = $encounter_data['measurements_by_type'];

    // Resolve encounter start date.
    $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
    $start_date_obj = new DateTime($start_date);
    $encounter_data['start_date_obj'] = $start_date_obj;

    // Try to resolve age in months at a time encounter was performed.
    $age_in_months = hedley_reports_resolve_age_in_months_for_individual_encounter($encounter, $start_date_obj);
    $encounter_data['age_in_months'] = $age_in_months;

    $previous_encounters_data = array_slice($encounters_data, 0, $index);
    $is_initial = ($encounter_type == 'nurse-encounter') || (($encounter_type == 'chw-encounter') && empty($previous_encounters_data));
    $encounter_data['is_initial'] = $is_initial;
    $diagnosis = $encounter->field_acute_illness_diagnosis[LANGUAGE_NONE][0]['value'];
    if (!$is_initial && (empty($diagnosis) || $diagnosis == 'none')) {
      // Reversing passed array, to have the encounters sorted DESC.
      $diagnosis = hedley_reports_get_acute_illness_diagnosis_by_previous_encounters(array_reverse($previous_encounters_data));
    }
    $encounter_data['illness_diagnosis'] = $diagnosis;

    // Acute illness module defines following logic:
    // If first encounter(s) were taken by CHW, but then
    // nurse ran and encounter, we consider that encounter of
    // nurse as initial. All data collected by CHWs until that
    // encounter should be ignored.
    $initial_nurse_encounter_index = -1;
    foreach ($previous_encounters_data as $ind => $data) {
      if ($data['encounter_type'] == 'nurse-encounter') {
        $initial_nurse_encounter_index = $ind;
        break;
      }
    }

    if ($initial_nurse_encounter_index == -1) {
      $first_initial_with_subsequents = $previous_encounters_data;
      $second_initial_with_subsequents = [];
    }
    else {
      $first_initial_with_subsequents = array_slice($previous_encounters_data, 0, $initial_nurse_encounter_index + 1);
      $second_initial_with_subsequents = array_slice($previous_encounters_data, $initial_nurse_encounter_index + 1);
    }
    $initial_with_subsequents = empty($second_initial_with_subsequents) ? $first_initial_with_subsequents : $second_initial_with_subsequents;
    $encounter_data['initial_with_subsequents'] = $initial_with_subsequents;

    $fever_at_symptoms = FALSE;
    if (!empty($measurements_by_type['symptoms_general'])) {
      $fever_period = $measurements_by_type['symptoms_general']->field_fever_period[LANGUAGE_NONE][0]['value'];
      if (!empty($fever_period)) {
        $fever_at_symptoms = $fever_period > 0;
      }
    }
    $fever_at_vitals = FALSE;
    if (!empty($measurements_by_type['acute_illness_vitals'])) {
      $body_temperature = $measurements_by_type['acute_illness_vitals']->field_body_temperature[LANGUAGE_NONE][0]['value'];
      if (!empty($body_temperature)) {
        $fever_at_vitals = $body_temperature >= 37.5;
      }
    }
    $fever = $fever_at_symptoms || $fever_at_vitals;
    $encounter_data['fever'] = $fever;

    // So far we were constructing data structures to resolve encounter data.
    // Now we have enough info to determine which activities were expected.
    $expected = hedley_reports_acute_illness_generate_expected_initial_activities($encounter_data);
    // If conditions match, add malaria_testing activity.
    hedley_reports_acute_illness_add_expected_malaria_testing($encounter_data, $expected);
    // If conditions match, add covid_testing activity.
    hedley_reports_acute_illness_add_expected_covid_testing($encounter_data, $expected);
    // If conditions match, add treatment_ongoing activity.
    hedley_reports_acute_illness_add_expected_treatment_ongoing($encounter_data, $expected);
    // If conditions match, add physical exam activities.
    hedley_reports_acute_illness_add_physical_exam_activities($encounter_data, $expected);
    // If conditions match, add next steps activities.
    hedley_reports_acute_illness_add_next_steps_activities($encounter_data, $expected);

    $completion_data = [
      'start_date' => $start_date,
      'taken_by' => $encounter_data['taken_by'],
      'completion' => hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping),
    ];

    $encounter->field_reports_data[LANGUAGE_NONE][0]['value'] = json_encode($completion_data);
    node_save($encounter);
  }
}

/**
 * Generates the list of expected activities for an acute illness encounter.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 *
 * @return array
 *   An array of expected activity names.
 */
function hedley_reports_acute_illness_generate_expected_initial_activities(array $encounter_data) {
  // Activities that are shown at any type of encounter,
  // unconditionally. Existed with initial launch of the feature.
  $expected = [
    'acute_illness_vitals',
  ];

  // Activities that are only shown at initial encounter.
  if ($encounter_data['is_initial']) {
    // Exposure activity.
    $expected[] = 'exposure';
    $expected[] = 'travel_history';
    // Symptoms activity.
    $expected[] = 'symptoms_general';
    $expected[] = 'symptoms_gi';
    $expected[] = 'symptoms_respiratory';
    // Treatment review activity.
    $expected[] = 'treatment_history';
  }

  // Activities that are only shown at subsequent encounters.
  if (!$encounter_data['is_initial']) {
    $launch_date = '2021-03-11';
    $launch_date_obj = new DateTime($launch_date);
    if ($encounter_data['start_date_obj'] >= $launch_date_obj) {
      $expected[] = 'acute_illness_danger_signs';
    }
  }

  return $expected;
}

/**
 * Adds Malaria Testing as expected activity, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_acute_illness_add_expected_malaria_testing(array $encounter_data, array &$expected) {
  // Malaria test is suggested only if fever is recorder.
  if (!$encounter_data['fever']) {
    return;
  }
  $measurements_by_type = $encounter_data['measurements_by_type'];
  $diagnosis = $encounter_data['illness_diagnosis'];
  $covid_diagnoses = ['covid19-severe', 'covid19-pneumonia', 'covid19-low-risk'];
  $covid_not_diagnosed = TRUE;
  if (!empty($diagnosis)) {
    $covid_not_diagnosed = !in_array($diagnosis, $covid_diagnoses);
  }

  // Initial encounter logic.
  if ($encounter_data['is_initial']) {
    if ($covid_not_diagnosed) {
      $expected[] = 'malaria_testing';
    }
    else {
      // Patient was not diagnosed with Covid, and patient was suggested to take
      // COVID test, but did not run it, we expect patient to take Malaria test.
      $covid_rapid_test_suggested_but_not_run = FALSE;
      if (!empty($measurements_by_type['covid_testing'])) {
        $covid_rapid_test_result = $measurements_by_type['covid_testing']->field_rapid_test_result[LANGUAGE_NONE][0]['value'];
        if (!empty($covid_rapid_test_result)) {
          $not_run_values = ['unable-to-run', 'unable-to-run-and-pregnant'];
          $covid_rapid_test_suggested_but_not_run = in_array($covid_rapid_test_result, $not_run_values);
        }
      }
      if ($covid_rapid_test_suggested_but_not_run) {
        $expected[] = 'malaria_testing';
      }
    }
  }
  // Subsequent encounter logic.
  else {
    // If patient was not diagnosed with Covid on current encounter, and fever
    // is recorded on current encounter, and patient did not test positive
    // to Malaria during one of previous encounters, we expect patient to take
    // Malaria test.
    $diagnosed_with_malaria_previously = FALSE;
    $initial_with_subsequents = $encounter_data['initial_with_subsequents'];
    foreach ($initial_with_subsequents as $prev_encounter_data) {
      $prev_measurements_by_type = $prev_encounter_data['measurements_by_type'];
      if (!empty($prev_measurements_by_type['malaria_testing'])) {
        $malaria_rapid_test_result = $prev_measurements_by_type['malaria_testing']->field_rapid_test_result[LANGUAGE_NONE][0]['value'];
        if (!empty($malaria_rapid_test_result)) {
          if (in_array($malaria_rapid_test_result, RDT_POSITIVE_VALUES)) {
            $diagnosed_with_malaria_previously = TRUE;
            break;
          }
        }
      }
    }

    if ($covid_not_diagnosed && !$diagnosed_with_malaria_previously) {
      $expected[] = 'malaria_testing';
    }
  }
}

/**
 * Adds expected COVID-19 as expected activity, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_acute_illness_add_expected_covid_testing(array $encounter_data, array &$expected) {
  if ($encounter_data['taken_by'] != 'nurse') {
    // COVID lab check is available for nurse only.
    return;
  }

  $launch_date = '2021-12-22';
  $launch_date_obj = new DateTime($launch_date);
  if ($encounter_data['start_date_obj'] < $launch_date_obj) {
    // Feature was not yet launched.
    return;
  }

  $measurements_by_type = $encounter_data['measurements_by_type'];
  $fever = $encounter_data['fever'];

  $total_symptoms_respiratory = hedley_reports_count_acute_illness_symptoms_respiratory($measurements_by_type['symptoms_respiratory']);
  $total_symptoms_gi = hedley_reports_count_acute_illness_symptoms_gi($measurements_by_type['symptoms_gi']);
  if ($total_symptoms_gi > 0) {
    $symptoms_indicate_covid = $total_symptoms_respiratory > 0;
  }
  else {
    $total_symptoms_general = hedley_reports_count_acute_illness_symptoms_general($measurements_by_type['symptoms_general']);
    $symptoms_indicate_covid = ($total_symptoms_general + $total_symptoms_respiratory + $total_symptoms_gi) > 1;
  }

  $total_exposure_signs = 0;
  if (!empty($measurements_by_type['exposure'])) {
    $total_exposure_signs = hedley_reports_count_acute_illness_signs($measurements_by_type['exposure']->field_exposure[LANGUAGE_NONE]);
  }
  $total_travel_history_signs = 0;
  if (!empty($measurements_by_type['travel_history'])) {
    $total_travel_history_signs = hedley_reports_count_acute_illness_signs($measurements_by_type['travel_history']->field_travel_history[LANGUAGE_NONE]);
  }
  $signs_indicate_covid = ($total_exposure_signs + $total_travel_history_signs) > 0;

  $malaria_rdt_run_and_not_positive = FALSE;
  if (!empty($measurements_by_type['malaria_testing'])) {
    $malaria_rapid_test_result = $measurements_by_type['malaria_testing']->field_malaria_rapid_test[LANGUAGE_NONE][0]['value'];
    $malaria_rdt_run_and_not_positive = !in_array($malaria_rapid_test_result, RDT_POSITIVE_VALUES);
  }

  if (($signs_indicate_covid && $symptoms_indicate_covid) ||
    ($signs_indicate_covid && $fever) ||
    (!$signs_indicate_covid && $fever && $malaria_rdt_run_and_not_positive && $total_symptoms_respiratory > 0) ||
    (!$signs_indicate_covid && $fever && $malaria_rdt_run_and_not_positive && $total_symptoms_general > 1)) {
    $expected[] = 'covid_testing';
  }
}

/**
 * Adds Ongoing Treatment as expected activity, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_acute_illness_add_expected_treatment_ongoing(array $encounter_data, array &$expected) {
  if ($encounter_data['is_initial']) {
    // Ongoing treatment is available only for subsequent encounters.
    return;
  }

  $launch_date = '2021-03-11';
  $launch_date_obj = new DateTime($launch_date);
  if ($encounter_data['start_date_obj'] < $launch_date_obj) {
    // Feature was not yet launched.
    return;
  }

  // Activity is expected, if medication was prescribed at any
  // of previous encounters.
  $medication_prescribed = FALSE;
  $initial_with_subsequents = $encounter_data['initial_with_subsequents'];
  foreach ($initial_with_subsequents as $prev_encounter_data) {
    $measurements_by_type = $prev_encounter_data['measurements_by_type'];
    if (empty($measurements_by_type['medication_distribution'])) {
      continue;
    }
    $prescribed_medication = $measurements_by_type['medication_distribution']->field_prescribed_medication[LANGUAGE_NONE];
    $total_prescribed = count($prescribed_medication);

    if ($total_prescribed == 0) {
      continue;
    };

    if ($total_prescribed > 1) {
      $medication_prescribed = TRUE;
      break;
    }

    // If we got so far, $total_prescribed == 1.
    $medication = $prescribed_medication[0]['value'];
    if (!in_array($medication, ['lemon-juice-or-honey', 'none'])) {
      $medication_prescribed = TRUE;
      break;
    }
  }

  if ($medication_prescribed) {
    $expected[] = 'treatment_ongoing';
  }
}

/**
 * Adds Physical Exam activities to the expected list, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_acute_illness_add_physical_exam_activities(array $encounter_data, array &$expected) {
  if ($encounter_data['is_initial']) {
    // Acute findings is available only for initial encounter.
    $expected[] = 'acute_findings';
  }

  $launch_date = '2021-12-22';
  $launch_date_obj = new DateTime($launch_date);
  // Core exam is taken only by nurse.
  if ($encounter_data['start_date_obj'] >= $launch_date_obj && $encounter_data['taken_by'] == 'nurse') {
    $expected[] = 'acute_illness_core_exam';
  }

  $launch_date = '2020-12-06';
  $launch_date_obj = new DateTime($launch_date);
  if ($encounter_data['start_date_obj'] >= $launch_date_obj) {
    // MUAC is taken for children that are 6 months to 5 years old.
    if ($encounter_data['age_in_months'] >= 6 && $encounter_data['age_in_months'] < 60) {
      $expected[] = 'acute_illness_muac';
    }
    // Nutrition is taken for children that bellow age of 5 years.
    if ($encounter_data['age_in_months'] < 60) {
      $expected[] = 'acute_illness_nutrition';
    }
  }
}

/**
 * Adds Next Steps activities to the expected list, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_acute_illness_add_next_steps_activities(array $encounter_data, array &$expected) {
  if ($encounter_data['is_initial']) {
    hedley_reports_acute_illness_add_next_steps_activities_initial_encounter($encounter_data, $expected);
  }
  else {
    hedley_reports_acute_illness_add_next_steps_activities_subsequent_encounter($encounter_data, $expected);
  }
}

/**
 * Adds Next Steps activities for the initial encounter, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_acute_illness_add_next_steps_activities_initial_encounter(array $encounter_data, array &$expected) {
  $age_in_months = $encounter_data['age_in_months'];
  $diagnosis = $encounter_data['illness_diagnosis'];
  $measurements_by_type = $encounter_data['measurements_by_type'];
  $is_chw = $encounter_data['taken_by'] == 'chw';

  $medication_prescribed = FALSE;
  if ((($diagnosis == 'malaria-uncomplicated') && $age_in_months >= 6) ||
    (in_array($diagnosis, ['cough-and-cold', 'ri-uncomplicated']) && ($age_in_months >= 2 && $age_in_months < 60)) ||
    (in_array($diagnosis, ['gi-uncomplicated', 'covid19-pneumonia'])) ||
    // DB data shows that in some cases, medication was distributed, but
    // diagnosis was not set properly.
    ($diagnosis == 'none' && !empty($measurements_by_type['medication_distribution']))
  ) {
    $medication_prescribed = TRUE;
  }

  // Adding Isolation activity.
  if (($is_chw && $diagnosis == 'covid19') || in_array($diagnosis, ['covid19-pneumonia', 'covid19-low-risk'])) {
    $expected[] = 'isolation';
  }

  // Adding Call 114 activity.
  if (($is_chw && $diagnosis == 'covid19')) {
    $expected[] = 'call_114';
  }

  // Adding Contact HC activity.
  if ($is_chw && $diagnosis == 'covid19' && !empty($measurements_by_type['call_114'])) {
    // If suspected COVID case, but call to 114 was not made, need
    // to contact HC. This means that 114 contact filed got single
    // value set to 'none'.
    $sign = $measurements_by_type['call_114']->field_114_contact[LANGUAGE_NONE][0]['value'];
    if ($sign == 'none') {
      $expected[] = 'hc_contact';
    }
  }

  // Adding Medication Distribution activity.
  if ($medication_prescribed) {
    $expected[] = 'medication_distribution';
  }

  // Adding Health Education activity.
  // At initial encounter, it's mapped to Symptoms Relief Guidance.
  if ($diagnosis == 'covid19-low-risk') {
    $expected[] = 'health_education';
  }

  // Adding Contacts Tracing activity.
  $launch_date = '2021-12-22';
  $launch_date_obj = new DateTime($launch_date);
  if ($encounter_data['start_date_obj'] >= $launch_date_obj) {
    if (in_array($diagnosis, [
      'covid19-pneumonia',
      'covid19-low-risk',
      'covid19-severe',
    ])) {
      $expected[] = 'acute_illness_contacts_tracing';
    }
  }

  // Adding Send to HC activity.
  hedley_reports_acute_illness_add_send_to_hc_initial_encounter($encounter_data, $medication_prescribed, $expected);

  // Adding Follow Up activity.
  // This activity must be last one checked, as it depends on previous checks.
  $launch_date = '2021-06-07';
  $launch_date_obj = new DateTime($launch_date);
  if (($encounter_data['start_date_obj'] >= $launch_date_obj) && !in_array($diagnosis, ['covid19-severe', 'fever-of-unknown-origin'])) {
    if (($diagnosis == 'tuberculosis-suspect') ||
      in_array('isolation', $expected) ||
      in_array('call_114', $expected) ||
      in_array('hc_contact', $expected) ||
      in_array('medication_distribution', $expected) ||
      in_array('send_to_hc', $expected)) {
      $expected[] = 'acute_illness_follow_up';
    }
  }
}

/**
 * Adds "Send to HC" activity during initial encounter, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param bool $medication_prescribed
 *   Whether medication was prescribed during the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_acute_illness_add_send_to_hc_initial_encounter(array $encounter_data, $medication_prescribed, array &$expected) {
  $age_in_months = $encounter_data['age_in_months'];
  $diagnosis = $encounter_data['illness_diagnosis'];
  $measurements_by_type = $encounter_data['measurements_by_type'];

  if (
    hedley_reports_acute_illness_send_to_hc_by_malaria_testing($encounter_data) ||
    (in_array($diagnosis, ['cough-and-cold', 'ri-uncomplicated']) && $age_in_months < 2) ||
    in_array($diagnosis, [
      'gi-complicated',
      'ri-complicated',
      'fever-of-unknown-origin',
      'undetermined',
      'covid19-severe',
    ]) ||
    ($medication_prescribed && $diagnosis != 'covid19-pneumonia' &&
      hedley_reports_acute_illness_send_to_hc_due_to_medication_non_administration($encounter_data)) ||
    ($encounter_data['taken_by'] == 'chw' && $diagnosis == 'tuberculosis-suspect') ||
    // DB data shows that in some cases, referral activity was completed, but
    // diagnosis was not set properly.
    ($diagnosis == 'none' && !empty($measurements_by_type['send_to_hc']))
  ) {
    $expected[] = 'send_to_hc';
  }
}

/**
 * Determines whether "Send to HC" activity is triggered per malaria testing.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 *
 * @return bool
 *   TRUE if the activity should be triggered, FALSE otherwise.
 */
function hedley_reports_acute_illness_send_to_hc_by_malaria_testing(array $encounter_data) {
  $age_in_months = $encounter_data['age_in_months'];
  $diagnosis = $encounter_data['illness_diagnosis'];

  return ($diagnosis == 'malaria-uncomplicated' && $age_in_months < 6) ||
    in_array($diagnosis, ['malaria-complicated', 'malaria-uncomplicated-pregnant']);
}

/**
 * Determines if "Send to HC" activity is triggered per medication medication.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 *
 * @return bool
 *   TRUE if the activity should be triggered, FALSE otherwise.
 */
function hedley_reports_acute_illness_send_to_hc_due_to_medication_non_administration(array $encounter_data) {
  $measurements_by_type = $encounter_data['measurements_by_type'];
  if (empty($measurements_by_type['medication_distribution'])) {
    return FALSE;
  }

  $signs = $measurements_by_type['medication_distribution']->field_non_administration_reason[LANGUAGE_NONE];
  foreach ($signs as $sign) {
    if (hedley_reports_ends_with($sign['value'], 'lack-of-stock') || hedley_reports_ends_with($sign['value'], 'known-allergy')) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Adds expected Next Steps activities for the subsequent encounter.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_acute_illness_add_next_steps_activities_subsequent_encounter(array $encounter_data, array &$expected) {
  $diagnosis = $encounter_data['illness_diagnosis'];
  $measurements_by_type = $encounter_data['measurements_by_type'];

  $malaria_diagnosed_at_current_encounter = FALSE;
  if (!empty($measurements_by_type['malaria_testing'])) {
    $malaria_rapid_test_result = $measurements_by_type['malaria_testing']->field_malaria_rapid_test[LANGUAGE_NONE][0]['value'];
    $malaria_diagnosed_at_current_encounter = in_array($malaria_rapid_test_result, RDT_POSITIVE_VALUES);
  }

  // Adding Medication Distribution activity.
  $send_to_hc_by_malaria_testing = hedley_reports_acute_illness_send_to_hc_by_malaria_testing($encounter_data);
  if ($malaria_diagnosed_at_current_encounter && !$send_to_hc_by_malaria_testing) {
    $expected[] = 'medication_distribution';
  }

  // Adding Health Education activity.
  if (!$malaria_diagnosed_at_current_encounter) {
    $expected[] = 'health_education';
  }

  // Adding Contact HC activity.
  $danger_sign_present_on_subsequent_visit = hedley_reports_acute_illness_danger_sign_present_on_subsequent_visit($encounter_data);
  if (!$malaria_diagnosed_at_current_encounter &&
    ($danger_sign_present_on_subsequent_visit && $diagnosis == 'covid19')) {
    $expected[] = 'hc_contact';
  }

  // Adding Send to HC activity.
  hedley_reports_acute_illness_add_send_to_hc_subsequent_encounter(
    $encounter_data,
    $malaria_diagnosed_at_current_encounter,
    $send_to_hc_by_malaria_testing,
    $danger_sign_present_on_subsequent_visit,
    $expected);

  // Adding Follow Up activity.
  // This activity must be last one checked, as it depends on previous checks.
  $launch_date = '2021-06-07';
  $launch_date_obj = new DateTime($launch_date);
  if (($encounter_data['start_date_obj'] >= $launch_date_obj)) {
    if (in_array('hc_contact', $expected) ||
      in_array('medication_distribution', $expected) ||
      in_array('send_to_hc', $expected)) {
      $expected[] = 'acute_illness_follow_up';
    }
  }
}

/**
 * Check if any of acute illness danger signs are present on a subsequent visit.
 *
 * This function examines the encounter data to determine if any of the recorded
 * danger signs match predefined signs list indicating serious conditions.
 *
 * @param array $encounter_data
 *   An array containing measurement data for the encounter, including
 *   'measurements_by_type' which holds the measurements for various types.
 *
 * @return bool
 *   TRUE if any of the danger signs are present, FALSE otherwise.
 */
function hedley_reports_acute_illness_danger_sign_present_on_subsequent_visit(array $encounter_data) {
  $measurements_by_type = $encounter_data['measurements_by_type'];

  if (empty($measurements_by_type['acute_illness_danger_signs'])) {
    return FALSE;
  }

  $danger_signs = [
    'unable-drink-suck',
    'vomiting',
    'convulsions',
    'lethargy-unconsciousness',
    'respiratory-distress',
    'spontaneous-bleeding',
    'bloody-diarrhea',
    'new-skip-rash',
  ];
  $recorder_signs = $measurements_by_type['acute_illness_danger_signs']->field_acute_illness_danger_signs[LANGUAGE_NONE];

  foreach ($recorder_signs as $recorder_sign) {
    if (in_array($recorder_sign['value'], $danger_signs)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Determine if referral activity is expected, based on various conditions.
 *
 * @param array $encounter_data
 *   An array containing data for the encounter, including illness diagnosis,
 *   measurements by type, and age in months.
 * @param bool $malaria_diagnosed_at_current_encounter
 *   TRUE if malaria was diagnosed at the current encounter, FALSE otherwise.
 * @param bool $send_to_hc_by_malaria_testing
 *   TRUE if the case should be sent to healthcare based on malaria testing,
 *   FALSE otherwise.
 * @param bool $danger_sign_present_on_subsequent_visit
 *   TRUE if danger signs are present on a subsequent visit, FALSE otherwise.
 * @param array &$expected
 *   An array to which the result will be added if conditions are met.
 */
function hedley_reports_acute_illness_add_send_to_hc_subsequent_encounter(
  array $encounter_data,
  $malaria_diagnosed_at_current_encounter,
  $send_to_hc_by_malaria_testing,
  $danger_sign_present_on_subsequent_visit,
  array &$expected
) {
  $diagnosis = $encounter_data['illness_diagnosis'];
  $measurements_by_type = $encounter_data['measurements_by_type'];
  $age_in_months = $encounter_data['age_in_months'];

  if ($malaria_diagnosed_at_current_encounter) {
    if ($send_to_hc_by_malaria_testing ||
      hedley_reports_acute_illness_send_to_hc_due_to_medication_non_administration($encounter_data)
    ) {
      $expected[] = 'send_to_hc';
      return;
    }
  }

  $respiratory_rate_elevated = FALSE;
  if (!empty($measurements_by_type['acute_illness_vitals'])) {
    $respiratory_rate = $measurements_by_type['acute_illness_vitals']->field_respiratory_rate[LANGUAGE_NONE][0]['value'];
    if ($age_in_months < 12) {
      $respiratory_rate_elevated = $respiratory_rate >= 50;
    }
    elseif ($age_in_months < 60) {
      $respiratory_rate_elevated = $respiratory_rate >= 40;
    }
    else {
      $respiratory_rate_elevated = $respiratory_rate >= 30;
    }
  }
  $send_to_hc_by_vitals = $encounter_data['fever'] || $respiratory_rate_elevated;

  $send_to_hc_by_muac = FALSE;
  if (!empty($measurements_by_type['acute_illness_muac'])) {
    $muac = $measurements_by_type['acute_illness_muac']->field_muac[LANGUAGE_NONE][0]['value'];
    $send_to_hc_by_muac = $muac <= 11.5;
  }

  $send_to_hc_by_nutrition = FALSE;
  if (!empty($measurements_by_type['acute_illness_nutrition'])) {
    $signs = $measurements_by_type['acute_illness_nutrition']->field_nutrition_signs[LANGUAGE_NONE];

    $triggers = ['abdominal-distension', 'apathy', 'edema', 'poor-appetite'];
    $brittle_hair = $dry_skin = FALSE;
    foreach ($signs as $sign) {
      if (in_array($sign['value'], $triggers)) {
        $send_to_hc_by_nutrition = TRUE;
        break;
      }

      if ($sign['value'] == 'brittle-hair') {
        $brittle_hair = TRUE;
      }
      elseif ($sign['value'] == 'dry-skin') {
        $dry_skin = TRUE;
      }

      if ($brittle_hair && $dry_skin) {
        $send_to_hc_by_nutrition = TRUE;
        break;
      }
    }
  }

  $no_improvement_without_danger_signs = !$danger_sign_present_on_subsequent_visit &&
    (hedley_reports_acute_illness_conditions_not_improving_on_subsequent_visit($encounter_data) ||
      $send_to_hc_by_vitals || $send_to_hc_by_muac || $send_to_hc_by_nutrition
    );

  $hc_recommended_to_come = FALSE;
  if (!empty($measurements_by_type['hc_contact'])) {
    $recommendations = $measurements_by_type['hc_contact']->field_hc_recommendation[LANGUAGE_NONE];
    foreach ($recommendations as $recommendation) {
      if ($recommendation['value'] == 'come-to-hc') {
        $hc_recommended_to_come = TRUE;
        break;
      }
    }
  }

  if ($no_improvement_without_danger_signs ||
    ($danger_sign_present_on_subsequent_visit && $diagnosis != 'covid19') ||
    ($danger_sign_present_on_subsequent_visit && $diagnosis == 'covid19' && $hc_recommended_to_come)
  ) {
    $expected[] = 'send_to_hc';
  }
}

/**
 * Check if any patients condition is not improving on a subsequent visit.
 *
 * This function examines the provided encounter data to determine if any of
 * the recorded danger signs indicate that a condition is not improving.
 *
 * @param array $encounter_data
 *   An array containing measurement data for the encounter, including
 *   'measurements_by_type' which holds the measurements.
 *
 * @return bool
 *   TRUE if there are signs indicating that the condition is not improving,
 *   FALSE otherwise.
 */
function hedley_reports_acute_illness_conditions_not_improving_on_subsequent_visit(array $encounter_data) {
  $measurements_by_type = $encounter_data['measurements_by_type'];

  if (empty($measurements_by_type['acute_illness_danger_signs'])) {
    return FALSE;
  }

  $recorder_signs = $measurements_by_type['acute_illness_danger_signs']->field_acute_illness_danger_signs[LANGUAGE_NONE];

  foreach ($recorder_signs as $recorder_sign) {
    if ($recorder_sign['value'] == 'condition-not-improving') {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Retrieve the acute illness diagnosis for given list of encounters.
 *
 * This function iterates through an array of encounter data to find and return
 * the first non-empty acute illness diagnosis that is not 'none'.
 *
 * @param array $encounters_data
 *   An array of encounter data, where each item contains an 'encounter' object.
 *
 * @return string|null
 *   The acute illness diagnosis if found, or NULL if nothing valid resolved.
 */
function hedley_reports_get_acute_illness_diagnosis_by_previous_encounters(array $encounters_data) {
  foreach ($encounters_data as $encounter_data) {
    $encounter = $encounter_data['encounter'];
    $diagnosis = $encounter->field_acute_illness_diagnosis[LANGUAGE_NONE][0]['value'];
    if (!empty($diagnosis) && $diagnosis !== 'none') {
      return $diagnosis;
    }
  }

  return NULL;
}

/**
 * Count acute illness general symptoms.
 *
 * @param object $measurement
 *   The measurement object containing symptom data.
 *
 * @return int
 *   The count of general symptoms.
 */
function hedley_reports_count_acute_illness_symptoms_general($measurement) {
  $fields = [
    'field_chills_period',
    'field_night_sweats_period',
    'field_body_aches_period',
    'field_headache_period',
  ];

  return hedley_reports_count_acute_illness_symptoms($measurement, $fields);
}

/**
 * Count acute illness respiratory symptoms.
 *
 * @param object $measurement
 *   The measurement object containing symptom data.
 *
 * @return int
 *   The count of respiratory symptoms.
 */
function hedley_reports_count_acute_illness_symptoms_respiratory($measurement) {
  $fields = [
    'field_cough_period',
    'field_shortness_of_breath_period',
    'field_nasal_congestion_period',
    'field_blood_in_sputum_period',
    'field_sore_throat_period',
    'field_loss_of_smell_period',
    'field_stabbing_chest_pain_period',
  ];

  return hedley_reports_count_acute_illness_symptoms($measurement, $fields);
}

/**
 * Count acute illness gastrointestinal symptoms.
 *
 * @param object $measurement
 *   The measurement object containing symptom data.
 *
 * @return int
 *   The count of gastrointestinal symptoms.
 */
function hedley_reports_count_acute_illness_symptoms_gi($measurement) {
  $fields = [
    'field_bloody_diarrhea_period',
    'field_non_bloody_diarrhea_period',
    'field_nausea_period',
    'field_vomiting_period',
    'field_abdominal_pain_period',
  ];

  return hedley_reports_count_acute_illness_symptoms($measurement, $fields);
}

/**
 * Helper function to count the number of acute illness symptoms present.
 *
 * @param object $measurement
 *   The measurement object containing symptom data.
 * @param array $fields
 *   An array of field names to check within the measurement object.
 *
 * @return int
 *   The count of symptoms that are present.
 */
function hedley_reports_count_acute_illness_symptoms($measurement, array $fields) {
  $count = 0;
  if (empty($measurement)) {
    return $count;
  }

  foreach ($fields as $field) {
    $value = $measurement->$field[LANGUAGE_NONE][0]['value'];
    if (!empty($value) && $value > 0) {
      $count++;
    }
  }

  return $count;
}

/**
 * Count the number of acute illness signs present.
 *
 * @param array $values
 *   An array of values, where each value represents a sign of illness.
 *
 * @return int
 *   The count of signs that are present (i.e., not equal to 'none').
 */
function hedley_reports_count_acute_illness_signs(array $values) {
  $count = 0;
  foreach ($values as $value) {
    if ($value['value'] != 'none') {
      $count++;
    }
  }

  return $count;
}

/**
 * Generates completion data for well child encounters for patient.
 *
 * @param object $participant
 *   The participant node object representing illness.
 * @param bool $exclude_set
 *   Indicate whether to exclude encounters with report data already set.
 */
function hedley_reports_generate_completion_data_for_well_child($participant, $exclude_set) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping = [
    'well_child_albendazole' => 'a',
    'well_child_bcg_immunisation' => 'b',
    'well_child_caring' => 'c',
    'well_child_contributing_factors' => 'd',
    'well_child_dtp_immunisation' => 'e',
    'well_child_ecd' => 'f',
    'well_child_feeding' => 'g',
    'well_child_follow_up' => 'h',
    'well_child_food_security' => 'i',
    'well_child_head_circumference' => 'j',
    'well_child_health_education' => 'k',
    'well_child_height' => 'l',
    'well_child_hygiene' => 'm',
    'well_child_ipv_immunisation' => 'n',
    'well_child_mebendezole' => 'o',
    'well_child_mr_immunisation' => 'p',
    'well_child_muac' => 'q',
    'well_child_ncda' => 'r',
    'well_child_next_visit' => 's',
    'well_child_nutrition' => 't',
    'well_child_opv_immunisation' => 'u',
    'well_child_pcv13_immunisation' => 'v',
    'well_child_photo' => 'w',
    'well_child_pregnancy_summary' => 'x',
    'well_child_rotarix_immunisation' => 'y',
    'well_child_send_to_hc' => 'z',
    'well_child_symptoms_review' => '1',
    'well_child_vitals' => '2',
    'well_child_vitamin_a' => '3',
    'well_child_weight' => '4',
    'well_child_hpv_immunisation' => '5',
    'well_child_dtp_sa_immunisation' => '6',
  ];

  // Load all encounters of current participant.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'well_child_encounter')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_individual_participant', 'target_id', $participant->nid)
    ->propertyOrderBy('nid')
    ->execute();

  if (empty($result['node'])) {
    return;
  }

  // Get birthdate and gender.
  $person_id = $participant->field_person[LANGUAGE_NONE][0]['target_id'];
  try {
    $person = node_load($person_id);
    $birth_date = explode(' ', $person->field_birth_date[LANGUAGE_NONE][0]['value'])[0];
    $birth_date_obj = new DateTime($birth_date);
    $gender = $person->field_gender[LANGUAGE_NONE][0]['value'];
  }
  catch (Exception $e) {
    $birth_date_obj = NULL;
    $gender = 'male';
  }

  // Encounters are sorted ASC.
  $encounters = node_load_multiple(array_keys($result['node']));
  $encounters_data = [];
  foreach ($encounters as $encounter) {
    // Skip encounter if exclusion flag is raised and it's report data is set.
    if ($exclude_set && !empty($encounter->field_reports_data[LANGUAGE_NONE][0]['value'])) {
      continue;
    }

    // Loading all measurements that belong to encounter.
    $measurements_ids = hedley_reports_load_individual_encounter_measurements_ids($encounter);
    // If encounter type field is empty, we default to pediatric care.
    if (empty($encounter->field_well_child_encounter_type)) {
      $encounter_type = 'pediatric-care';
    }
    else {
      $encounter_type = $encounter->field_well_child_encounter_type[LANGUAGE_NONE][0]['value'];
    }

    $measurements = !empty($measurements_ids) ? node_load_multiple($measurements_ids) : [];
    // Ordering measurements by type.
    $measurements_by_type = [];
    foreach ($measurements as $measurement) {
      $measurements_by_type[$measurement->type] = $measurement;
    }

    $encounters_data[] = [
      'encounter' => $encounter,
      'encounter_type' => $encounter_type,
      'measurements_by_type' => $measurements_by_type,
    ];
  }

  foreach ($encounters_data as $index => $encounter_data) {
    $encounter = $encounter_data['encounter'];
    $measurements_by_type = $encounter_data['measurements_by_type'];

    // Resolve encounter start date.
    $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
    $start_date_obj = new DateTime($start_date);
    $encounter_data['start_date_obj'] = $start_date_obj;

    // Try to resolve age in months at a time encounter was performed.
    $encounter_data['age_in_months'] = hedley_reports_resolve_age_in_months_for_individual_encounter($encounter, $start_date_obj);
    $encounter_data['previous_encounters_data'] = array_slice($encounters_data, 0, $index);

    list($encounter_data['vaccination_history'], $encounter_data['vaccination_progress']) = hedley_reports_well_child_generate_vaccination_progress_data($person_id, $encounter_data);

    // So far we were constructing data structures to resolve encounter data.
    // Now we have enough info to determine which activities were expected.
    $expected = hedley_reports_well_child_generate_expected_initial_activities($encounter_data);
    // If conditions match, add immunisation activities.
    hedley_reports_well_child_add_immunisation_activities($encounter_data, $birth_date_obj, $gender, $expected);
    // If conditions match, add medication activities.
    hedley_reports_well_child_add_medication_activities($encounter_data, $expected);
    // If conditions match, add next steps activities.
    hedley_reports_well_child_add_next_steps_activities($encounter_data, $birth_date_obj, $gender, $expected);

    $completion_data = [
      'start_date' => $start_date,
      'encounter_type' => $encounter_data['encounter_type'],
      'completion' => hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping),
    ];

    $encounter->field_reports_data[LANGUAGE_NONE][0]['value'] = json_encode($completion_data);
    node_save($encounter);
  }
}

/**
 * Generates vaccination progress data for a well-child encounter.
 *
 * This function processes immunisation data from previous and current
 * encounters, generating vaccination history and progress data for
 * well-child encounters. It merges this data with child scoreboard data
 * to produce comprehensive vaccination progress information.
 *
 * @param int $person_id
 *   The ID of the person (child) whose vaccination data is being
 *   processed.
 * @param array $encounter_data
 *   An associative array containing details of the current encounter,
 *   including previous encounter data and measurements.
 *
 * @return array
 *   An array containing merged vaccination progress data, with history
 *   and progress for the child.
 */
function hedley_reports_well_child_generate_vaccination_progress_data($person_id, array $encounter_data) {
  $previous_encounters_data = $encounter_data['previous_encounters_data'];

  $immunisation_types = [
    'well_child_bcg_immunisation',
    'well_child_dtp_immunisation',
    'well_child_dtp_sa_immunisation',
    'well_child_ipv_immunisation',
    'well_child_mr_immunisation',
    'well_child_opv_immunisation',
    'well_child_pcv13_immunisation',
    'well_child_rotarix_immunisation',
    'well_child_hpv_immunisation',
  ];

  $immunisations_from_previous_encounters = [];
  foreach ($immunisation_types as $immunisation_type) {
    $immunisations_from_previous_encounters[$immunisation_type] = [];
  }

  foreach ($previous_encounters_data as $previous_encounter_data) {
    $measurements_by_type = $previous_encounter_data['measurements_by_type'];
    foreach ($immunisation_types as $immunisation_type) {
      if (empty($measurements_by_type[$immunisation_type])) {
        continue;
      }
      $immunisations_from_previous_encounters[$immunisation_type][] = $measurements_by_type[$immunisation_type];
    }
  }

  $immunisations_from_all_encounters = $immunisations_from_previous_encounters;
  $measurements_by_type = $encounter_data['measurements_by_type'];
  foreach ($immunisation_types as $immunisation_type) {
    if (empty($measurements_by_type[$immunisation_type])) {
      continue;
    }
    $immunisations_from_all_encounters[$immunisation_type][] = $measurements_by_type[$immunisation_type];
  }

  $history_data_by_well_child = hedley_reports_generate_vaccination_progress_data($immunisations_from_previous_encounters, 'well-child');
  $progress_data_by_well_child = hedley_reports_generate_vaccination_progress_data($immunisations_from_all_encounters, 'well-child');
  $progress_data_by_child_scoreboard = hedley_reports_well_child_generate_vaccination_progress_data_by_child_scoreboard($person_id, $encounter_data['start_date_obj']);

  return [
    hedley_reports_merge_vaccination_progress_data($immunisation_types, 'well-child', $history_data_by_well_child, $progress_data_by_child_scoreboard),
    hedley_reports_merge_vaccination_progress_data($immunisation_types, 'well-child', $progress_data_by_well_child, $progress_data_by_child_scoreboard),
  ];
}

/**
 * Generates regular vaccination progress data from encounters.
 *
 * Processes immunisation data from a series of encounters to create
 * a structured array of vaccination doses and dates, ensuring the data
 * is sorted and aligned.
 *
 * @param array $immunisations_from_encounters
 *   An associative array containing immunisation data from previous
 *   encounters, indexed by immunisation type.
 * @param string $module
 *   The type of individual encounter where immunisations were taken.
 *   Supported values: 'well-child' / 'child-scoreboard'.
 *
 * @return array
 *   A structured array of vaccination doses and dates, organized by
 *   immunisation type.
 */
function hedley_reports_generate_vaccination_progress_data(array $immunisations_from_encounters, $module) {
  $return = [];
  $immunisations_by_type = [];
  foreach ($immunisations_from_encounters as $immunisation_type => $immunisations) {
    foreach ($immunisations as $immunisation) {
      $doses = $immunisation->field_administered_doses;
      $dates = $immunisation->field_administration_dates;
      if (empty($doses) || empty($dates)) {
        continue;
      }

      $encounter_doses = $encounter_dates = [];
      foreach ($doses[LANGUAGE_NONE] as $dose) {
        $encounter_doses[] = $dose['value'];
      }
      foreach ($dates[LANGUAGE_NONE] as $date) {
        $encounter_dates[] = explode(' ', $date['value'])[0];
      }

      if (empty($immunisations_by_type[$immunisation_type]['doses'])) {
        $immunisations_by_type[$immunisation_type]['doses'] = $encounter_doses;
      }
      else {
        $immunisations_by_type[$immunisation_type]['doses'] = array_merge($immunisations_by_type[$immunisation_type]['doses'], $encounter_doses);
      }

      if (empty($immunisations_by_type[$immunisation_type]['dates'])) {
        $immunisations_by_type[$immunisation_type]['dates'] = $encounter_dates;
      }
      else {
        $immunisations_by_type[$immunisation_type]['dates'] = array_merge($immunisations_by_type[$immunisation_type]['dates'], $encounter_dates);
      }
    }
  }

  foreach ($immunisations_by_type as $type => $item) {
    if (empty($item['doses']) || empty($item['dates'])) {
      continue;
    }

    $immunisations_by_type[$type]['doses'] = array_unique($item['doses']);
    sort($immunisations_by_type[$type]['doses']);
    $immunisations_by_type[$type]['dates'] = array_unique($item['dates']);
    sort($immunisations_by_type[$type]['dates']);
    $total_doses = count($immunisations_by_type[$type]['doses']);
    $total_dates = count($immunisations_by_type[$type]['dates']);

    // Make sure number of doses matches the number of dates.
    if ($total_doses != $total_dates) {
      $common_size = min($total_doses, $total_dates);
      $immunisations_by_type[$type]['doses'] = array_slice($immunisations_by_type[$type]['doses'], 0, $common_size);
      $immunisations_by_type[$type]['dates'] = array_slice($immunisations_by_type[$type]['dates'], 0, $common_size);
    }

    $prefix = $suffix = '';
    switch ($module) {
      case 'child-scoreboard':
        $prefix = 'child_scoreboard_';
        $suffix = '_iz';
        break;

      case 'well-child':
        $prefix = 'well_child_';
        $suffix = '_immunisation';
        break;

      case 'prenatal':
        // No need to remove anything, since there's only single source
        // of immunisations, and no merge is needed.
        break;
    }

    foreach ($immunisations_by_type[$type]['doses'] as $index => $dose) {
      $common_type = hedley_reports_drop_prefix_and_suffix($type, $prefix, $suffix);
      $return[$common_type][$dose] = $immunisations_by_type[$type]['dates'][$index];
    }
  }

  return $return;
}

/**
 * Generates vaccination progress data based on child scoreboard data.
 *
 * Retrieves immunisation data for a child from the child scoreboard,
 * considering all encounters up to the current well-child encounter,
 * and returns structured vaccination progress data.
 *
 * @param int $person_id
 *   The ID of the person (child) whose scoreboard data is being
 *   processed.
 * @param DateTime $well_child_encounter_start_date_obj
 *   The DateTime object representing the start date of the current
 *   well-child encounter.
 *
 * @return array
 *   A structured array of vaccination doses and dates, organized by
 *   immunisation type, based on child scoreboard encounters.
 */
function hedley_reports_well_child_generate_vaccination_progress_data_by_child_scoreboard($person_id, DateTime $well_child_encounter_start_date_obj) {
  $return = [];
  if (empty($person_id)) {
    return $return;
  }

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'individual_participant')
    ->fieldCondition('field_encounter_type', 'value', 'child-scoreboard')
    ->fieldCondition('field_person', 'target_id', $person_id)
    ->propertyCondition('status', NODE_PUBLISHED)
    ->addTag('exclude_deleted');

  $result = $query
    ->range(0, 1)
    ->execute();

  if (empty($result['node'])) {
    // No more items left.
    return $return;
  }

  $participant_id = key($result['node']);
  // Load all encounters of current participant.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'child_scoreboard_encounter')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_individual_participant', 'target_id', $participant_id)
    ->propertyOrderBy('nid')
    ->execute();

  if (empty($result['node'])) {
    return $return;
  }

  $immunisation_types = [
    'child_scoreboard_bcg_iz',
    'child_scoreboard_dtp_iz',
    'child_scoreboard_dtp_sa_iz',
    'child_scoreboard_ipv_iz',
    'child_scoreboard_mr_iz',
    'child_scoreboard_opv_iz',
    'child_scoreboard_pcv13_iz',
    'child_scoreboard_rotarix_iz',
  ];

  $immunisations_by_type = [];
  foreach ($immunisation_types as $immunisation_type) {
    $immunisations_by_type[$immunisation_type] = [
      'doses' => [],
      'dates' => [],
    ];
  }
  $encounters = node_load_multiple(array_keys($result['node']));
  foreach ($encounters as $encounter) {
    $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
    $start_date_obj = new DateTime($start_date);
    if ($start_date_obj > $well_child_encounter_start_date_obj) {
      // This encounter started after well child encounter, so, skip it.
      continue;
    }

    // Loading all immunisation activities recorded during the encounter.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', $immunisation_types, 'IN')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->fieldCondition('field_child_scoreboard_encounter', 'target_id', $encounter->nid)
      ->execute();

    if (empty($result['node'])) {
      continue;
    }

    $immunisations = node_load_multiple(array_keys($result['node']));
    foreach ($immunisations as $immunisation) {
      $doses = $immunisation->field_administered_doses;
      $dates = $immunisation->field_administration_dates;
      if (empty($doses) || empty($dates)) {
        continue;
      }

      $encounter_doses = $encounter_dates = [];
      foreach ($doses[LANGUAGE_NONE] as $dose) {
        $encounter_doses[] = $dose['value'];
      }
      foreach ($dates[LANGUAGE_NONE] as $date) {
        $encounter_dates[] = explode(' ', $date['value'])[0];
      }

      $immunisations_by_type[$immunisation->type]['doses'] = array_merge($immunisations_by_type[$immunisation->type]['doses'], $encounter_doses);
      $immunisations_by_type[$immunisation->type]['dates'] = array_merge($immunisations_by_type[$immunisation->type]['dates'], $encounter_dates);
    }
  }

  foreach ($immunisations_by_type as $type => $item) {
    if (empty($item['doses']) || empty($item['dates'])) {
      continue;
    }

    $immunisations_by_type[$type]['doses'] = array_unique($item['doses']);
    sort($immunisations_by_type[$type]['doses']);
    $immunisations_by_type[$type]['dates'] = array_unique($item['dates']);
    sort($immunisations_by_type[$type]['dates']);
    $total_doses = count($immunisations_by_type[$type]['doses']);
    $total_dates = count($immunisations_by_type[$type]['dates']);

    // Make sure number of doses matches the number of dates.
    if ($total_doses != $total_dates) {
      $common_size = min($total_doses, $total_dates);
      $immunisations_by_type[$type]['doses'] = array_slice($immunisations_by_type[$type]['doses'], 0, $common_size);
      $immunisations_by_type[$type]['dates'] = array_slice($immunisations_by_type[$type]['dates'], 0, $common_size);
    }

    foreach ($immunisations_by_type[$type]['doses'] as $index => $dose) {
      $common_type = hedley_reports_drop_prefix_and_suffix($type, 'child_scoreboard_', '_iz');
      $return[$common_type][$dose] = $immunisations_by_type[$type]['dates'][$index];
    }
  }

  return $return;
}

/**
 * Merges vaccination progress data from different sources.
 *
 * Combines vaccination progress data from two sources (e.g., history
 * and child scoreboard data) into a single structured array, organized
 * by immunisation type.
 *
 * @param array $immunisation_types
 *   An array of immunisation types to be merged.
 * @param string $module
 *   The type of individual encounter where immunisations were taken.
 *   Supported values: 'well-child' / 'child-scoreboard'.
 * @param array $first
 *   The first set of vaccination progress data.
 * @param array $second
 *   The second set of vaccination progress data.
 *
 * @return array
 *   A merged array of vaccination progress data, organized by
 *   immunisation type.
 */
function hedley_reports_merge_vaccination_progress_data(array $immunisation_types, $module, array $first, array $second) {
  $prefix = $suffix = '';
  switch ($module) {
    case 'child-scoreboard':
      $prefix = 'child_scoreboard_';
      $suffix = '_iz';
      break;

    case 'well-child':
      $prefix = 'well_child_';
      $suffix = '_immunisation';
  }

  $return = [];
  foreach ($immunisation_types as $type) {
    $common_type = hedley_reports_drop_prefix_and_suffix($type, $prefix, $suffix);
    if (!empty($first[$common_type]) && !empty($second[$common_type])) {
      $return[$common_type] = array_merge($first[$common_type], $second[$common_type]);
    }
    elseif (!empty($first[$common_type])) {
      $return[$common_type] = $first[$common_type];
    }
    elseif (!empty($second[$common_type])) {
      $return[$common_type] = $second[$common_type];
    }
    else {
      $return[$common_type] = [];
    }
  }

  return $return;
}

/**
 * Generates the list of expected activities for an well child encounter.
 *
 * Here we add activities with simple logic from:
 *  - Pregnancy Summary.
 *  - Danger Signs.
 *  - Nutrition Assessment.
 *  - Child Photo.
 *  - Home Visit.
 *  - NCDA.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 *
 * @return array
 *   An array of expected activity names.
 */
function hedley_reports_well_child_generate_expected_initial_activities(array $encounter_data) {
  $encounter_type = $encounter_data['encounter_type'];
  $age_in_months = $encounter_data['age_in_months'];
  $start_date_obj = $encounter_data['start_date_obj'];

  // Activities that are shown at any type of encounter,
  // unconditionally. Existed with initial launch of the feature.
  $expected = [
    'well_child_nutrition',
    'well_child_photo',
    'well_child_weight',
  ];

  $is_newborn_exam = $encounter_type == 'newborn-exam';
  if (!$is_newborn_exam) {
    $expected[] = 'well_child_height';
  }

  // MUAC is taken starting age of 6 months.
  if (!$is_newborn_exam && isset($age_in_months) && $age_in_months >= 6) {
    $expected[] = 'well_child_muac';
  }

  // Head Circumference is taken for children bellow age of 3 years.
  if (isset($age_in_months) && $age_in_months < 36) {
    $expected[] = 'well_child_head_circumference';
  }

  if ($is_newborn_exam) {
    $expected[] = 'well_child_pregnancy_summary';
    return $expected;
  }

  // Any SPV encounters performed by CHW / nurse.
  $expected = array_merge($expected, [
    'well_child_symptoms_review',
    'well_child_vitals',
  ]);

  // CHW SPV encounters.
  if ($encounter_type == 'pediatric-care-chw') {
    // Home Visit vas added only for SPV encounter by CHW, on Feb 18, 2024.
    $launch_date = '2024-02-18';
    $launch_date_obj = new DateTime($launch_date);
    if ($start_date_obj >= $launch_date_obj) {
      $expected = array_merge($expected, [
        'well_child_caring',
        'well_child_feeding',
        'well_child_food_security',
        'well_child_hygiene',
      ]);
    }
  }
  // Nurse SPV encounters.
  else {
    if (hedley_reports_ncda_expected($age_in_months, $start_date_obj)) {
      $expected[] = 'well_child_ncda';
    }
  }

  return $expected;
}

/**
 * Adds Immunisation activities as expected, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param DateTime $birth_date_obj
 *   The DateTime object representing the child's birth date.
 * @param string $gender
 *   The gender of the child, used to determine gender-specific immunisations.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_well_child_add_immunisation_activities(array $encounter_data, DateTime $birth_date_obj, $gender, array &$expected) {
  $expected_by_history = hedley_reports_well_child_get_expected_immunisation_activities($encounter_data, $birth_date_obj, $gender, 'history');
  foreach ($expected_by_history as $activity) {
    $expected[] = $activity;
  }
}

/**
 * Generates a list of expected well-child immunisation activities.
 *
 * This function determines the expected immunisation activities for a
 * well-child based on the child's encounter data, age, gender, and mode.
 * It considers the vaccination history or progress, the site of the encounter,
 * and other factors such as the child's age in days. It then generates a list
 * of immunisations that should be expected during the encounter.
 *
 * @param array $encounter_data
 *   An associative array containing details of the encounter, including
 *   encounter type, vaccination progress, vaccination history, and start date.
 * @param DateTime $birth_date_obj
 *   The DateTime object representing the child's birth date.
 * @param string $gender
 *   The gender of the child, used to determine gender-specific immunisations.
 * @param string $mode
 *   The mode of operation, either 'history' or 'progress', which determines
 *   whether to consider the vaccination history or progress.
 *
 * @return array
 *   An array of expected immunisation activities based on the encounter data.
 */
function hedley_reports_well_child_get_expected_immunisation_activities(array $encounter_data, DateTime $birth_date_obj, $gender, $mode) {
  $encounter_type = $encounter_data['encounter_type'];
  $vaccination_progress = $encounter_data['vaccination_progress'];
  // History mode looks at vaccination status excluding vaccinations done at
  // current encounter. Progress mode includes vaccinations done at current
  // encounter.
  $vaccination_history = $mode == 'history' ? $encounter_data['vaccination_history'] : $vaccination_progress;
  $start_date_obj = $encounter_data['start_date_obj'];

  $initial_opv_administered = hedley_reports_initial_opv_administered($encounter_data, $birth_date_obj);
  $interval = $start_date_obj->diff($birth_date_obj, TRUE);
  $age_in_days = $interval->days;

  $possible_immunisations = ['bcg', 'opv'];
  if ($encounter_type != 'newborn-exam') {
    if ($age_in_days >= (6 * 7)) {
      $possible_immunisations = array_merge(
        $possible_immunisations,
        ['dtp', 'pcv13', 'rotarix']
      );
    }
    if ($age_in_days >= (14 * 7)) {
      $possible_immunisations[] = 'ipv';
    }
    if ($age_in_days >= (36 * 7)) {
      $possible_immunisations[] = 'mr';
    }

    $site = variable_get('hedley_general_site_name', '');
    if ($site == 'burundi') {
      // All 3 doses of DTP were given, it has passed at least 28 days since
      // third dose, and, child is at last 18 months old.
      if (!empty($vaccination_progress['dtp']['dose-3'])) {
        $age_in_months = ($interval->y * 12) + $interval->m;
        $third_dose_date_obj = new DateTime($vaccination_progress['dtp']['dose-3']);
        $interval = $start_date_obj->diff($third_dose_date_obj, TRUE);
        $days_since_third_dose = $interval->days;

        if ($age_in_months >= 18 && $days_since_third_dose >= 28) {
          $possible_immunisations[] = 'dtp_sa';
        }
      }
    }
    else {
      $age_in_years = $interval->y;
      if ($age_in_years >= 12 && $gender == 'female') {
        $possible_immunisations[] = 'hpv';
      }
    }
  }

  $expected = [];
  foreach ($possible_immunisations as $immunisation_type) {
    $immunisation_full_name = "well_child_{$immunisation_type}_immunisation";
    if (empty($vaccination_history)) {
      $expected[] = $immunisation_full_name;
      continue;
    }

    $performed = $vaccination_history[$immunisation_type];
    if (empty($performed)) {
      $expected[] = $immunisation_full_name;
      continue;
    }

    $doses = array_keys($performed);
    sort($doses);
    $last_dose = array_reverse($doses)[0];
    $last_dose_for_immunisation = hedley_reports_get_last_dose_for_vaccine($immunisation_type, $initial_opv_administered);
    // If all doses we administered, skipping to next immunisation type.
    if ($last_dose == $last_dose_for_immunisation) {
      continue;
    }

    // Calculating when next dose is supposed to be administered.
    $last_dose_as_number = (int) explode('-', $last_dose)[1];
    $next_dose_as_number = $last_dose_as_number + 1;
    $last_dose_date = $performed[$last_dose];
    $interval_between_dosed = hedley_reports_get_interval_for_vaccine($immunisation_type, $site);
    $last_dose_date_obj = new DateTime($last_dose_date);
    $next_dose_date_obj = clone $last_dose_date_obj;
    $next_dose_date_obj->modify($interval_between_dosed);
    if ($immunisation_type == 'opv' && $next_dose_as_number == 2 && $initial_opv_administered) {
      $six_weeks_old_date_obj = clone $birth_date_obj;
      $six_weeks_old_date_obj->modify('+6 weeks');

      if ($six_weeks_old_date_obj > $next_dose_date_obj) {
        $next_dose_date_obj = $six_weeks_old_date_obj;
      }
    }

    // If encounter started after the date when immunisation was supposed
    // to be administered, adding it as expected.
    if ($start_date_obj >= $next_dose_date_obj) {
      $expected[] = $immunisation_full_name;
    }
  }

  return $expected;
}

/**
 * Determines if the initial OPV dose was administered within 14 days of birth.
 *
 * This function checks whether the first dose of OPV (Oral Polio Vaccine) was
 * given within 14 days of the child's birth, based on the vaccination progress
 * data.
 *
 * @param array $encounter_data
 *   An associative array containing details of the encounter, including
 *   vaccination progress.
 * @param DateTime $birth_date_obj
 *   The DateTime object representing the child's birth date.
 *
 * @return bool
 *   TRUE if the initial OPV dose was administered within 14 days of birth,
 *   FALSE otherwise.
 */
function hedley_reports_initial_opv_administered(array $encounter_data, DateTime $birth_date_obj) {
  $vaccination_progress = $encounter_data['vaccination_progress'];

  if (empty($vaccination_progress['opv']) || empty($vaccination_progress['opv']['dose-1'])) {
    return FALSE;
  }

  $first_dose_date_obj = new DateTime($vaccination_progress['opv']['dose-1']);
  $interval = $first_dose_date_obj->diff($birth_date_obj);

  return $interval->days < 14;
}

/**
 * Retrieves the last expected dose for a specific vaccine type.
 *
 * This function returns the last dose that should be administered for a given
 * initial vaccine type, based on the child's vaccination history and whether
 * the OPV dose was administered.
 *
 * @param string $immunisation_type
 *   The type of immunisation (e.g., 'bcg', 'opv', 'dtp').
 * @param bool $initial_opv_administered
 *   Indicates whether the initial OPV dose was administered within 14 days
 *   of birth.
 *
 * @return string|bool
 *   The last expected dose for the vaccine (e.g., 'dose-1', 'dose-3'),
 *   or FALSE, if the immunisation type is not recognized.
 */
function hedley_reports_get_last_dose_for_vaccine($immunisation_type, $initial_opv_administered) {
  switch ($immunisation_type) {
    case 'bcg':
    case 'ipv':
    case 'dtp_sa':
      return 'dose-1';

    case 'rotarix':
    case 'mr':
    case 'hpv':
      return 'dose-2';

    case 'dtp':
    case 'pcv13':
      return 'dose-3';

    case 'opv':
      return $initial_opv_administered ? 'dose-4' : 'dose-3';
  }

  return FALSE;
}

/**
 * Retrieves the interval between doses for a specific vaccine type.
 *
 * This function returns the time interval that should be observed between
 * doses for a given vaccine, taking into account the site where the encounter
 * occurs.
 *
 * @param string $immunisation_type
 *   The type of immunisation (e.g., 'bcg', 'opv', 'dtp').
 * @param string $site
 *   The site name, which may affect the interval for certain vaccines.
 *
 * @return string|bool
 *   A string representing the interval between doses (e.g., '+4 weeks',
 *   '+9 months'), or FALSE if the immunisation type is not recognized.
 */
function hedley_reports_get_interval_for_vaccine($immunisation_type, $site) {
  switch ($immunisation_type) {
    case 'bcg':
    case 'ipv':
    case 'dtp_sa':
      return '+0 days';

    case 'opv':
    case 'dtp':
    case 'pcv13':
    case 'rotarix':
      return '+4 weeks';

    case 'mr':
      return $site == 'burundi' ? '+9 months' : '+6 months';

    case 'hpv':
      return '+6 months';
  }

  return FALSE;
}

/**
 * Adds Medication activities as expected, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_well_child_add_medication_activities(array $encounter_data, array &$expected) {
  $age_in_months = $encounter_data['age_in_months'];
  $start_date_obj = $encounter_data['start_date_obj'];
  // Reversing array, to have the encounters sorted DESC.
  $previous_encounters_data = array_reverse($encounter_data['previous_encounters_data']);

  // Resolving all activities representing medications that are required,
  // per child age at a time when encounter was run.
  $expected_activities_by_age = hedley_reports_well_child_genrate_expected_medication_activities_by_age($age_in_months);
  foreach ($expected_activities_by_age as $expected_activity) {
    // Searching for date on which last dose of medication was administered.
    $last_administration_date_obj = NULL;
    foreach ($previous_encounters_data as $previous_encounter_data) {
      $measurements_by_type = $previous_encounter_data['measurements_by_type'];
      if (empty($measurements_by_type[$expected_activity])) {
        continue;
      }

      $measurement = $measurements_by_type[$expected_activity];
      if (empty($measurement->field_administration_note)) {
        continue;
      }

      $administration_note = $measurement->field_administration_note[LANGUAGE_NONE][0]['value'];
      if ($administration_note == 'administered-today') {
        $last_administration_date_obj = $previous_encounter_data['start_date_obj'];
        break;
      }
    }

    if (is_null($last_administration_date_obj)) {
      // Medication was not administered previously - add it as expected.
      $expected[] = $expected_activity;
    }
    else {
      $next_administration_date_obj = $last_administration_date_obj->add(new DateInterval('P6M'));
      if ($start_date_obj >= $next_administration_date_obj) {
        // Medication was administered previously more than 6 months
        // ago - add it as expected.
        $expected[] = $expected_activity;
      }
    }
  }
}

/**
 * Generates a list of expected well-child medication activities based on age.
 *
 * This function determines the expected medication activities for a well-child
 * visit based on the child's age in months. The activities may differ based
 * on the site name, which is retrieved from the configuration.
 *
 * The function checks age ranges and adds specific activities to the
 * expected list. If the site is "burundi", different rules are applied compared
 * to the default site.
 *
 * @param int $age_in_months
 *   The age of the child in months.
 *
 * @return array
 *   An array of expected medication activities for the child based on their
 *   age. Returns an empty array if the age is not provided.
 */
function hedley_reports_well_child_genrate_expected_medication_activities_by_age($age_in_months) {
  if (!isset($age_in_months)) {
    return [];
  }

  $site = variable_get('hedley_general_site_name', '');
  $expected = [];

  switch ($site) {
    case 'burundi':
      // 6 months to 12 years.
      if ($age_in_months >= 6 && $age_in_months < (12 * 12)) {
        $expected[] = 'well_child_albendazole';
      }
      // 6 months to 6 years.
      if ($age_in_months >= 6 && $age_in_months < (6 * 12)) {
        $expected[] = 'well_child_vitamin_a';
      }
      break;

    default:
      // 6 years to 12 years.
      if ($age_in_months >= (6 * 12) && $age_in_months < (12 * 12)) {
        $expected[] = 'well_child_albendazole';
      }
      // 1 year to 6 years.
      if ($age_in_months >= 12 && $age_in_months < (6 * 12)) {
        $expected[] = 'well_child_mebendezole';
      }
      // 6 months to 12 years.
      if ($age_in_months >= 6 && $age_in_months < (6 * 12)) {
        $expected[] = 'well_child_vitamin_a';
      }
      break;
  }

  return $expected;
}

/**
 * Adds Next Steps activities to the expected list, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_well_child_add_next_steps_activities(array $encounter_data, $birth_date_obj, $gender, array &$expected) {
  $measurements_by_type = $encounter_data['measurements_by_type'];

  $assessment = '';
  if (!empty($measurements_by_type['well_child_nutrition'])) {
    $assessment = $measurements_by_type['well_child_nutrition']->field_nutrition_assesment[LANGUAGE_NONE][0]['value'];
  }
  elseif (!empty($measurements_by_type['well_child_follow_up'])) {
    $assessment = $measurements_by_type['well_child_follow_up']->field_nutrition_assesment[LANGUAGE_NONE][0]['value'];
  }

  if (!empty($assessment) && $assessment !== 'none') {
    $expected = array_merge(
      $expected,
      [
        'well_child_contributing_factors',
        'well_child_follow_up',
        'well_child_health_education',
        'well_child_send_to_hc',
      ]
    );
  }
  elseif ($encounter_data['encounter_type'] != 'pediatric-care') {
    $immunisation_activities_completed = TRUE;
    foreach ($expected as $activity) {
      if (hedley_reports_ends_with($activity, '_immunisation')) {
        if (empty($measurements_by_type[$activity])) {
          $immunisation_activities_completed = FALSE;
          break;
        }
      }
    }

    if ($immunisation_activities_completed) {
      $expected_by_progress = hedley_reports_well_child_get_expected_immunisation_activities($encounter_data, $birth_date_obj, $gender, 'progress');
      if (!empty($expected_by_progress)) {
        // Immunisation activity completed, but child is still behind
        // on vaccinations.
        $expected = array_merge($expected, ['well_child_health_education', 'well_child_send_to_hc']);
      }
    }
  }
}

/**
 * Generates completion data for Home Visit encounter.
 *
 * @param object $encounter
 *   The encounter node object.
 *
 * @return array
 *   An array containing the completion data for given encounter.
 */
function hedley_reports_generate_completion_data_for_home_visit_encounter($encounter) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping = [
    'nutrition_caring' => 'a',
    'nutrition_feeding' => 'b',
    'nutrition_food_security' => 'c',
    'nutrition_hygiene' => 'd',
  ];

  // Activities that are always taken during encounter.
  $expected = array_keys($mapping);

  // Resolve encounter start date.
  $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];

  // Loading all measurements that belong to encounter.
  $measurements_ids = hedley_reports_load_individual_encounter_measurements_ids($encounter);

  if (empty($measurements_ids)) {
    $completion = hedley_reports_generate_completion_result($expected, [], $mapping);

    return [
      'start_date' => $start_date,
      'completion' => $completion,
    ];
  }

  // Ordering measurements by type.
  $measurements_by_type = [];
  $measurements = node_load_multiple($measurements_ids);
  foreach ($measurements as $measurement) {
    $measurements_by_type[$measurement->type] = $measurement;
  }

  $completion = hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping);

  return [
    'start_date' => $start_date,
    'completion' => $completion,
  ];
}

/**
 * Generates completion data for Child Scoreboard encounter.
 *
 * @param object $participant
 *   The participant node object with which encounters are associated.
 * @param bool $exclude_set
 *   Indicate whether to exclude encounters with report data already set.
 */
function hedley_reports_generate_completion_data_for_child_scoreboard_encounter($participant, $exclude_set) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping = [
    'child_scoreboard_ncda' => 'a',
    'child_scoreboard_bcg_iz' => 'b',
    'child_scoreboard_dtp_iz' => 'c',
    'child_scoreboard_ipv_iz' => 'd',
    'child_scoreboard_mr_iz' => 'e',
    'child_scoreboard_opv_iz' => 'f',
    'child_scoreboard_pcv13_iz' => 'g',
    'child_scoreboard_rotarix_iz' => 'h',
    'child_scoreboard_dtp_sa_iz' => 'i',

  ];

  // Load all encounters of current participant.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'child_scoreboard_encounter')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_individual_participant', 'target_id', $participant->nid)
    ->propertyOrderBy('nid')
    ->execute();

  if (empty($result['node'])) {
    return;
  }

  // Get birthdate and gender.
  $person_id = $participant->field_person[LANGUAGE_NONE][0]['target_id'];
  try {
    $person = node_load($person_id);
    $birth_date = explode(' ', $person->field_birth_date[LANGUAGE_NONE][0]['value'])[0];
    $birth_date_obj = new DateTime($birth_date);
    $gender = $person->field_gender[LANGUAGE_NONE][0]['value'];
  }
  catch (Exception $e) {
    $birth_date_obj = NULL;
    $gender = 'male';
  }

  // Encounters are sorted ASC.
  $encounters = node_load_multiple(array_keys($result['node']));
  $encounters_data = [];
  foreach ($encounters as $encounter) {
    // Skip encounter if exclusion flag is raised and it's report data is set.
    if ($exclude_set && !empty($encounter->field_reports_data[LANGUAGE_NONE][0]['value'])) {
      continue;
    }

    // Loading all measurements that belong to encounter.
    $measurements_ids = hedley_reports_load_individual_encounter_measurements_ids($encounter);

    $measurements = !empty($measurements_ids) ? node_load_multiple($measurements_ids) : [];
    // Ordering measurements by type.
    $measurements_by_type = [];
    foreach ($measurements as $measurement) {
      $measurements_by_type[$measurement->type] = $measurement;
    }

    $encounters_data[] = [
      'encounter' => $encounter,
      'measurements_by_type' => $measurements_by_type,
    ];
  }

  foreach ($encounters_data as $index => $encounter_data) {
    $encounter = $encounter_data['encounter'];
    $measurements_by_type = $encounter_data['measurements_by_type'];

    $expected = ['child_scoreboard_ncda'];

    // Resolve encounter start date.
    $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
    $start_date_obj = new DateTime($start_date);

    // Checking patient indicated at NCDA questioner that all
    // vaccinations are up to date.
    if (empty($measurements_by_type['child_scoreboard_ncda']) || empty($measurements_by_type['child_scoreboard_ncda']->field_ncda_signs)) {
      $up_to_date_by_ncda_response = FALSE;
    }
    else {
      $behind_by_ncda_response = FALSE;
      $signs = $measurements_by_type['child_scoreboard_ncda']->field_ncda_signs[LANGUAGE_NONE];
      foreach ($signs as $sign) {
        if ($sign['value'] == 'child-behind-on-vaccination') {
          $behind_by_ncda_response = TRUE;
          break;
        }
      }

      $up_to_date_by_ncda_response = !$behind_by_ncda_response;
    }

    // If patient indicated at NCDA questioner that all vaccinations are
    // up to date, we'll check that they were all recorded. If not, we should
    // have immunisation activities to record data currently missing.
    if ($up_to_date_by_ncda_response) {
      $encounter_data['start_date_obj'] = $start_date_obj;

      // Try to resolve age in months at a time encounter was performed.
      $encounter_data['age_in_months'] = hedley_reports_resolve_age_in_months_for_individual_encounter($encounter, $start_date_obj);
      $encounter_data['previous_encounters_data'] = array_slice($encounters_data, 0, $index);

      list($encounter_data['vaccination_history'], $encounter_data['vaccination_progress']) = hedley_reports_child_scoreboard_generate_vaccination_progress_data($person_id, $encounter_data);

      $expected_immunisation_activities = hedley_reports_child_scoreboard_get_expected_immunisation_activities($encounter_data, $birth_date_obj, $gender, 'history');
      $expected = array_merge($expected, $expected_immunisation_activities);
    }

    $completion_data = [
      'start_date' => $start_date,
      'completion' => hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping),
    ];

    $encounter->field_reports_data[LANGUAGE_NONE][0]['value'] = json_encode($completion_data);
    node_save($encounter);
  }
}

/**
 * Generates vaccination progress data for a child scoreboard encounter.
 *
 * This function processes immunisation data from previous and current
 * encounters, generating vaccination history and progress data for
 * child scoreboard encounters. It merges this data with well-child
 * data to produce comprehensive vaccination progress information.
 *
 * @param int $person_id
 *   The ID of the person (child) whose vaccination data is being
 *   processed.
 * @param array $encounter_data
 *   An associative array containing details of the current encounter,
 *   including previous encounter data and measurements.
 *
 * @return array
 *   An array containing merged vaccination progress data, with history
 *   and progress for the child.
 */
function hedley_reports_child_scoreboard_generate_vaccination_progress_data($person_id, array $encounter_data) {
  $previous_encounters_data = $encounter_data['previous_encounters_data'];

  $immunisation_types = [
    'child_scoreboard_bcg_iz',
    'child_scoreboard_dtp_iz',
    'child_scoreboard_ipv_iz',
    'child_scoreboard_mr_iz',
    'child_scoreboard_opv_iz',
    'child_scoreboard_pcv13_iz',
    'child_scoreboard_rotarix_iz',
  ];

  $immunisations_from_previous_encounters = [];
  foreach ($immunisation_types as $immunisation_type) {
    $immunisations_from_previous_encounters[$immunisation_type] = [];
  }

  foreach ($previous_encounters_data as $previous_encounter_data) {
    $measurements_by_type = $previous_encounter_data['measurements_by_type'];
    foreach ($immunisation_types as $immunisation_type) {
      if (empty($measurements_by_type[$immunisation_type])) {
        continue;
      }
      $immunisations_from_previous_encounters[$immunisation_type][] = $measurements_by_type[$immunisation_type];
    }
  }

  $immunisations_from_all_encounters = $immunisations_from_previous_encounters;
  $measurements_by_type = $encounter_data['measurements_by_type'];
  foreach ($immunisation_types as $immunisation_type) {
    if (empty($measurements_by_type[$immunisation_type])) {
      continue;
    }
    $immunisations_from_all_encounters[$immunisation_type][] = $measurements_by_type[$immunisation_type];
  }

  $history_data_by_well_child = hedley_reports_generate_vaccination_progress_data($immunisations_from_previous_encounters, 'child-scoreboard');
  $progress_data_by_well_child = hedley_reports_generate_vaccination_progress_data($immunisations_from_all_encounters, 'child-scoreboard');
  $progress_data_by_child_scoreboard = hedley_reports_child_scoreboard_generate_vaccination_progress_data_by_well_child($person_id, $encounter_data['start_date_obj']);

  return [
    hedley_reports_merge_vaccination_progress_data($immunisation_types, 'child-scoreboard', $history_data_by_well_child, $progress_data_by_child_scoreboard),
    hedley_reports_merge_vaccination_progress_data($immunisation_types, 'child-scoreboard', $progress_data_by_well_child, $progress_data_by_child_scoreboard),
  ];
}

/**
 * Generates a list of expected well-child immunisation activities.
 *
 * This function determines the expected immunisation activities for a
 * well-child based on the child's encounter data, age, gender, and mode.
 * It considers the vaccination history or progress, the site of the encounter,
 * and other factors such as the child's age in days. It then generates a list
 * of immunisations that should be expected during the encounter.
 *
 * @param array $encounter_data
 *   An associative array containing details of the encounter, including
 *   encounter type, vaccination progress, vaccination history, and start date.
 * @param DateTime $birth_date_obj
 *   The DateTime object representing the child's birth date.
 * @param string $gender
 *   The gender of the child, used to determine gender-specific immunisations.
 * @param string $mode
 *   The mode of operation, either 'history' or 'progress', which determines
 *   whether to consider the vaccination history or progress.
 *
 * @return array
 *   An array of expected immunisation activities based on the encounter data.
 */
function hedley_reports_child_scoreboard_get_expected_immunisation_activities(array $encounter_data, DateTime $birth_date_obj, $gender, $mode) {
  $vaccination_progress = $encounter_data['vaccination_progress'];
  // History mode looks at vaccination status excluding vaccinations done at
  // current encounter. Progress mode includes vaccinations done at current
  // encounter.
  $vaccination_history = $mode == 'history' ? $encounter_data['vaccination_history'] : $vaccination_progress;
  $start_date_obj = $encounter_data['start_date_obj'];

  $initial_opv_administered = hedley_reports_initial_opv_administered($encounter_data, $birth_date_obj);
  $interval = $start_date_obj->diff($birth_date_obj);
  $age_in_days = $interval->days;

  $possible_immunisations = ['bcg', 'opv'];
  if ($age_in_days >= (6 * 7)) {
    $possible_immunisations = array_merge(
      $possible_immunisations,
      ['dtp', 'pcv13', 'rotarix']
    );
  }
  if ($age_in_days >= (14 * 7)) {
    $possible_immunisations[] = 'ipv';
  }
  if ($age_in_days >= (36 * 7)) {
    $possible_immunisations[] = 'mr';
  }

  $site = variable_get('hedley_general_site_name', '');
  if ($site == 'burundi') {
    // All 3 doses of DTP were given, it has passed at least 28 days since
    // third dose, and, child is at last 18 months old.
    if (!empty($vaccination_progress['dtp']['dose-3'])) {
      $age_in_months = ($interval->y * 12) + $interval->m;
      $third_dose_date_obj = new DateTime($vaccination_progress['dtp']['dose-3']);
      $interval = $start_date_obj->diff($third_dose_date_obj, TRUE);
      $days_since_third_dose = $interval->days;

      if ($age_in_months >= 18 && $days_since_third_dose >= 28) {
        $possible_immunisations[] = 'dtp_sa';
      }
    }
  }
  else {
    $age_in_years = $interval->y;
    if ($age_in_years >= 12 && $gender == 'female') {
      $possible_immunisations[] = 'hpv';
    }
  }

  $expected = [];
  foreach ($possible_immunisations as $immunisation_type) {
    $immunisation_full_name = "child_scoreboard_{$immunisation_type}_iz";
    if (empty($vaccination_history)) {
      $expected[] = $immunisation_full_name;
      continue;
    }

    $performed = $vaccination_history[$immunisation_type];
    if (empty($performed)) {
      $expected[] = $immunisation_full_name;
      continue;
    }

    $doses = array_keys($performed);
    sort($doses);
    $last_dose = array_reverse($doses)[0];
    $last_dose_for_immunisation = hedley_reports_get_last_dose_for_vaccine($immunisation_type, $initial_opv_administered);
    // If all doses we administered, skipping to next immunisation type.
    if ($last_dose == $last_dose_for_immunisation) {
      continue;
    }

    // Calculating when next dose is supposed to be administered.
    $last_dose_as_number = (int) explode('-', $last_dose)[1];
    $next_dose_as_number = $last_dose_as_number + 1;
    $last_dose_date = $performed[$last_dose];
    $interval_between_dosed = hedley_reports_get_interval_for_vaccine($immunisation_type, $site);
    $last_dose_date_obj = new DateTime($last_dose_date);
    $next_dose_date_obj = clone $last_dose_date_obj;
    $next_dose_date_obj->modify($interval_between_dosed);
    if ($immunisation_type == 'opv' && $next_dose_as_number == 2 && $initial_opv_administered) {
      $six_weeks_old_date_obj = clone $birth_date_obj;
      $six_weeks_old_date_obj->modify('+6 weeks');

      if ($six_weeks_old_date_obj > $next_dose_date_obj) {
        $next_dose_date_obj = $six_weeks_old_date_obj;
      }
    }

    // If encounter started after the date when immunisation was supposed
    // to be administered, adding it as expected.
    if ($start_date_obj >= $next_dose_date_obj) {
      $expected[] = $immunisation_full_name;
    }
  }

  return $expected;
}

/**
 * Generates vaccination progress data based on well-child data.
 *
 * Retrieves immunisation data for a child from the well-child,
 * considering all encounters up to the current child scoreboard encounter,
 * and returns structured vaccination progress data.
 *
 * @param int $person_id
 *   The ID of the person (child) whose scoreboard data is being
 *   processed.
 * @param DateTime $child_scoreboard_encounter_start_date_obj
 *   The DateTime object representing the start date of the current
 *   child scoreboard encounter.
 *
 * @return array
 *   A structured array of vaccination doses and dates, organized by
 *   immunisation type, based on child scoreboard encounters.
 */
function hedley_reports_child_scoreboard_generate_vaccination_progress_data_by_well_child($person_id, DateTime $child_scoreboard_encounter_start_date_obj) {
  $return = [];
  if (empty($person_id)) {
    return $return;
  }

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'individual_participant')
    ->fieldCondition('field_encounter_type', 'value', 'well-child')
    ->fieldCondition('field_person', 'target_id', $person_id)
    ->propertyCondition('status', NODE_PUBLISHED)
    ->addTag('exclude_deleted');

  $result = $query
    ->range(0, 1)
    ->execute();

  if (empty($result['node'])) {
    // No more items left.
    return $return;
  }

  $participant_id = key($result['node']);
  // Load all encounters of current participant.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'well_child_encounter')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_individual_participant', 'target_id', $participant_id)
    ->propertyOrderBy('nid')
    ->execute();

  if (empty($result['node'])) {
    return $return;
  }

  $immunisation_types = [
    'well_child_bcg_immunisation',
    'well_child_dtp_immunisation',
    'well_child_dtp_sa_immunisation',
    'well_child_ipv_immunisation',
    'well_child_mr_immunisation',
    'well_child_opv_immunisation',
    'well_child_pcv13_immunisation',
    'well_child_rotarix_immunisation',
  ];

  $immunisations_by_type = [];
  foreach ($immunisation_types as $immunisation_type) {
    $immunisations_by_type[$immunisation_type] = [
      'doses' => [],
      'dates' => [],
    ];
  }
  $encounters = node_load_multiple(array_keys($result['node']));
  foreach ($encounters as $encounter) {
    $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
    $start_date_obj = new DateTime($start_date);
    if ($start_date_obj > $child_scoreboard_encounter_start_date_obj) {
      // This encounter started after well child encounter, so, skip it.
      continue;
    }

    // Loading all immunisation activities recorded during the encounter.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', $immunisation_types, 'IN')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->fieldCondition('field_well_child_encounter', 'target_id', $encounter->nid)
      ->execute();

    if (empty($result['node'])) {
      continue;
    }

    $immunisations = node_load_multiple(array_keys($result['node']));
    foreach ($immunisations as $immunisation) {
      $doses = $immunisation->field_administered_doses;
      $dates = $immunisation->field_administration_dates;
      if (empty($doses) || empty($dates)) {
        continue;
      }

      $encounter_doses = $encounter_dates = [];
      foreach ($doses[LANGUAGE_NONE] as $dose) {
        $encounter_doses[] = $dose['value'];
      }
      foreach ($dates[LANGUAGE_NONE] as $date) {
        $encounter_dates[] = explode(' ', $date['value'])[0];
      }

      $immunisations_by_type[$immunisation->type]['doses'] = array_merge($immunisations_by_type[$immunisation->type]['doses'], $encounter_doses);
      $immunisations_by_type[$immunisation->type]['dates'] = array_merge($immunisations_by_type[$immunisation->type]['dates'], $encounter_dates);
    }
  }

  foreach ($immunisations_by_type as $type => $item) {
    if (empty($item['doses']) || empty($item['dates'])) {
      continue;
    }

    $immunisations_by_type[$type]['doses'] = array_unique($item['doses']);
    sort($immunisations_by_type[$type]['doses']);
    $immunisations_by_type[$type]['dates'] = array_unique($item['dates']);
    sort($immunisations_by_type[$type]['dates']);
    $total_doses = count($immunisations_by_type[$type]['doses']);
    $total_dates = count($immunisations_by_type[$type]['dates']);

    // Make sure number of doses matches the number of dates.
    if ($total_doses != $total_dates) {
      $common_size = min($total_doses, $total_dates);
      $immunisations_by_type[$type]['doses'] = array_slice($immunisations_by_type[$type]['doses'], 0, $common_size);
      $immunisations_by_type[$type]['dates'] = array_slice($immunisations_by_type[$type]['dates'], 0, $common_size);
    }

    foreach ($immunisations_by_type[$type]['doses'] as $index => $dose) {
      $common_type = hedley_reports_drop_prefix_and_suffix($type, 'well_child_', '_immunisation');
      $return[$common_type][$dose] = $immunisations_by_type[$type]['dates'][$index];
    }
  }

  return $return;
}

/**
 * Generates completion data for NCD encounters for patient.
 *
 * @param object $participant
 *   The participant node object with which encounters are associated.
 * @param bool $exclude_set
 *   Indicate whether to exclude encounters with report data already set.
 */
function hedley_reports_generate_completion_data_for_ncd($participant, $exclude_set) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping = [
    'ncd_core_exam' => 'a',
    'ncd_co_morbidities' => 'b',
    'ncd_creatinine_test' => 'c',
    'ncd_danger_signs' => 'd',
    'ncd_family_history' => 'e',
    'ncd_family_planning' => 'f',
    'ncd_hba1c_test' => 'g',
    'ncd_health_education' => 'h',
    'ncd_hiv_test' => 'i',
    // Not a real activity. Used for data only.
    'ncd_labs_results' => '',
    'ncd_lipid_panel_test' => 'j',
    'ncd_liver_function_test' => 'k',
    'ncd_medication_distribution' => 'l',
    'ncd_medication_history' => 'm',
    'ncd_outside_care' => 'n',
    'ncd_pregnancy_test' => 'o',
    'ncd_random_blood_sugar_test' => 'p',
    'ncd_referral' => 'q',
    'ncd_social_history' => 'r',
    'ncd_symptom_review' => 's',
    'ncd_urine_dipstick_test' => 't',
    'ncd_vitals' => 'u',
    // Logical activities.
    'ncd_creatinine_test_result' => 'v',
    'ncd_lipid_panel_test_result' => 'w',
    'ncd_liver_function_test_result' => 'x',
    'ncd_random_blood_sugar_test_result' => 'y',
    'ncd_urine_dipstick_test_result' => 'z',
  ];

  // Load all encounters of current participant.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'ncd_encounter')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_individual_participant', 'target_id', $participant->nid)
    ->propertyOrderBy('nid')
    ->execute();

  if (empty($result['node'])) {
    return;
  }

  // Get birthdate and gender.
  $person_id = $participant->field_person[LANGUAGE_NONE][0]['target_id'];
  try {
    $person = node_load($person_id);
    $birth_date = explode(' ', $person->field_birth_date[LANGUAGE_NONE][0]['value'])[0];
    $birth_date_obj = new DateTime($birth_date);
    $gender = $person->field_gender[LANGUAGE_NONE][0]['value'];
  }
  catch (Exception $e) {
    $birth_date_obj = NULL;
    $gender = 'male';
  }

  // Encounters are sorted ASC.
  $encounters = node_load_multiple(array_keys($result['node']));
  $encounters_data = [];
  foreach ($encounters as $encounter) {
    // Skip encounter if exclusion flag is raised and it's report data is set.
    if ($exclude_set && !empty($encounter->field_reports_data[LANGUAGE_NONE][0]['value'])) {
      continue;
    }

    // Loading all measurements that belong to encounter.
    $measurements_ids = hedley_reports_load_individual_encounter_measurements_ids($encounter);
    $measurements = !empty($measurements_ids) ? node_load_multiple($measurements_ids) : [];
    // Ordering measurements by type.
    $measurements_by_type = [];
    foreach ($measurements as $measurement) {
      $measurements_by_type[$measurement->type] = $measurement;
    }

    $encounters_data[] = [
      'encounter' => $encounter,
      'measurements_by_type' => $measurements_by_type,
    ];
  }

  foreach ($encounters_data as $index => $encounter_data) {
    $encounter = $encounter_data['encounter'];
    $measurements_by_type = $encounter_data['measurements_by_type'];

    // Resolve encounter start date.
    $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
    $start_date_obj = new DateTime($start_date);
    $encounter_data['start_date_obj'] = $start_date_obj;

    // Try to resolve age in months at a time encounter was performed.
    $encounter_data['age_in_months'] = hedley_reports_resolve_age_in_months_for_individual_encounter($encounter, $start_date_obj);
    $encounter_data['previous_encounters_data'] = array_slice($encounters_data, 0, $index);

    // So far we were constructing data structures to resolve encounter data.
    // Now we have enough info to determine which activities were expected.
    $expected = hedley_reports_ncd_generate_expected_initial_activities($encounter_data, $birth_date_obj, $gender);

    // If conditions match, add labs activities.
    hedley_reports_ncd_add_labs_activities($encounter_data, $birth_date_obj, $gender, $expected);
    // If conditions match, add next steps activities.
    hedley_reports_ncd_add_next_steps_activities($encounter_data, $expected);

    // Adding labs test results activities. Since those are logically derived,
    // and not actual content, we apply proprietary logic per records recorded
    // at labs results content.
    $labs_results = $measurements_by_type['ncd_labs_results'];
    if (!empty($labs_results)) {
      if (!empty($labs_results->field_performed_tests)) {
        $performed_tests = $labs_results->field_performed_tests[LANGUAGE_NONE];
        foreach ($performed_tests as $performed_test) {
          switch ($performed_test['value']) {
            case 'creatinine':
              $expected[] = 'ncd_creatinine_test_result';
              break;

            case 'lipid-panel':
              $expected[] = 'ncd_lipid_panel_test_result';
              break;

            case 'liver-function':
              $expected[] = 'ncd_liver_function_test_result';
              break;

            case 'random-blood-sugar':
              $expected[] = 'ncd_random_blood_sugar_test_result';
              break;

            case 'urine-dipstick':
              $expected[] = 'ncd_urine_dipstick_test_result';
              break;
          }
        }
      }

      if (!empty($labs_results->field_completed_tests)) {
        $completed_tests = $labs_results->field_completed_tests[LANGUAGE_NONE];
        foreach ($completed_tests as $completed_test) {
          switch ($completed_test['value']) {
            case 'creatinine':
              $measurements_by_type['ncd_creatinine_test_result'] = 'dummy';
              break;

            case 'lipid-panel':
              $measurements_by_type['ncd_lipid_panel_test_result'] = 'dummy';
              break;

            case 'liver-function':
              $measurements_by_type['ncd_liver_function_test_result'] = 'dummy';
              break;

            case 'random-blood-sugar':
              $measurements_by_type['ncd_random_blood_sugar_test_result'] = 'dummy';
              break;

            case 'urine-dipstick':
              $measurements_by_type['ncd_urine_dipstick_test_result'] = 'dummy';
              break;
          }
        }
      }
    }

    $completion_data = [
      'start_date' => $start_date,
      'completion' => hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping),
    ];

    $encounter->field_reports_data[LANGUAGE_NONE][0]['value'] = json_encode($completion_data);
    node_save($encounter);
  }
}

/**
 * Generates the list of expected activities for an acute illness encounter.
 *
 * Here we add activities with simple logic.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 *
 * @return array
 *   An array of expected activity names.
 */
function hedley_reports_ncd_generate_expected_initial_activities(array $encounter_data, $birth_date_obj, $gender) {
  $start_date_obj = $encounter_data['start_date_obj'];

  $expected = [
    'ncd_danger_signs',
    'ncd_symptom_review',
    'ncd_core_exam',
    'ncd_vitals',
  ];

  // If fertile woman, add Family Planning.
  if ($gender == 'female' && !empty($birth_date_obj)) {
    $interval = $start_date_obj->diff($birth_date_obj);
    $age_in_years = $interval->y;

    if ($age_in_years >= 13 && $age_in_years <= 44) {
      $expected[] = 'ncd_family_planning';
    }
  }

  // If first encounter, add all Medical History activities.
  if (empty($encounter_data['previous_encounters_data'])) {
    $expected = array_merge(
      $expected,
      [
        'ncd_co_morbidities',
        'ncd_medication_history',
        'ncd_social_history',
        'ncd_family_history',
        'ncd_outside_care',
      ]
    );
  }
  // If subsequent encounter, add Outside Care.
  else {
    $expected[] = 'ncd_outside_care';
  }

  return $expected;
}

/**
 * Adds Labs activities to the expected list, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param DateTime $birth_date_obj
 *   The DateTime object representing the child's birth date.
 * @param string $gender
 *   The gender of the child, used to determine gender-specific immunisations.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_ncd_add_labs_activities(array $encounter_data, DateTime $birth_date_obj, $gender, array &$expected) {
  // Blood sugar test is performed unconditionally.
  $expected[] = 'ncd_random_blood_sugar_test';

  $tests_dates_by_lab_type = [
    'ncd_creatinine_test' => [],
    'ncd_hba1c_test' => [],
    'ncd_hiv_test' => [],
    'ncd_lipid_panel_test' => [],
    'ncd_liver_function_test' => [],
    'ncd_pregnancy_test' => [],
    'ncd_urine_dipstick_test' => [],
  ];
  $hiv_known_as_positive = FALSE;

  // Reversing, to have most recent dates first.
  $previous_encounters_data = array_reverse($encounter_data['previous_encounters_data']);
  foreach ($previous_encounters_data as $previous_encounter_data) {
    $measurements_by_type = $previous_encounter_data['measurements_by_type'];

    $creatinine_test = $measurements_by_type['ncd_creatinine_test'];
    if (hedley_reports_lab_test_performed_by_execution_note($creatinine_test)) {
      $date_measured = explode(' ', $creatinine_test->field_date_measured[LANGUAGE_NONE][0]['value'])[0];
      $date_measured_obj = new DateTime($date_measured);
      $diff_days = $encounter_data['start_date_obj']->diff($date_measured_obj, TRUE)->days;
      $results_exists = !empty($creatinine_test->field_creatinine_result) && !empty($creatinine_test->field_creatinine_result[LANGUAGE_NONE][0]['value']);
      if ($results_exists || $diff_days <= HEDLEY_GENERAL_LAB_EXPIRATION_PERIOD) {
        $tests_dates_by_lab_type['ncd_creatinine_test'][] = explode(' ', $creatinine_test->field_execution_date[LANGUAGE_NONE][0]['value'])[0];
      }
    }

    $hba1c_test = $measurements_by_type['ncd_hba1c_test'];
    if (hedley_reports_lab_test_performed_by_execution_note($hba1c_test)) {
      $date_measured = explode(' ', $hba1c_test->field_date_measured[LANGUAGE_NONE][0]['value'])[0];
      $date_measured_obj = new DateTime($date_measured);
      $diff_days = $encounter_data['start_date_obj']->diff($date_measured_obj, TRUE)->days;
      $results_exists = !empty($hba1c_test->field_hba1c_result) && !empty($hba1c_test->field_hba1c_result[LANGUAGE_NONE][0]['value']);
      if ($results_exists || $diff_days <= HEDLEY_GENERAL_LAB_EXPIRATION_PERIOD) {
        $tests_dates_by_lab_type['ncd_hba1c_test'][] = explode(' ', $hba1c_test->field_execution_date[LANGUAGE_NONE][0]['value'])[0];
      }
    }

    $hiv_test = $measurements_by_type['ncd_hiv_test'];
    if (!$hiv_known_as_positive) {
      if (!empty($hiv_test) && !empty($hiv_test->field_test_execution_note)) {
        $hiv_known_as_positive = $hiv_test->field_test_execution_note[LANGUAGE_NONE][0]['value'] == 'known-as-positive';
        if (!$hiv_known_as_positive && hedley_reports_lab_test_performed_by_execution_note($hiv_test)) {
          $date_measured = explode(' ', $hiv_test->field_date_measured[LANGUAGE_NONE][0]['value'])[0];
          $date_measured_obj = new DateTime($date_measured);
          $diff_days = $encounter_data['start_date_obj']->diff($date_measured_obj, TRUE)->days;
          $valid_results_exists =
            !empty($hiv_test->field_test_result) &&
            !empty($hiv_test->field_test_result[LANGUAGE_NONE][0]['value']) &&
            $hiv_test->field_test_result[LANGUAGE_NONE][0]['value'] != 'indeterminate';
          if ($valid_results_exists || $diff_days <= HEDLEY_GENERAL_LAB_EXPIRATION_PERIOD) {
            $tests_dates_by_lab_type['ncd_hiv_test'][] = explode(' ', $hiv_test->field_execution_date[LANGUAGE_NONE][0]['value'])[0];
          }
        }
      }
    }

    $lipid_panel_test = $measurements_by_type['ncd_lipid_panel_test'];
    if (hedley_reports_lab_test_performed_by_execution_note($lipid_panel_test)) {
      $date_measured = explode(' ', $lipid_panel_test->field_date_measured[LANGUAGE_NONE][0]['value'])[0];
      $date_measured_obj = new DateTime($date_measured);
      $diff_days = $encounter_data['start_date_obj']->diff($date_measured_obj, TRUE)->days;
      $results_exists = !empty($lipid_panel_test->field_total_cholesterol) && !empty($lipid_panel_test->field_total_cholesterol[LANGUAGE_NONE][0]['value']);
      if ($results_exists || $diff_days <= HEDLEY_GENERAL_LAB_EXPIRATION_PERIOD) {
        $tests_dates_by_lab_type['ncd_lipid_panel_test'][] = explode(' ', $lipid_panel_test->field_execution_date[LANGUAGE_NONE][0]['value'])[0];
      }
    }

    $liver_function_test = $measurements_by_type['ncd_liver_function_test'];
    if (hedley_reports_lab_test_performed_by_execution_note($liver_function_test)) {
      $date_measured = explode(' ', $liver_function_test->field_date_measured[LANGUAGE_NONE][0]['value'])[0];
      $date_measured_obj = new DateTime($date_measured);
      $diff_days = $encounter_data['start_date_obj']->diff($date_measured_obj, TRUE)->days;
      $results_exists = !empty($liver_function_test->field_alt_result) && !empty($liver_function_test->field_alt_result[LANGUAGE_NONE][0]['value']);
      if ($results_exists || $diff_days <= HEDLEY_GENERAL_LAB_EXPIRATION_PERIOD) {
        $tests_dates_by_lab_type['ncd_liver_function_test'][] = explode(' ', $liver_function_test->field_execution_date[LANGUAGE_NONE][0]['value'])[0];
      }
    }

    $pregnancy_test = $measurements_by_type['ncd_pregnancy_test'];
    if (hedley_reports_lab_test_performed_by_execution_note($pregnancy_test)) {
      $date_measured = explode(' ', $pregnancy_test->field_date_measured[LANGUAGE_NONE][0]['value'])[0];
      $date_measured_obj = new DateTime($date_measured);
      $diff_days = $encounter_data['start_date_obj']->diff($date_measured_obj, TRUE)->days;
      $valid_results_exists =
        !empty($hiv_test->field_test_result) &&
        !empty($hiv_test->field_test_result[LANGUAGE_NONE][0]['value']) &&
        $hiv_test->field_test_result[LANGUAGE_NONE][0]['value'] != 'indeterminate';
      if ($valid_results_exists || $diff_days <= HEDLEY_GENERAL_LAB_EXPIRATION_PERIOD) {
        $tests_dates_by_lab_type['ncd_pregnancy_test'][] = explode(' ', $pregnancy_test->field_execution_date[LANGUAGE_NONE][0]['value'])[0];
      }
    }

    $urine_dipstick_test = $measurements_by_type['ncd_urine_dipstick_test'];
    if (hedley_reports_lab_test_performed_by_execution_note($urine_dipstick_test)) {
      $date_measured = explode(' ', $urine_dipstick_test->field_date_measured[LANGUAGE_NONE][0]['value'])[0];
      $date_measured_obj = new DateTime($date_measured);
      $diff_days = $encounter_data['start_date_obj']->diff($date_measured_obj, TRUE)->days;
      $results_exists = !empty($urine_dipstick_test->field_protein) && !empty($urine_dipstick_test->field_protein[LANGUAGE_NONE][0]['value']);
      if ($results_exists || $diff_days <= HEDLEY_GENERAL_LAB_EXPIRATION_PERIOD) {
        $tests_dates_by_lab_type['ncd_urine_dipstick_test'][] = explode(' ', $urine_dipstick_test->field_execution_date[LANGUAGE_NONE][0]['value'])[0];
      }
    }
  }

  foreach ($tests_dates_by_lab_type as $test_name => $dates_by_lab_type) {
    $last_date = reset($dates_by_lab_type);
    switch ($test_name) {
      case 'ncd_creatinine_test':
        if (hedley_reports_recurrent_test_required($last_date, $encounter_data['start_date_obj'], 12)) {
          $expected[] = 'ncd_creatinine_test';
        }
        break;

      case 'ncd_hba1c_test':
        if (hedley_reports_recurrent_test_required($last_date, $encounter_data['start_date_obj'], 6)) {
          $expected[] = 'ncd_hba1c_test';
        }
        break;

      case 'ncd_hiv_test':
        if (!$hiv_known_as_positive && empty($last_date)) {
          $expected[] = 'ncd_hiv_test';
        }
        break;

      case 'ncd_lipid_panel_test':
        if (hedley_reports_recurrent_test_required($last_date, $encounter_data['start_date_obj'], 12)) {
          $expected[] = 'ncd_lipid_panel_test';
        }
        break;

      case 'ncd_liver_function_test':
        if (hedley_reports_recurrent_test_required($last_date, $encounter_data['start_date_obj'], 12)) {
          $expected[] = 'ncd_liver_function_test';
        }
        break;

      case 'ncd_pregnancy_test':
        if (empty($last_date)) {
          if ($gender == 'female' && !empty($birth_date_obj)) {
            $interval = $encounter_data['start_date_obj']->diff($birth_date_obj);
            $age_in_years = $interval->y;

            if ($age_in_years >= 13 && $age_in_years <= 44) {
              $expected[] = 'ncd_pregnancy_test';
            }
          }
        }
        break;

      case 'ncd_urine_dipstick_test':
        if (hedley_reports_recurrent_test_required($last_date, $encounter_data['start_date_obj'], 12)) {
          $expected[] = 'ncd_urine_dipstick_test';
        }
        break;
    }
  }
}

/**
 * Adds Next Steps activities to the expected list, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_ncd_add_next_steps_activities(array $encounter_data, array &$expected) {
  // Resolving diagnoses from current encounter.
  $current_encounter = $encounter_data['encounter'];
  $measurements_by_type = $encounter_data['measurements_by_type'];
  $current_encounter_diagnoses = [];
  if (!empty($current_encounter->field_ncd_diagnoses)) {
    foreach ($current_encounter->field_ncd_diagnoses[LANGUAGE_NONE] as $diagnosis) {
      if ($diagnosis['value'] != 'none') {
        $current_encounter_diagnoses[] = $diagnosis['value'];
      }
    }
  }

  // Resolving diagnoses from previous encounters.
  $previous_encounters_diagnoses = [];
  // Reversing, to have most recent dates first.
  $previous_encounters_data = array_reverse($encounter_data['previous_encounters_data']);
  foreach ($previous_encounters_data as $previous_encounter_data) {
    $previous_encounter = $previous_encounter_data['encounter'];
    if (!empty($previous_encounter->field_ncd_diagnoses)) {
      foreach ($previous_encounter->field_ncd_diagnoses[LANGUAGE_NONE] as $diagnosis) {
        if ($diagnosis['value'] != 'none') {
          $previous_encounters_diagnoses[] = $diagnosis['value'];
        }
      }
    }
  }

  // Checking is patient is pregnant.
  $patient_pregnant = FALSE;
  $pregnancy_test = $measurements_by_type['ncd_pregnancy_test'];
  if (!empty(($pregnancy_test->field_test_execution_note))) {
    $patient_pregnant = $pregnancy_test->field_test_execution_note[LANGUAGE_NONE][0]['value'] == 'known-as-positive';
  }
  if (!$patient_pregnant &&!empty(($pregnancy_test->field_test_result))) {
    $patient_pregnant = $pregnancy_test->field_test_result[LANGUAGE_NONE][0]['value'] == 'positive';
  }

  $hypertension_diagnoses = [
    'hypertension-stage1',
    'hypertension-stage2',
    'hypertension-stage3',
  ];
  $diabetes_diagnoses = ['diabetes-initial', 'diabetes-recurrent'];
  $diabetes_diagnoses_with_renal = array_merge($diabetes_diagnoses, ['renal-complications']);

  if (
    !$patient_pregnant &&
    in_array('hypertension-stage1', $current_encounter_diagnoses) &&
    empty(array_intersect($previous_encounters_diagnoses, $hypertension_diagnoses)) &&
    empty(
      array_intersect(
        $current_encounter_diagnoses,
        ['renal-complications', 'diabetes-initial']
      )
    ) &&
    empty(array_intersect($previous_encounters_diagnoses, $diabetes_diagnoses_with_renal))
  ) {
    $expected[] = 'ncd_health_education';
  }

  // List of all diagnoses. Most recent one comes first.
  $all_diagnoses = array_merge($current_encounter_diagnoses, $previous_encounters_diagnoses);

  // Checking if Medication Distribution is expected.
  $medicated_for_diabetes = !empty(array_intersect($all_diagnoses, $diabetes_diagnoses));

  $current_hypertension_stage = '';
  foreach ($all_diagnoses as $diagnosis) {
    if (in_array($diagnosis, $hypertension_diagnoses)) {
      $current_hypertension_stage = $diagnosis;
      break;
    }
  }

  $medicate_for_hypertension_initial_phase = FALSE;
  if (!empty($current_hypertension_stage)) {
    if ($current_hypertension_stage == 'hypertension-stage1') {
      if (
        $patient_pregnant ||
        in_array('diabetes-initial', $current_encounter_diagnoses) ||
        !empty(array_intersect($previous_encounters_diagnoses, $hypertension_diagnoses)) ||
        !empty(array_intersect($previous_encounters_diagnoses, $diabetes_diagnoses_with_renal))
      ) {
        $medicate_for_hypertension_initial_phase = TRUE;
      }
    }
    else {
      $medicate_for_hypertension_initial_phase = TRUE;
    }
  }

  $medicate_for_hypertension_recurrent_phase = FALSE;
  if (!$medicate_for_hypertension_initial_phase) {
    if (
      in_array('hypertension-stage1', $current_encounter_diagnoses) &&
      !empty(
        array_intersect(
          $current_encounter_diagnoses,
          ['renal-complications', 'diabetes-recurrent']
        )
      ) &&
      empty(array_intersect($previous_encounters_diagnoses, $hypertension_diagnoses)) &&
      empty(array_intersect($previous_encounters_diagnoses, $diabetes_diagnoses_with_renal))
    ) {
      $medicate_for_hypertension_recurrent_phase = TRUE;
    }
  }
  $medicate_for_hypertension = $medicate_for_hypertension_initial_phase || $medicate_for_hypertension_recurrent_phase;

  if ($medicated_for_diabetes || $medicate_for_hypertension) {
    $expected[] = 'ncd_medication_distribution';
  }

  // Checking if Referral is expected.
  $refer_for_hypertension = FALSE;
  if (!empty($current_hypertension_stage)) {
    $refer_for_hypertension = $patient_pregnant || ($current_hypertension_stage == 'hypertension-stage3');
  }

  $refer_for_diabetes = FALSE;
  if (!empty($current_hypertension_stage)) {
    $refer_for_diabetes = !empty(array_intersect($all_diagnoses, $diabetes_diagnoses));
  }

  $refer_for_renal_omplications = FALSE;
  if (!empty($current_hypertension_stage)) {
    $refer_for_renal_omplications = in_array('renal-complications', $all_diagnoses);
  }

  if ($refer_for_hypertension || $refer_for_diabetes || $refer_for_renal_omplications) {
    $expected[] = 'ncd_referral';
  }
}

/**
 * Generates completion data for HIV encounters for patient.
 *
 * @param object $participant
 *   The participant node object with which encounters are associated.
 * @param bool $exclude_set
 *   Indicate whether to exclude encounters with report data already set.
 */
function hedley_reports_generate_completion_data_for_hiv($participant, $exclude_set) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping = [
    'hiv_diagnostics' => 'a',
    'hiv_follow_up' => 'b',
    'hiv_health_education' => 'c',
    'hiv_medication' => 'd',
    'hiv_referral' => 'e',
    'hiv_symptom_review' => 'f',
    'hiv_treatment_review' => 'g',
  ];

  // Load all encounters of current participant.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'hiv_encounter')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_individual_participant', 'target_id', $participant->nid)
    ->propertyOrderBy('nid')
    ->execute();

  if (empty($result['node'])) {
    return;
  }

  // Encounters are sorted ASC.
  $encounters = node_load_multiple(array_keys($result['node']));
  $encounters_data = [];
  foreach ($encounters as $encounter) {
    // Skip encounter if exclusion flag is raised and it's report data is set.
    if ($exclude_set && !empty($encounter->field_reports_data[LANGUAGE_NONE][0]['value'])) {
      continue;
    }

    // Loading all measurements that belong to encounter.
    $measurements_ids = hedley_reports_load_individual_encounter_measurements_ids($encounter);
    $measurements = !empty($measurements_ids) ? node_load_multiple($measurements_ids) : [];
    // Ordering measurements by type.
    $measurements_by_type = [];
    foreach ($measurements as $measurement) {
      $measurements_by_type[$measurement->type] = $measurement;
    }

    $encounters_data[] = [
      'encounter' => $encounter,
      'measurements_by_type' => $measurements_by_type,
    ];
  }

  foreach ($encounters_data as $index => $encounter_data) {
    $encounter = $encounter_data['encounter'];
    $measurements_by_type = $encounter_data['measurements_by_type'];

    // Resolve encounter start date.
    $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
    $previous_encounters_data = array_slice($encounters_data, 0, $index);

    // So far we were constructing data structures to resolve encounter data.
    // Now we have enough info to determine which activities were expected.
    $completed = array_keys($measurements_by_type);

    $expected = ['hiv_medication'];
    if (empty($previous_encounters_data)) {
      $expected[] = 'hiv_diagnostics';

      if (in_array('hiv_medication', $completed)) {
        $expected[] = 'hiv_treatment_review';
      }
    }
    else {
      $expected = array_merge(
        $expected,
        ['hiv_symptom_review', 'hiv_treatment_review']
      );
    }

    // Checking which Next Steps activities to expect.
    $mandatory_activities = [
      'hiv_diagnostics',
      'hiv_medication',
      'hiv_symptom_review',
    ];
    // Here we consider activity as completed, if it was expected,
    // and we actually see it as completed at encounter measurements.
    // If not expected, we consider it completed.
    $mandatory_activities_completed = TRUE;
    foreach ($mandatory_activities as $activity) {
      if (in_array($activity, $expected) && !in_array($activity, $completed)) {
        $mandatory_activities_completed = FALSE;
        break;
      }
    }

    if ($mandatory_activities_completed) {
      $expected = array_merge(
        $expected,
        ['hiv_follow_up', 'hiv_health_education']
      );

      // Referral is expected, if there was reported symptom or adverse event.
      // Checking if symptom was reported.
      $symptom_reported = FALSE;
      $symptom_review = $measurements_by_type['hiv_symptom_review'];
      if (!empty($symptom_review) && !empty($symptom_review->field_hiv_symptoms)) {
        $symptoms = $symptom_review->field_hiv_symptoms[LANGUAGE_NONE];
        foreach ($symptoms as $symptom) {
          if ($symptom['value'] != 'none') {
            // Symptom was reported. Add Referral to expected list.
            $expected[] = 'hiv_referral';
            // Raise flag, as there's no need to check for adverse events.
            $symptom_reported = TRUE;
            break;
          }
        }
      }

      // If symptom was not reported, checking for adverse event.
      if (!$symptom_reported) {
        $treatment_review = $measurements_by_type['hiv_treatment_review'];
        if (!empty($treatment_review) && !empty($treatment_review->field_adverse_events)) {
          $adverse_events = $treatment_review->field_adverse_events[LANGUAGE_NONE];
          foreach ($adverse_events as $adverse_event) {
            if ($adverse_event['value'] != 'none') {
              $expected[] = 'hiv_referral';
              break;
            }
          }
        }
      }
    }

    $completion_data = [
      'start_date' => $start_date,
      'completion' => hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping),
    ];

    $encounter->field_reports_data[LANGUAGE_NONE][0]['value'] = json_encode($completion_data);
    node_save($encounter);
  }
}

/**
 * Generates completion data for Tuberculosis encounters for patient.
 *
 * @param object $participant
 *   The participant node object with which encounters are associated.
 * @param bool $exclude_set
 *   Indicate whether to exclude encounters with report data already set.
 */
function hedley_reports_generate_completion_data_for_tuberculosis($participant, $exclude_set) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping = [
    'tuberculosis_diagnostics' => 'a',
    'tuberculosis_dot' => 'b',
    'tuberculosis_follow_up' => 'c',
    'tuberculosis_health_education' => 'd',
    'tuberculosis_medication' => 'e',
    'tuberculosis_referral' => 'f',
    'tuberculosis_symptom_review' => 'g',
    'tuberculosis_treatment_review' => 'h',
  ];

  // Load all encounters of current participant.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'tuberculosis_encounter')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_individual_participant', 'target_id', $participant->nid)
    ->propertyOrderBy('nid')
    ->execute();

  if (empty($result['node'])) {
    return;
  }

  // Encounters are sorted ASC.
  $encounters = node_load_multiple(array_keys($result['node']));
  $encounters_data = [];
  foreach ($encounters as $encounter) {
    // Skip encounter if exclusion flag is raised and it's report data is set.
    if ($exclude_set && !empty($encounter->field_reports_data[LANGUAGE_NONE][0]['value'])) {
      continue;
    }

    // Loading all measurements that belong to encounter.
    $measurements_ids = hedley_reports_load_individual_encounter_measurements_ids($encounter);
    $measurements = !empty($measurements_ids) ? node_load_multiple($measurements_ids) : [];
    // Ordering measurements by type.
    $measurements_by_type = [];
    foreach ($measurements as $measurement) {
      $measurements_by_type[$measurement->type] = $measurement;
    }

    $encounters_data[] = [
      'encounter' => $encounter,
      'measurements_by_type' => $measurements_by_type,
    ];
  }

  foreach ($encounters_data as $index => $encounter_data) {
    $encounter = $encounter_data['encounter'];
    $measurements_by_type = $encounter_data['measurements_by_type'];

    // Resolve encounter start date.
    $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
    $previous_encounters_data = array_slice($encounters_data, 0, $index);

    // So far we were constructing data structures to resolve encounter data.
    // Now we have enough info to determine which activities were expected.
    $completed = array_keys($measurements_by_type);

    $expected = ['tuberculosis_medication'];
    if (in_array('tuberculosis_medication', $completed)) {
      $expected = array_merge(
        $expected,
        ['tuberculosis_dot', 'tuberculosis_treatment_review']
      );
    }
    if (empty($previous_encounters_data)) {
      $expected[] = 'tuberculosis_diagnostics';
    }
    else {
      $expected[] = 'tuberculosis_symptom_review';
    }

    // Checking which Next Steps activities to expect.
    $mandatory_activities = [
      'tuberculosis_diagnostics',
      'tuberculosis_medication',
      'tuberculosis_symptom_review',
    ];
    // Here we consider activity as completed, if it was expected,
    // and we actually see it as completed at encounter measurements.
    // If not expected, we consider it completed.
    $mandatory_activities_completed = TRUE;
    foreach ($mandatory_activities as $activity) {
      if (in_array($activity, $expected) && !in_array($activity, $completed)) {
        $mandatory_activities_completed = FALSE;
        break;
      }
    }

    if ($mandatory_activities_completed) {
      $expected = array_merge(
        $expected,
        ['tuberculosis_follow_up', 'tuberculosis_health_education']
      );

      // Referral is expected, if there was reported symptom or adverse event.
      // Checking if symptom was reported.
      $symptom_reported = FALSE;
      $symptom_review = $measurements_by_type['tuberculosis_symptom_review'];
      if (!empty($symptom_review) && !empty($symptom_review->field_tuberculosis_symptoms)) {
        $symptoms = $symptom_review->field_tuberculosis_symptoms[LANGUAGE_NONE];
        foreach ($symptoms as $symptom) {
          if ($symptom['value'] != 'none') {
            // Symptom was reported. Add Referral to expected list.
            $expected[] = 'tuberculosis_referral';
            // Raise flag, as there's no need to check for adverse events.
            $symptom_reported = TRUE;
            break;
          }
        }
      }

      // If symptom was not reported, checking for adverse event.
      if (!$symptom_reported) {
        $treatment_review = $measurements_by_type['tuberculosis_treatment_review'];
        if (!empty($treatment_review) && !empty($treatment_review->field_adverse_events)) {
          $adverse_events = $treatment_review->field_adverse_events[LANGUAGE_NONE];
          foreach ($adverse_events as $adverse_event) {
            if ($adverse_event['value'] != 'none') {
              $expected[] = 'tuberculosis_referral';
              break;
            }
          }
        }
      }
    }

    $completion_data = [
      'start_date' => $start_date,
      'completion' => hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping),
    ];

    $encounter->field_reports_data[LANGUAGE_NONE][0]['value'] = json_encode($completion_data);
    node_save($encounter);
  }
}

function hedley_reports_generate_completion_data_for_prenatal($participant, $exclude_set) {
  // To reduce memory usage, mapping measurement types as single characters.
  $mapping = [
    'appointment_confirmation' => 'a',
    'birth_plan' => 'b',
    'breast_exam' => 'c',
    'core_physical_exam' => 'd',
    'danger_signs' => 'e',
    'last_menstrual_period' => 'f',
    'medical_history' => 'g',
    'medication' => 'h',
    'obstetric_history' => 'i',
    'obstetric_history_step2' => 'j',
    'obstetrical_exam' => 'k',
    'pregnancy_testing' => 'l',
    'prenatal_blood_gprs_test' => 'm',
    'prenatal_breastfeeding' => 'n',
    'prenatal_family_planning' => 'o',
    'prenatal_follow_up' => 'p',
    'prenatal_gu_exam' => 'q',
    'prenatal_health_education' => 'r',
    'prenatal_hemoglobin_test' => 's',
    'prenatal_hepatitis_b_test' => 't',
    'prenatal_hiv_pcr_test' => 'u',
    'prenatal_hiv_test' => 'v',
    // Not a real activity. Used for data only.
    'prenatal_labs_results' => '',
    'prenatal_malaria_test' => 'w',
    'prenatal_medication_distribution' => 'x',
    'prenatal_mental_health' => 'y',
    'prenatal_nutrition' => 'z',
    'prenatal_outside_care' => '0',
    'prenatal_partner_hiv_test' => '1',
    'prenatal_photo' => '2',
    'prenatal_random_blood_sugar_test' => '3',
    'prenatal_send_to_hc' => '4',
    'prenatal_speciality_care' => '5',
    'prenatal_symptom_review' => '6',
    'prenatal_syphilis_test' => '7',
    'prenatal_tetanus_immunisation' => '8',
    'prenatal_urine_dipstick_test' => '9',
    'resource' => '@',
    'social_history' => '#',
    'vitals' => '$',
  ];

  // Load all encounters of current participant.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'prenatal_encounter')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_individual_participant', 'target_id', $participant->nid)
    ->propertyOrderBy('nid')
    ->execute();

  if (empty($result['node'])) {
    return;
  }

  // Encounters are sorted ASC.
  $encounters = node_load_multiple(array_keys($result['node']));
  $encounters_data = [];
  foreach ($encounters as $encounter) {
    // Skip encounter if exclusion flag is raised and it's report data is set.
    if ($exclude_set && !empty($encounter->field_reports_data[LANGUAGE_NONE][0]['value'])) {
      continue;
    }

    // If encounter type field is empty, we default to 'nurse'.
    if (empty($encounter->field_prenatal_encounter_type)) {
      $encounter_type = 'nurse';
    }
    else {
      $encounter_type = $encounter->field_prenatal_encounter_type[LANGUAGE_NONE][0]['value'];
    }

    $diagnoses = $past_diagnoses = [];
    if (!empty($encounter->field_prenatal_diagnoses) && !empty($encounter->field_prenatal_diagnoses[LANGUAGE_NONE])) {
      foreach ($encounter->field_prenatal_diagnoses[LANGUAGE_NONE] as $diagnosis) {
        if ($diagnosis['value'] != 'none') {
          $diagnoses[] = $diagnosis['value'];
        }
      }
    }

    if (!empty($encounter->field_past_prenatal_diagnoses) && !empty($encounter->field_past_prenatal_diagnoses[LANGUAGE_NONE])) {
      foreach ($encounter->field_past_prenatal_diagnoses[LANGUAGE_NONE] as $diagnosis) {
        if ($diagnosis['value'] != 'none') {
          $past_diagnoses[] = $diagnosis['value'];
        }
      }
    }

    // Loading all measurements that belong to encounter.
    $measurements_ids = hedley_reports_load_individual_encounter_measurements_ids($encounter);
    $measurements = !empty($measurements_ids) ? node_load_multiple($measurements_ids) : [];
    // Ordering measurements by type.
    $measurements_by_type = [];
    foreach ($measurements as $measurement) {
      $measurements_by_type[$measurement->type] = $measurement;
    }

    $encounters_data[] = [
      'encounter' => $encounter,
      'encounter_type' => $encounter_type,
      'diagnoses' => $diagnoses,
      'past_diagnoses' => $past_diagnoses,
      'measurements_by_type' => $measurements_by_type,
    ];
  }

  foreach ($encounters_data as $index => $encounter_data) {
    $encounter = $encounter_data['encounter'];
    $measurements_by_type = $encounter_data['measurements_by_type'];

    // Resolve encounter start date.
    $start_date = explode(' ', $encounter->field_scheduled_date[LANGUAGE_NONE][0]['value'])[0];
    $start_date_obj = new DateTime($start_date);
    $encounter_data['start_date_obj'] = $start_date_obj;

    // Resolve and partition previous encounters data.
    $previous_encounters_data = array_slice($encounters_data, 0, $index);
    $previous_nurse_encounters_data =  $previous_chw_encounters_data = [];
    foreach ($previous_encounters_data as $previous_encounter_data) {
      $encounter_type = $previous_encounter_data['encounter_type'];
      if (in_array($encounter_type, ['nurse', 'nurse-postpartum'])) {
        $previous_nurse_encounters_data[] = $previous_encounter_data;
      }
      else {
        $previous_chw_encounters_data[] = $previous_encounter_data;
      }
    }
    $encounter_data['previous_nurse_encounters_data'] = $previous_nurse_encounters_data;
    $encounter_data['previous_chw_encounters_data'] = $previous_chw_encounters_data;

    // Resolving global LMP date.
    // First, we check for value at previous nurse encounters.
    $lmp_date = NULL;
    foreach ($previous_nurse_encounters_data as $previous_nurse_encounter_data) {
      $lmp_measurement = $previous_nurse_encounter_data['measurements_by_type']['last_menstrual_period'];
      if (empty($lmp_measurement) || empty($lmp_measurement->field_last_menstrual_period[LANGUAGE_NONE])) {
        continue;
      }
      $lmp_date = explode(' ', $lmp_measurement->field_last_menstrual_period[LANGUAGE_NONE][0]['value']);
      break;
    }
    // No value found at previous nurse encounters - check current encounter.
    if (empty($lmp_date)) {
      $lmp_measurement = $measurements_by_type['last_menstrual_period'];
      if (!empty($lmp_measurement) && !empty($lmp_measurement->field_last_menstrual_period[LANGUAGE_NONE])) {
        $lmp_date = explode(' ', $lmp_measurement->field_last_menstrual_period[LANGUAGE_NONE][0]['value']);
      }
    }
    // No value found at current encounter - check previous CHW encounters.
    if (empty($lmp_date)) {
      foreach ($previous_chw_encounters_data as $previous_chw_encounter_data) {
        $lmp_measurement = $previous_chw_encounter_data['measurements_by_type']['last_menstrual_period'];
        if (empty($lmp_measurement) || empty($lmp_measurement->field_last_menstrual_period[LANGUAGE_NONE])) {
          continue;
        }
        $lmp_date = explode(' ', $lmp_measurement->field_last_menstrual_period[LANGUAGE_NONE][0]['value']);
        break;
      }
    }
    $encounter_data['lmp_date'] = $lmp_date;

    // So far we were constructing data structures to resolve encounter data.
    // Now we have enough info to determine which activities were expected.
    $expected = hedley_reports_prenatal_generate_expected_initial_activities($encounter_data);
    hedley_reports_prenatal_add_history_activities($encounter_data, $expected);
    hedley_reports_prenatal_add_examination_activities($encounter_data, $expected);
    hedley_reports_prenatal_add_immunisation_activities($encounter_data, $expected);
    hedley_reports_prenatal_add_mental_health_activity($encounter_data, $expected);

    $completion_data = [
      'start_date' => $start_date,
      'completion' => hedley_reports_generate_completion_result($expected, $measurements_by_type, $mapping),
    ];

    $encounter->field_reports_data[LANGUAGE_NONE][0]['value'] = json_encode($completion_data);
    node_save($encounter);
  }
}

/**
 * Generates vaccination history data for a prenatal encounter.
 *
 * @param array $encounter_data
 *   An associative array containing details of the current encounter,
 *   including previous encounter data and measurements.
 *
 * @return array
 *   Vaccination history data.
 */
function hedley_reports_prenatal_generate_vaccination_history_data(array $encounter_data) {
  $previous_encounters_data = $encounter_data['previous_nurse_encounters_data'];

  $immunisation_types = [
    'prenatal_tetanus_immunisation',
  ];

  $immunisations_from_previous_encounters = [];
  foreach ($immunisation_types as $immunisation_type) {
    $immunisations_from_previous_encounters[$immunisation_type] = [];
  }

  foreach ($previous_encounters_data as $previous_encounter_data) {
    $measurements_by_type = $previous_encounter_data['measurements_by_type'];
    foreach ($immunisation_types as $immunisation_type) {
      if (empty($measurements_by_type[$immunisation_type])) {
        continue;
      }
      $immunisations_from_previous_encounters[$immunisation_type][] = $measurements_by_type[$immunisation_type];
    }
  }

  return hedley_reports_generate_vaccination_progress_data($immunisations_from_previous_encounters, 'prenatal');
}

/**
 * Generates the list of expected activities for a prenatal encounter.
 *
 * Here we add activities with simple logic from:
 *  - Pregnancy Dating.
 *  - Family Planning.
 *  - Medication.
 *  - Malaria prevention (Resource).
 *  - Danger Signs.
 *  - Symptom Review.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 *
 * @return array
 *   An array of expected activity names.
 */
function hedley_reports_prenatal_generate_expected_initial_activities($encounter_data) {
  $encounter_type = $encounter_data['encounter_type'];
  $previous_nurse_encounters_data = $encounter_data['previous_nurse_encounters_data'];

  $expected = [];
  if ($encounter_type == 'chw-1' || ($encounter_type == 'nurse' && empty($previous_nurse_encounters_data))) {
    $expected[] = 'last_menstrual_period';
  }

  if (in_array($encounter_type, ['nurse', 'nurse-postpartum'])) {
    $expected[] = 'prenatal_family_planning';

    // Symptom Review activity was added on Dec 19, 2021.
    $launch_date = '2021-12-19';
    $launch_date_obj = new DateTime($launch_date);
    if ($encounter_data['start_date_obj'] >= $launch_date_obj) {
      $expected[] = 'prenatal_symptom_review';
    }
  }

  if ($encounter_type == 'nurse' && empty($previous_nurse_encounters_data)) {
    $expected[] = 'medication';
  }

  if ($encounter_type == 'nurse') {
    $mosquito_net_supplied = FALSE;
    foreach ($previous_nurse_encounters_data as $previous_nurse_encounter_data) {
      $resource_measurement = $previous_nurse_encounter_data['measurements_by_type']['resource'];

      if (!empty($resource_measurement) &&  !empty($resource_measurement->field_resources)) {
        if ($resource_measurement->field_resources[LANGUAGE_NONE][0]['value'] == 'mosquito-net') {
          $mosquito_net_supplied = TRUE;
          break;
        }
      }
    }
    if (!$mosquito_net_supplied) {
      $expected[] = 'resource';
    }
  }

  if ($encounter_type != 'nurse-postpartum') {
    $expected[] = 'danger_signs';
  }

  return $expected;
}

/**
 * Adds History activities to the expected list, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_prenatal_add_history_activities(array $encounter_data, array &$expected) {
  $encounter_type = $encounter_data['encounter_type'];
  if ($encounter_type == 'nurse') {
    return;
  }

  $expected[] = 'social_history';
  $previous_nurse_encounters_data = $encounter_data['previous_nurse_encounters_data'];
  if (empty($previous_nurse_encounters_data)) {
    $expected = array_merge(
      $expected,
      ['medical_history', 'obstetric_history', 'obstetric_history_step2']
    );
  }
  else {
    // Outside care activity was added on Dec 19, 2021.
    $launch_date = '2021-12-19';
    $launch_date_obj = new DateTime($launch_date);
    if ($encounter_data['start_date_obj'] >= $launch_date_obj) {
      $expected[] = 'prenatal_outside_care';
    }
  }
}

/**
 * Adds Examinations activities to the expected list, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_prenatal_add_examination_activities(array $encounter_data, array &$expected) {
  $encounter_type = $encounter_data['encounter_type'];
  if (!in_array($encounter_type, ['nurse', 'nurse-postpartum'])) {
    return;
  }

  $expected = array_merge(
    $expected,
    ['vitals', 'prenatal_nutrition', 'core_physical_exam', 'breast_exam']
  );

  if ($encounter_type == 'nurse') {
    $expected[] = 'obstetrical_exam';
  }
  else {
    // GU Exam activity was added on Sept 25, 2022.
    $launch_date = '2022-09-25';
    $launch_date_obj = new DateTime($launch_date);
    if ($encounter_data['start_date_obj'] >= $launch_date_obj) {
      $expected[] = 'prenatal_gu_exam';
    }
  }
}

/**
 * Adds Immunisation activities as expected, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_prenatal_add_immunisation_activities(array $encounter_data, array &$expected) {
  $encounter_type = $encounter_data['encounter_type'];
  if ($encounter_type != 'nurse') {
    return;
  }

  $vaccination_history = hedley_reports_prenatal_generate_vaccination_history_data($encounter_data);
  $start_date_obj = $encounter_data['start_date_obj'];

  $immunisation_type = 'prenatal_tetanus_immunisation';

  if (empty($vaccination_history)) {
    $expected[] = $immunisation_type;
    return;
  }

  $performed = $vaccination_history[$immunisation_type];
  if (empty($performed)) {
    $expected[] = $immunisation_type;
    return;
  }

  $doses = array_keys($performed);
  sort($doses);
  $last_dose = array_reverse($doses)[0];
  $last_dose_for_immunisation = 'dose-5';
  // If all doses we administered, skipping to next immunisation type.
  if ($last_dose == $last_dose_for_immunisation) {
    return;
  }

  // Calculating when next dose is supposed to be administered.
  $interval_between_dosed = '';
  switch ($last_dose) {
    case 'dose-1':
      $interval_between_dosed = '+4 weeks';
      break;

    case 'dose-2':
      $interval_between_dosed = '+6 months';
      break;

    case 'dose-3':
    case 'dose-4':
      $interval_between_dosed = '+12 months';
      break;
  }

  if (empty($interval_between_dosed)) {
    return;
  }

  $last_dose_date = $performed[$last_dose];
  $last_dose_date_obj = new DateTime($last_dose_date);
  $next_dose_date_obj = clone $last_dose_date_obj;
  $next_dose_date_obj->modify($interval_between_dosed);

  // If encounter started after the date when immunisation was supposed
  // to be administered, adding it as expected.
  if ($start_date_obj >= $next_dose_date_obj) {
    $expected[] = $immunisation_type;
  }
}

/**
 * Adds Mental Health activity to the expected list, if conditions match.
 *
 * @param array $encounter_data
 *   An associative array containing data about the encounter.
 * @param array &$expected
 *   An array of expected activity names, passed by reference.
 */
function hedley_reports_prenatal_add_mental_health_activity(array $encounter_data, array &$expected) {
  $encounter_type = $encounter_data['encounter_type'];
  if (!in_array($encounter_type, ['nurse', 'nurse-postpartum'])) {
    return;
  }

  $lmp_date = $encounter_data['lmp_date'];
  if (empty($lmp_date)) {
    return;
  }

  $start_date_obj = $encounter_data['start_date_obj'];
  // Mental Health activity was added on Sept 25, 2022.
  $launch_date = '2022-09-25';
  $launch_date_obj = new DateTime($launch_date);
  if ($start_date_obj < $launch_date_obj) {
    return;
  }

  $lmp_date_obj = new DateTime($lmp_date);
  $interval = $start_date_obj->diff($lmp_date_obj, TRUE);
  // Get the total number of days from the interval
  $total_days = $interval->days;
  $ega_in_weeks = floor($total_days / 7);
  if ($ega_in_weeks < 28) {
    return;
  }

  $performed_previously = FALSE;
  $previous_nurse_encounters_data = $encounter_data['previous_nurse_encounters_data'];
  foreach ($previous_nurse_encounters_data as $previous_nurse_encounter_data) {
    if (!empty($previous_nurse_encounter_data['measurements_by_type']['prenatal_mental_health'])) {
      $performed_previously = TRUE;
      break;
    }
  }

  if (!$performed_previously) {
    $expected[] = 'prenatal_mental_health';
  }
}

/**
 * Checks if a lab test was performed based on the test execution note.
 *
 * Determines if the test execution note indicates that the test was performed
 * by checking if it matches one of the predefined statuses.
 *
 * @param object $test
 *   An object representing the lab test, which contains the test execution
 *   note field.
 *
 * @return bool
 *   TRUE if the test was performed based on the execution note, FALSE
 *   otherwise.
 */
function hedley_reports_lab_test_performed_by_execution_note($test) {
  if (empty($test) || empty($test->field_test_execution_note)) {
    return FALSE;
  }

  return in_array(
    $test->field_test_execution_note[LANGUAGE_NONE][0]['value'],
    ['run-today', 'run-previously', 'run-confirmed-by-lab-tech']
  );
}

/**
 * Determines if a recurrent test is required.
 *
 * Decision is made based on the last test date,
 * encounter start date, and the period between tests.
 *
 * If the last test date is empty, a test is required. Otherwise, it calculates
 * the time difference in months between the last test date and the encounter
 * start date and checks if it meets or exceeds the required period.
 *
 * @param string|null $last_date
 *   The date of the last test in 'Y-m-d' format, or NULL if no test was done.
 * @param DateTime $encounter_start_date_obj
 *   The start date of the encounter as a DateTime object.
 * @param int $period_between_tests
 *   The required period between tests in months.
 *
 * @return bool
 *   TRUE if the recurrent test is required, FALSE otherwise.
 */
function hedley_reports_recurrent_test_required($last_date, DateTime $encounter_start_date_obj, $period_between_tests) {
  if (empty($last_date)) {
    return TRUE;
  }

  $last_date_obj = new DateTime($last_date);
  // Calculate the difference between the encounter start date
  // and the last test date.
  $interval = $encounter_start_date_obj->diff($last_date_obj);

  // Total number of months, accounting for years as well.
  $diff_months = ($interval->y * 12) + $interval->m;

  return $diff_months >= $period_between_tests;
}

/**
 * Resolve the age in months for patient at the time of a specific encounter.
 *
 * @param object $encounter
 *   The encounter object, which includes the participant and person data.
 * @param DateTime $start_date_obj
 *   The date object representing the start date of the encounter.
 *
 * @return int|null
 *   The age in months of the individual at the time of the encounter,
 *   or NULL if an error occurs.
 */
function hedley_reports_resolve_age_in_months_for_individual_encounter($encounter, DateTime $start_date_obj) {
  return hedley_reports_resolve_age_for_individual_encounter($encounter, $start_date_obj);
}

/**
 * Resolve the age for patient at the time of a specific encounter.
 *
 * @param object $encounter
 *   The encounter object, which includes the participant and person data.
 * @param DateTime $start_date_obj
 *   The date object representing the start date of the encounter.
 * @param string $unit
 *   Units for the age. Supports 'day' and 'month'.
 *
 * @return int|null
 *   The age (in units) of the individual at the time of the encounter,
 *   or NULL if an error occurs / incorrect unit set.
 */
function hedley_reports_resolve_age_for_individual_encounter($encounter, DateTime $start_date_obj, $unit = 'month') {
  try {
    // Get participant ID and node.
    $participant_id = $encounter->field_individual_participant[LANGUAGE_NONE][0]['target_id'];
    $participant = node_load($participant_id);

    // Get person ID and node.
    $person_id = $participant->field_person[LANGUAGE_NONE][0]['target_id'];
    $person = node_load($person_id);

    // Get birthdate and date measured.
    $birth_date = explode(' ', $person->field_birth_date[LANGUAGE_NONE][0]['value'])[0];

    // Calculate age in months.
    $birth_date_obj = new DateTime($birth_date);
    $interval = $start_date_obj->diff($birth_date_obj);

    switch ($unit) {
      case 'day':
        return $interval->days;

      case 'month':
        return ($interval->y * 12) + $interval->m;

      default:
        return NULL;
    }
  }
  catch (Exception $e) {
    watchdog('hedley_reports', "Failed to resolve patient age at encounter ID $encounter->nid.");
    return NULL;
  }
}

/**
 * Whether NCDA activity is expected.
 *
 * Conditions for NCDA:
 *  - NCDA feature is enabled.
 *  - Encounter was performed after NCDA launch date.
 *  - Child was under age of 24 months.
 *
 * @param int $age_in_months
 *   Age of the child at a time when encounter was performed.
 * @param DateTime $start_date_obj
 *   The date object representing the start date of the encounter.
 *
 * @return bool
 *   True, if NCDA activity is expected.
 */
function hedley_reports_ncda_expected($age_in_months, DateTime $start_date_obj) {
  $ncda_enabled = variable_get('hedley_admin_feature_ncda_enabled', FALSE);
  $ncda_launch_date = '2023-11-20';
  $ncda_launch_date_obj = new DateTime($ncda_launch_date);

  return $ncda_enabled && $start_date_obj >= $ncda_launch_date_obj && isset($age_in_months) && $age_in_months < 24;
}

/**
 * Load the measurement IDs associated with an individual encounter.
 *
 * This function retrieves the IDs of measurements related to a specific
 * encounter by querying the database for entities linked to the encounter node.
 *
 * @param object $encounter
 *   The encounter object, which includes the node ID and bundle type.
 *
 * @return array
 *   An array of measurement entity IDs associated with the encounter.
 */
function hedley_reports_load_individual_encounter_measurements_ids($encounter) {
  $bundle = $encounter->type;
  $encounter_field = "field_$bundle";
  $query = db_select("field_data_$encounter_field", 'ef');
  $query->addField('ef', 'entity_id');
  $query->condition("ef.{$encounter_field}_target_id", $encounter->nid);
  return $query->execute()->fetchCol();
}

/**
 * Generate a completion result string per expected and completed measurements.
 *
 * This function checks which expected measurements have been completed based on
 * the provided measurements by type, maps both the expected and completed
 * measurement types using the provided mapping array, and then generates
 * a string representing the completion result.
 *
 * @param array $expected
 *   An array of expected measurement types.
 * @param array $measurements_by_type
 *   An associative array where the keys are measurement types and the values
 *   indicate whether the measurement has been completed.
 * @param array $mapping
 *   An associative array where keys are measurement types and values are their
 *   corresponding mapped values.
 *
 * @return string
 *   A string that concatenates the mapped expected and completed measurement
 *   types, separated by a '|' character. The expected and completed values are
 *   each comma-separated within their respective sections.
 */
function hedley_reports_generate_completion_result(array $expected, array $measurements_by_type, array $mapping) {
  $completed = [];
  foreach ($expected as $measurement_type) {
    if (!empty($measurements_by_type[$measurement_type])) {
      $completed[] = $measurement_type;
    }
  }

  foreach ($expected as $index => $measurement_type) {
    $expected[$index] = $mapping[$measurement_type];
  }

  foreach ($completed as $index => $measurement_type) {
    $completed[$index] = $mapping[$measurement_type];
  }

  return implode(',', $expected) . '|' . implode(',', $completed);
}

/**
 * Check if a string ends with a given substring.
 *
 * @param string $haystack
 *   The string to search within.
 * @param string $needle
 *   The substring to check for at the end of the `$haystack` string.
 *
 * @return bool
 *   TRUE if `$haystack` ends with `$needle`, FALSE otherwise.
 */
function hedley_reports_ends_with($haystack, $needle) {
  $length = strlen($needle);
  if (!$length) {
    return TRUE;
  }
  return substr($haystack, -$length) === $needle;
}

/**
 * Removes the specified prefix and suffix from a string, if both are present.
 *
 * This function checks if the given string starts with the specified prefix
 * and ends with the specified suffix. If both conditions are met, the function
 * returns the substring that remains after removing the prefix and suffix.
 * If either the prefix or suffix is not found, the original string is returned.
 *
 * @param string $string
 *   The input string from which the prefix and suffix will be removed.
 * @param string $pref
 *   The prefix to be removed from the start of the string.
 * @param string $suff
 *   The suffix to be removed from the end of the string.
 *
 * @return string
 *   The string without the specified prefix and suffix, or the original
 *   string if the prefix or suffix is not found.
 */
function hedley_reports_drop_prefix_and_suffix(string $string, string $pref, string $suff) {
  if (strpos($string, $pref) !== 0 || substr($string, -strlen($suff)) !== $suff) {
    return $string;
  }

  // Extract the part between the prefix and suffix.
  $start = strlen($pref);
  $length = strlen($string) - $start - strlen($suff);

  return substr($string, $start, $length);
}
