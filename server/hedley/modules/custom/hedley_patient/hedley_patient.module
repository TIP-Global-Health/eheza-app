<?php

/**
 * @file
 * Code for the Hedley Patient feature.
 */

include_once 'hedley_patient.features.inc';

define('HEDLEY_PATIENT_EDUCATION_NONE', 0);
define('HEDLEY_PATIENT_EDUCATION_PRIMARY', 1);
define('HEDLEY_PATIENT_EDUCATION_VOCATIONAL', 2);
define('HEDLEY_PATIENT_EDUCATION_SECONDARY', 3);
define('HEDLEY_PATIENT_EDUCATION_DIPLOMA', 4);
define('HEDLEY_PATIENT_EDUCATION_UNIVERSITY', 5);
define('HEDLEY_PATIENT_EDUCATION_ADVANCED', 6);

/**
 * Implements hook_node_insert().
 */
function hedley_patient_node_insert($node) {
  if ($node->type != 'pmtct_participant') {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  hedley_patient_recalculate_shards_for_person($wrapper->field_person->getIdentifier());
  hedley_patient_recalculate_shards_for_person($wrapper->field_adult->getIdentifier());
}

/**
 * Implements hook_node_update().
 */
function hedley_patient_node_update($node) {
  if ($node->type != 'person') {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper_orig = entity_metadata_wrapper('node', $node->orig);
  $shards = $wrapper->field_shards->value(['identifier' => TRUE]);
  $shards_orig = $wrapper_orig->field_shards->value(['identifier' => TRUE]);

  if (empty(array_diff($shards, $shards_orig))) {
    return;
  }

  // hedley_patient_recalculate_shards_for_person_content($node->nid);
}

function hedley_patient_recalculate_shards_for_person($nid) {
  $wrapper = entity_metadata_wrapper('node', $nid);
  $current_shards = $wrapper->field_shards->value(['identifier' => TRUE]);

  // Figure out what the shards for this person ought to be.
  $shards = hedley_patient_shards_for_person_by_pmtct_participants($nid);

  if (empty(array_diff($shards, $current_shards))) {
    return;
  }

  $wrapper->field_shards->set($shards);
  $wrapper->save();
}

/**
 * Recalculate and potentially update shard assignments.
 *
 * @param int $nid
 *   The node ID of a person to recalculate for.
 */
function hedley_patient_recalculate_shards_for_person_content($nid) {
  $wrapper = entity_metadata_wrapper('node', $nid);
  $shards = $wrapper->field_shards->value(['identifier' => TRUE]);
  sort($shards);

  // Now, we need to cycle through the sharded entities for the person and
  // update those that do not match, so that they will get sent to the right
  // devices.
  $query = db_select('node', 'n');

  // Join field_shards and field_person. So, we're getting all sharded nodes
  // that have a field_person.
  $query->join('field_data_field_person', 'p', 'p.entity_id = n.nid');
  $query->leftJoin('field_data_field_shards', 's', 's.entity_id = n.nid');

  // Limit to the person we're interested in.
  $query->condition('p.field_person_target_id', $nid);

  // Limit to sharded nodes.
  $sharded = array_keys(HEDLEY_RESTFUL_SHARDED);
  $query->condition('n.type', $sharded);

  $query->fields('n', ['nid', 'type']);
  $query->fields('s', ['field_shards_target_id']);

  $tmp = $query->execute()->fetchAll();
  $result = $query->execute();
  $measurement = [];

  // Group the resulting shards by the nid of the sharded node.
  foreach ($result as $record) {
    if (empty($measurement[$record->nid])) {
      $measurement[$record->nid] = [];
    }

    if (!empty($record->field_shards_target_id)) {
      $measurement[$record->nid][] = $record->field_shards_target_id;
    }
  }

  // For each sharded node, check whether we need to update it.
  foreach ($measurement as $key => $value) {
    sort($value);
    if ($value != $shards) {
      $wrapper = entity_metadata_wrapper('node', $key);
      $wrapper->field_shards->set($shards);
      $wrapper->save();
    }
  }
}

/**
 * Which shards should a person's measurements be sent to?
 *
 * @param int $nid
 *   The node ID of the person.
 *
 * @return array
 *   An array of shard ID's.
 */
function hedley_patient_shards_for_person_by_pmtct_participants($nid) {
  // For now, we just look at their pmtct_participant records.  If they have
  // one, we send their measurements to the associated health center.
  //
  // We do this as a db_select because we need an `OR`, and we can
  // do it all at once with several joins, which is pleasant.
  $query = db_select('node', 'n');

  $query->condition('n.type', 'pmtct_participant');

  $query->join('field_data_field_adult', 'adult', 'adult.entity_id = n.nid');
  $query->join('field_data_field_person', 'child', 'child.entity_id = n.nid');

  $adult_or_child = db_or();
  $adult_or_child->condition('adult.field_adult_target_id', $nid);
  $adult_or_child->condition('child.field_person_target_id', $nid);

  $query->condition($adult_or_child);

  $query->join('field_data_field_clinic', 'clinic', 'clinic.entity_id = n.nid');
  $query->join('field_data_field_health_center', 'hc', 'hc.entity_id = clinic.field_clinic_target_id');

  $query->fields('hc', ['field_health_center_target_id']);
  $query->distinct();

  $shards = $query->execute()->fetchCol();

  if ($shard = hedley_device_shard_by_health_center($nid)) {
    if ($shard && !in_array($shard, $shards)) {
      $shards[] = $shard;
    }
  }

  return $shards;
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Add to a query which needs to get all entities without a 'field_relationship'
 * value (is null).
 */
function hedley_patient_query_exclude_existing_relationships_alter(QueryAlterableInterface $query) {
  $query->leftJoin('field_data_field_relationship', 'r', 'node.nid = r.entity_id');
  $query->isNull('r.field_relationship_value');
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function hedley_patient_form_mother_node_form_alter(&$form, &$form_state, $form_id) {
  $form['#validate'][] = 'hedley_patient_mother_birth_date_validation';

  $params = drupal_get_query_parameters();

  if (!isset($params['type']) || $params['type'] != 'caregiver') {
    $form['field_relationship'][LANGUAGE_NONE]['#default_value'] = ['mother'];
    return;
  }

  $form['field_relationship'][LANGUAGE_NONE]['#default_value'] = ['caregiver'];
}

/**
 * Validation callback for mother node form.
 *
 * When the mother node is a caregiver, date of birth is not required.
 */
function hedley_patient_mother_birth_date_validation($form, &$form_state) {
  $relationship_value = $form_state['values']['field_relationship'][LANGUAGE_NONE][0]['value'];
  $birth_date_value = $form_state['values']['field_date_birth'][LANGUAGE_NONE][0]['value'];

  if ($relationship_value == 'mother' && empty($birth_date_value)) {
    form_set_error('field_date_birth', t('The date of birth field is required when adding a mother.'));
  }
}
