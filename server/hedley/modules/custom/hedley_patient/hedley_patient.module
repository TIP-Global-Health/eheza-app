<?php

/**
 * @file
 * Code for the Hedley Patient feature.
 */

include_once 'hedley_patient.features.inc';

define('HEDLEY_PATIENT_EDUCATION_NONE', 0);
define('HEDLEY_PATIENT_EDUCATION_PRIMARY', 1);
define('HEDLEY_PATIENT_EDUCATION_VOCATIONAL', 2);
define('HEDLEY_PATIENT_EDUCATION_SECONDARY', 3);
define('HEDLEY_PATIENT_EDUCATION_DIPLOMA', 4);
define('HEDLEY_PATIENT_EDUCATION_UNIVERSITY', 5);
define('HEDLEY_PATIENT_EDUCATION_ADVANCED', 6);

/**
 * Implements hook_menu().
 */
function hedley_patient_menu() {
  $items = [];

  $items['admin/content/consolidate-patients'] = [
    'type' => MENU_LOCAL_TASK,
    'title' => 'Consolidate Patients',
    'description' => 'Consolidate original patient with its duplicate',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['hedley_patient_consolidate_patients_form'],
    'access callback' => 'hedley_admin_administrators_access',
    'weight' => 2,
  ];

  return $items;
}

/**
 * Implements hook_node_insert().
 */
function hedley_patient_node_insert($node) {
  if ($node->type != 'pmtct_participant') {
    return;
  }

  if (isset($node->imported)) {
    // No need to run recalculations for person during import.
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  hedley_patient_recalculate_shards_for_person($wrapper->field_person->getIdentifier());
  hedley_patient_recalculate_shards_for_person($wrapper->field_adult->getIdentifier());
}

/**
 * Implements hook_node_update().
 */
function hedley_patient_node_update($node) {
  if ($node->type != 'person') {
    return;
  }

  $wrapper_orig = entity_metadata_wrapper('node', $node->original);
  $shards_orig = $wrapper_orig->field_shards->value(['identifier' => TRUE]);

  if (empty($shards_orig)) {
    // Having empty shards on update is a sign for person creation during
    // patients import process. Therefore, know there's no content to
    // recalculate shards for.
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $shards = $wrapper->field_shards->value(['identifier' => TRUE]);

  if (hedley_patient_arrays_equal($shards, $shards_orig)) {
    return;
  }

  hedley_patient_recalculate_shards_for_person_content($node->nid);
}

/**
 * Recalculate and potentially update shard assignments for person.
 *
 * @param int $nid
 *   The node ID of a person to recalculate for.
 *
 * @throws \EntityMetadataWrapperException
 */
function hedley_patient_recalculate_shards_for_person($nid) {
  $wrapper = entity_metadata_wrapper('node', $nid);
  $current_shards = $wrapper->field_shards->value(['identifier' => TRUE]);

  // Figure out what the shards for this person ought to be.
  $shards = hedley_patient_shards_for_person_by_pmtct_participants($nid);

  if (hedley_patient_arrays_equal($shards, $current_shards)) {
    return;
  }

  $wrapper->field_shards->set($shards);
  $wrapper->save();
}

/**
 * Recalculate and potentially update shard assignments for person content.
 *
 * Cycle through the sharded entities for the person and update
 * those that do not match, so that they will get sent to the right devices.
 *
 * @param int $person_id
 *   The node ID of a person to recalculate for.
 *
 * @throws \EntityMetadataWrapperException
 */
function hedley_patient_recalculate_shards_for_person_content($person_id) {
  $wrapper = entity_metadata_wrapper('node', $person_id);
  $person_shards = $wrapper->field_shards->value(['identifier' => TRUE]);

  // On first step, we fetch all content that is associated with person
  // using person, adult and related_to fields.
  // These are group and individual measurements, relationships,
  // and group and individual participants.
  $association_fields = [
    'field_person',
    'field_adult',
    'field_related_to',
  ];
  $entries = hedley_general_get_person_content_associated_by_fields($person_id, $association_fields);

  $ids = $individual_participants = [];
  foreach ($entries as $entry) {
    $ids[] = $entry->entity_id;
    if ($entry->bundle == 'individual_participant') {
      $individual_participants[] = $entry->entity_id;
    }
  }

  // On second step, we fetch all content that is associated with person
  // by individual_participant field.
  // These are individual encounters - antenatal, nutrition, ...
  if (!empty($individual_participants)) {
    $query = db_select('node', 'n');
    $query->join('field_data_field_individual_participant', 'ip', 'ip.entity_id = n.nid');

    // Limit to individual participants we're interested in.
    $query->condition('ip.field_individual_participant_target_id', $individual_participants);
    $query->addField('n', 'nid');

    $ids = array_merge($ids, $query->execute()->fetchCol());
  }

  if (empty($ids)) {
    return;
  }

  $nodes = node_load_multiple($ids);
  foreach ($nodes as $node) {
    $wrapper = entity_metadata_wrapper('node', $node);
    $node_shards = $wrapper->field_shards->value(['identifier' => TRUE]);

    if (!hedley_patient_arrays_equal($person_shards, $node_shards)) {
      $wrapper->field_shards->set($person_shards);
      $wrapper->save();
    }
  }
}

/**
 * Which shards should a person's measurements be sent to?
 *
 * @param int $nid
 *   The node ID of the person.
 *
 * @return array
 *   An array of shard ID's.
 */
function hedley_patient_shards_for_person_by_pmtct_participants($nid) {
  $shard_by_health_center = hedley_general_shard_by_health_center($nid);
  $shards = !empty($shard_by_health_center) ? [$shard_by_health_center] : [];

  $pmtct_participants_ids = hedley_person_pmtct_participants_for_person($nid);
  if (!empty($pmtct_participants_ids)) {
    $pmtct_participants = node_load_multiple($pmtct_participants_ids);
    foreach ($pmtct_participants as $pmtct_participant) {
      $wrapper = entity_metadata_wrapper('node', $pmtct_participant);
      $clinic_id = $wrapper->field_clinic->getIdentifier();
      $shard = hedley_general_shard_by_health_center($clinic_id);
      if (!empty($shard)) {
        $shards[] = $shard;
      }
    }
  }

  return array_unique($shards);
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Add to a query which needs to get all entities without a 'field_relationship'
 * value (is null).
 */
function hedley_patient_query_exclude_existing_relationships_alter(QueryAlterableInterface $query) {
  $query->leftJoin('field_data_field_relationship', 'r', 'node.nid = r.entity_id');
  $query->isNull('r.field_relationship_value');
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function hedley_patient_form_mother_node_form_alter(&$form, &$form_state, $form_id) {
  $form['#validate'][] = 'hedley_patient_mother_birth_date_validation';

  $params = drupal_get_query_parameters();

  if (!isset($params['type']) || $params['type'] != 'caregiver') {
    $form['field_relationship'][LANGUAGE_NONE]['#default_value'] = ['mother'];
    return;
  }

  $form['field_relationship'][LANGUAGE_NONE]['#default_value'] = ['caregiver'];
}

/**
 * Validation callback for mother node form.
 *
 * When the mother node is a caregiver, date of birth is not required.
 */
function hedley_patient_mother_birth_date_validation($form, &$form_state) {
  $relationship_value = $form_state['values']['field_relationship'][LANGUAGE_NONE][0]['value'];
  $birth_date_value = $form_state['values']['field_date_birth'][LANGUAGE_NONE][0]['value'];

  if ($relationship_value == 'mother' && empty($birth_date_value)) {
    form_set_error('field_date_birth', t('The date of birth field is required when adding a mother.'));
  }
}

/**
 * Checks if array1 is equal to array2.
 *
 * Equal means that both have same number of elements, and all elements
 * at array1 also appear at array2.
 *
 * @param array $array1
 *   First array.
 * @param array $array2
 *   Second array.
 *
 * @return bool
 *   True, if array1 is equal to array2.
 */
function hedley_patient_arrays_equal(array $array1, array $array2) {
  return count($array1) == count($array2) && empty(array_diff($array1, $array2));
}

function hedley_patient_consolidate_patients_form($form, &$form_state) {
  $form['person1'] = array(
    '#type' => 'textfield',
    '#title' => t('Node ID of the original patient'),
    '#required' => TRUE,
  );

  $form['person2'] = array(
    '#type' => 'textfield',
    '#title' => t('Node ID of the duplicate patient'),
    '#required' => TRUE,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Consolidate Patients'),
  );

  return $form;
}

function hedley_patient_consolidate_patients_form_submit($form, &$form_state) {
  // Get the values of the input fields.
  $original_patient = $form_state['values']['person1'];
  $duplicate_patient = $form_state['values']['person2'];

  // Build the Drush command to execute.
  $drush_command = 'drush consolidate-patients';
  $arguments = '--original=' . escapeshellarg($original_patient) . ' --duplicate=' . escapeshellarg($duplicate_patient);

  // Execute the Drush command as a shell command.
  $command = $drush_command . ' ' . $arguments;
  $output = shell_exec($command);

  // Display the output on the page.
  drupal_set_message($output);
}
